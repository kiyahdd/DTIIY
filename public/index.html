<!DOCTYPE html>

<html lang="en">

<head>
<meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<title>False Flag Fixerâ„¢</title>

<!-- Google Fonts - Raleway for headings -->

<link rel="preconnect" href="https://fonts.googleapis.com">

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<link href="https://fonts.googleapis.com/css2?family=Raleway:wght@600;700&display=swap" rel="stylesheet">

<!-- Prevent stale caches during development -->

<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />

<meta http-equiv="Pragma" content="no-cache" />

<meta http-equiv="Expires" content="0" />

<script>

  // Global backend URL configuration
  if (window.location.hostname.includes('replit.dev') || window.location.hostname.includes('repl.co')) { window.BACKEND_URL = window.location.origin; } else { window.BACKEND_URL = 'http://localhost:5000'; }

  // Cache-busting helper: call forceHardReload() to reload with version

  window.__BUILD__ = '2025-11-05-01';

  console.log('ðŸ”§ [BUILD] FREE Cards Updated - Build 2025-11-05-01');

  console.log('ðŸ”§ [BUILD] Hella Sus label: "AI detectors are gonna lose it - time for the full glow-up âœ¨"');

  console.log('ðŸ”§ [BUILD] Kinda Sus label: "These sentences are lowkey cooked. Not on Lil\' Sus\'s watch."');

  console.log('ðŸ”§ [BUILD] Kinda Sus color: #FFF000');

  (function () {

    const params = new URLSearchParams(location.search);

    window.forceHardReload = function () {

      params.set('v', window.__BUILD__);

      location.search = params.toString();

    };

    // Auto one-time refresh if the page URL lacks the current build version

    try {

      const current = params.get('v');

      const key = 'reloadedForVersion-' + window.__BUILD__;

      if (current !== window.__BUILD__ && !sessionStorage.getItem(key)) {

        sessionStorage.setItem(key, '1');

        params.set('v', window.__BUILD__);

        location.replace(location.pathname + '?' + params.toString() + location.hash);

        return; // stop running old page

      }

    } catch (e) {}

    console.log('[FFF] Build', window.__BUILD__, '- if changes don\'t appear, run forceHardReload() in console');

  })();



  // AUTO-LOG CAPTURE: Save all console logs to localStorage so we can retrieve them after hangs

  (function() {

    const MAX_LOGS = 500; // Keep last 500 log entries

    const LOG_KEY = 'fff_debug_logs';



    // Get existing logs

    function getLogs() {

      try {

        const stored = localStorage.getItem(LOG_KEY);

        return stored ? JSON.parse(stored) : [];

      } catch (e) {

        return [];

      }

    }



    // Save logs (keep only last MAX_LOGS)

    function saveLog(logEntry) {

      try {

        const logs = getLogs();

        logs.push(logEntry);

        if (logs.length > MAX_LOGS) {

          logs.shift(); // Remove oldest

        }

        localStorage.setItem(LOG_KEY, JSON.stringify(logs));

      } catch (e) {

        // localStorage full or error - ignore

      }

    }



    // Intercept console methods

    const originalLog = console.log;

    const originalError = console.error;

    const originalWarn = console.warn;



    console.log = function(...args) {

      saveLog({

        type: 'log',

        time: new Date().toISOString(),

        message: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ')

      });

      originalLog.apply(console, args);

    };



    console.error = function(...args) {

      saveLog({

        type: 'error',

        time: new Date().toISOString(),

        message: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ')

      });

      originalError.apply(console, args);

    };



    console.warn = function(...args) {

      saveLog({

        type: 'warn',

        time: new Date().toISOString(),

        message: args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ')

      });

      originalWarn.apply(console, args);

    };



    // Function to retrieve logs (call this after a hang)

    window.getDebugLogs = function() {

      const logs = getLogs();

      console.log('ðŸ“‹ Retrieved', logs.length, 'log entries from localStorage');

      return logs;

    };



    // Function to clear logs

    window.clearDebugLogs = function() {

      localStorage.removeItem(LOG_KEY);

      console.log('âœ… Debug logs cleared');

    };



    // Function to download logs as text file

    window.downloadDebugLogs = function() {

      const logs = getLogs();

      const text = logs.map(l => `[${l.time}] ${l.type.toUpperCase()}: ${l.message}`).join('\n');

      const blob = new Blob([text], { type: 'text/plain' });

      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');

      a.href = url;

      a.download = `fff-debug-logs-${Date.now()}.txt`;

      a.click();

      URL.revokeObjectURL(url);

    };



    console.log('âœ… Auto-log capture enabled. After a hang, run: getDebugLogs() or downloadDebugLogs()');

  })();

</script>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=Open+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" />

<style>

/* ALL YOUR EXISTING CSS STYLES REMAIN EXACTLY THE SAME */

* { box-sizing: border-box; margin: 0; padding: 0; }

html {

  overflow-y: auto; /* Show scrollbar only when content overflows */

  overflow-x: hidden;

}

body { 

  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 

  background: linear-gradient(to bottom, #0b0646, #00a8e8);

  min-height: 100vh;

  display: flex;

  flex-direction: column;

  width: 100%;

  overflow-x: hidden;

  margin: 0;

  padding: 0;

  position: relative;

  scrollbar-gutter: stable;

}



/* Prevent body from shifting when modals appear */

body.modal-open {

  overflow: hidden;

  /* Removed padding-right to prevent layout shift */

}



.panic-banner {

  background: linear-gradient(90deg, #ef4444, #dc2626);

  color: #fff;

  padding: 12px 20px;

  text-align: center;

  font-weight: 700;

  position: sticky;

  top: 0;

  z-index: 999;

  box-shadow: 0 2px 10px rgba(0,0,0,.2);

  display: none;

  width: 100%;

}

.panic-banner a {

  color: #fef3c7;

  text-decoration: underline;

  margin-left: 10px;

  font-weight: 800;

}



.hero-section { 

  text-align: center; 

  padding: 30px 20px 20px; 

  color: #fff;

  width: 100%;

  box-sizing: border-box;

  display: flex;

  flex-direction: column;

  align-items: center;

  justify-content: flex-start;

}

.hero-title { 

  font-size: clamp(2em,5vw,3em); 

  font-weight: 700; 

  font-family: 'Raleway', sans-serif;

  margin: 0 0 12px; 

  line-height: 1.1; 

  color: #fff; 

  text-shadow: 2px 2px 4px rgba(0,0,0,.2);

  text-align: center;

  width: 100%;

  letter-spacing: -0.25px;

}

.hero-subtitle { 

  font-size: clamp(1em,2.5vw,1.2em); 

  margin: 0 auto !important; 

  opacity: .95; 

  max-width: 100%;

  text-align: center !important;

  width: 100%;

  display: block;

  box-sizing: border-box; 

  line-height: 1.4; 

  color: #fff;

  position: relative;

  left: 0 !important;

  right: 0 !important;

  transform: translateX(0) !important;

  align-self: center;

}



/* Stabilize the main container */

.main-container {

  width: 100%;

  max-width: 1000px; /* Pro + QuickFix flow: same width as Pro dashboard */

   margin: -24px auto 30px; /* Negative top margin to move form up 1/4" (24px) */

  padding: 0 24px; /* Match Free results wrapper padding for consistent bordered card width */

  background: #fff;

  border-radius: 20px;

  overflow: hidden;

  box-shadow: 0 20px 40px rgba(0,0,0,.2);

  box-sizing: border-box;

  position: static;

  left: auto;

  right: auto;

  transform: none;

}





.input-section {

  padding: 30px;

  background: #f8f9fa;

  position: relative;

  width: 100%;

  box-sizing: border-box;

}





/* Add min-height to prevent collapse */

#quickfixFlow,

#inputSection,

#resultsContainer {

  min-height: 100vh;

  width: 100%;

}



/* Prevent layout shifts on form focus */

input, textarea, button {

  outline: none;

  border: none;

  box-sizing: border-box;

}



input:focus, textarea:focus {

  outline: 2px solid #2ecc71;

  outline-offset: 2px;

}



/* Add min-height to prevent collapse */

.page-wrapper {

  min-height: auto;

  width: 100%;

  display: flex;

  flex-direction: column;

  align-items: center;

  justify-content: flex-start;

  overflow-x: hidden;

  margin: 0;

  padding: 0;

}



/* Modal positioning */

.modal {

  position: fixed;

  top: 0;

  left: 0;

  width: 100%;

  height: 100vh;

  background: rgba(0, 0, 0, 0.8);

  display: flex;

  align-items: center;

  justify-content: center;

  z-index: 10000;

}



/* === PRO FLOW STYLES (Steps 7â€“9) - Fixed to match QuickFix === */



/* Step 6 - Pro Dashboard - FORCE WHITE */

/* Note: .quickfix-step already has display:none by default, and .active makes it visible */



#quickfixStep6 .main-container {

  max-width: 1000px !important;

  background: #ffffff !important;

  background-color: #ffffff !important;

  border-radius: 20px !important;

  box-shadow: 0 20px 40px rgba(0,0,0,.2) !important;

  padding-top: 60px !important;

}



#quickfixStep6 .input-section {

  background: #ffffff !important;

  background-color: #ffffff !important;

  padding-top: 0 !important;

}



#quickfixStep6 .main-container {

  max-width: 1000px !important;

  width: 100% !important;

  margin: 0 auto !important;

}



/* BULLETPROOF - Prevent any horizontal scrolling or layout shifts */

* {

  max-width: 100%;

  box-sizing: border-box;

}





/* Ensure form elements don't cause layout shifts */

textarea, input[type="text"] {

  resize: vertical;

  min-height: 40px;

}



.upload-area {

  border: 3px dashed #0b0646;

  border-radius: 15px;

  padding: 30px 20px;

  text-align: center;

  background: #fff;

  transition: .3s;

  cursor: pointer;

  position: relative;

  animation: pulse 2s infinite;

  margin-bottom: 20px;

}



.upload-area:hover {

  border-color: #090535;

  background: #f7fafc;

  transform: translateY(-2px);

}



@keyframes pulse {

  0%, 100% { border-color: #0b0646; }

  50% { border-color: #2ecc71; }

}



@keyframes pulseRed {

  0%, 100% { 

    border-color: #dc2626;

    box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7);

  }

  50% { 

    border-color: #ef4444;

    box-shadow: 0 0 0 8px rgba(220, 38, 38, 0);

  }

}



@keyframes bonusRescanPulse {

  0%, 100% {

    box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.5), 0 4px 12px rgba(34, 197, 94, 0.3);

    transform: scale(1);

    border-color: #4ade80;

  }

  50% {

    box-shadow: 0 0 40px 20px rgba(34, 197, 94, 0.6), 0 0 0 16px rgba(34, 197, 94, 0.25);

    transform: scale(1.04);

    border-color: #22c55e;

  }

}



@keyframes pulsate {

  0%, 100% {

    transform: scale(1);

  }

  50% {

    transform: scale(1.08);

  }

}



.false-flag-stamp-glow {

  animation: pulsate 2s ease-in-out infinite;

  transform-origin: center;

}



/* Ensure Clean No Sus CTA text is always medium navy blue */

#quickfixStep3CleanNoSusCTAText {

  color: #1e3a8a !important;

}



@keyframes slowRotate {

  from { transform: rotate(0deg); }

  to { transform: rotate(360deg); }

}



.authorship-section-pulse {

  animation: pulseRed 1.5s ease-in-out infinite;

}

#essayInput {

  width: 100%;

  height: 150px;

  padding: 20px;

  border: none;

  border-radius: 12px;

  font-size: 16px;

  font-family: inherit;

  resize: vertical;

  margin-top: 15px;

  box-shadow: inset 0 2px 8px rgba(0,0,0,.1);

  line-height: 1.6;

}

#essayInput:focus {

  outline: 3px solid #0b0646;

  outline-offset: 2px;

}

.char-counter {

  text-align: right;

  font-size: .9em;

  margin-top: 8px;

  color: #666;

  font-weight: 600;

}

.char-counter.warning { color: #f59e0b; }

.char-counter.danger { color: #ef4444; }

.scans-left {

  text-align: center;

  margin-top: 8px;

  font-size: .9em;

  color: #666;

  font-weight: 600;

}

.scans-left.warning { color: #f59e0b; }

.scans-left.danger { color: #ef4444; }



.button-group {

  display: flex;

  gap: 10px;

  margin-top: 20px;

  flex-wrap: wrap;

}



.scan-button, .emergency-button, .pro-button {

  flex: 1;

  padding: 12px 16px !important;

  border: none;

  border-radius: 12px;

  font-size: 0.95em !important;

  font-weight: 700;

  cursor: pointer;

  transition: .3s;

  letter-spacing: 0.5px;

  min-width: 160px !important;

  position: relative;

  line-height: 1.2 !important;

  height: auto !important;

}



.scan-button {

  background: linear-gradient(to bottom, #00a8e8, #0b0646);

  color: #fff;

  box-shadow: 0 4px 12px rgba(16,185,129,.3);

}

.scan-button:hover:not(:disabled) {

  background: linear-gradient(to bottom, #0087c4, #06082e);

  transform: translateY(-2px);

  box-shadow: 0 6px 20px rgba(16,185,129,.4);

}

.scan-button:disabled {

  background: #9ca3af;

  cursor: not-allowed;

}



/* Pro user disabled CTA styling */

.cta-disabled-for-pro {

  opacity: 0.5 !important;

  pointer-events: none !important;

  cursor: not-allowed !important;

  position: relative !important;

}



/* Removed ::after overlay - keeping only blurred/greyed out appearance */



/* Test Mode Toggle Button */

#testModeToggle {

  position: fixed;

  top: 20px;

  right: 20px;

  z-index: 9999;

  background: linear-gradient(135deg, #f59e0b, #d97706);

  color: white;

  border: 2px solid #fbbf24;

  border-radius: 12px;

  padding: 10px 16px;

  font-size: 13px;

  font-weight: 700;

  cursor: pointer;

  box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);

  transition: all 0.3s ease;

  display: flex;

  align-items: center;

  gap: 8px;

  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

}



#testModeToggle:hover {

  transform: translateY(-2px);

  box-shadow: 0 6px 16px rgba(245, 158, 11, 0.5);

  background: linear-gradient(135deg, #fbbf24, #f59e0b);

}



#testModeToggle.pro-mode {

  background: linear-gradient(135deg, #00a8e8, #0087c4);

  border-color: #00d4ff;

  box-shadow: 0 4px 12px rgba(0, 168, 232, 0.4);

}



#testModeToggle.pro-mode:hover {

  background: linear-gradient(135deg, #00d4ff, #00a8e8);

  box-shadow: 0 6px 16px rgba(0, 168, 232, 0.5);

}



#testModeToggle .test-mode-icon {

  font-size: 16px;

}



#testModeToggle .test-mode-text {

  white-space: nowrap;

}



.emergency-button {

  background: #ff6b00;

  color: #fff;

  box-shadow: 0 4px 12px rgba(255,107,0,.3);

}

.emergency-button:hover {

  background: #e55a00;

  transform: translateY(-2px);

  box-shadow: 0 6px 20px rgba(255,107,0,.4);

}



.pro-button {

  background: linear-gradient(to bottom, #00a8e8, #0b0646);

  color: #fff;

  box-shadow: 0 4px 12px rgba(16,185,129,.3);

}

.pro-button:hover {

  background: linear-gradient(to bottom, #0087c4, #06082e);

  transform: translateY(-2px);

  box-shadow: 0 6px 20px rgba(16,185,129,.4);

}



.results-container {

  display: none;

  padding: 20px;

  background: linear-gradient(135deg, #0b0646 0%, #1a1f6e 100%);

  min-height: 100vh;

  position: relative; /* Changed from fixed */

  width: 100%;

  overflow-x: hidden;

  transform: none;

  will-change: auto;

}

.results-container.show {

  display: block !important;

  /* Temporarily disabled animation to debug bounce */

  /* animation: slideIn .5s ease-out !important; */

  width: 100%;

  margin: 0 auto;

  left: 0;

  right: 0;

}



.results-wrapper {

  width: 100%;

  max-width: 900px; /* Changed from 720px to 900px (WIDER!) */

  margin: 0 auto;

  padding: 24px;

  box-sizing: border-box;

  background: #ffffff;

  border-radius: 16px;

  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.25);

  display: flex;

  flex-direction: column;

  gap: 20px;

}

@keyframes slideIn {

  from { 

    opacity: 0; 

    transform: translateY(20px);

  }

  to { 

    opacity: 1; 

    transform: translateY(0);

  }

}



.card {

  background: white;

  border-radius: 16px;

  padding: 20px;

  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);

  border: 1px solid rgba(255, 255, 255, 0.2);

}



.warning-card { text-align: center; }

.warning-icon { 

  font-size: 40px; 

  margin-bottom: 10px; 

  display: block; 

}

.warning-title {

  font-size: 22px;

  font-weight: 800;

  color: #1f2937;

  margin-bottom: 15px;

}

.score-display {

  font-size: 50px;

  font-weight: 900;

  margin-bottom: 8px;

  display: flex;

  align-items: center;

  justify-content: center;

  gap: 12px;

  color: #dc2626;

}



.score-number {

  font-size: 28px !important;

  font-weight: 900 !important;

  color: #dc2626; /* Removed !important so JavaScript can override */

}

.warning-emoji {

  font-size: 50px;

  animation: bounce 2s infinite;

}

@keyframes pointBackForth {

  0%, 100% {

    transform: translateX(0);

  }

  50% {

    transform: translateX(10px);

  }

}



.lil-sus-pulsate {

  animation: pointBackForth 1.5s ease-in-out infinite;

}



/* QuickFix "All trigger words" modal */

#quickfixAllTriggersModal {

  display: none;

}



@keyframes bounce {

  0%, 20%, 50%, 80%, 100% { transform: translateY(0); }

  40% { transform: translateY(-8px); }

  60% { transform: translateY(-4px); }

}



@keyframes pulse-urgent {

  0%, 100% { 

    transform: scale(1);

    box-shadow: 0 0 0 0 rgba(255, 149, 0, 0.7);

  }

  50% { 

    transform: scale(1.05);

    box-shadow: 0 0 0 8px rgba(255, 149, 0, 0);

  }

}

/* PROGRESS BAR CONTAINER */

.progress-container {

  margin: 24px 0 32px 0;

  width: 100%;

}



/* THE BAR BACKGROUND */

.progress-bar {

  height: 8px;

  background: #e5e7eb;

  border-radius: 4px;

  position: relative;

  margin-bottom: 12px;

  border: 1px solid #d1d5db;

  overflow: visible; /* IMPORTANT: Allow indicator to show */

}

/* 50% midway indicator line on progress bar */

.progress-bar::after {

  content: '';

  position: absolute;

  left: 50%;

  top: 0;

  bottom: 0;

  width: 1px;

  background: #9ca3af;

  z-index: 1;

  transform: translateX(-50%);

  opacity: 0.8;

}



/* THE FILL (animates) */

.progress-fill {

  height: 100%;

  width: 0%; /* START AT 0% */

  background: linear-gradient(

    to right,

    #10b981 0%,     /* Green: 0-29% (Clean) */

    #10b981 29%,

    #FFF000 30%,    /* Yellow: 30-69% (Kinda Sus) - correct QuickFix yellow */

    #FFF000 69%,

    #ef4444 70%,    /* Red: 70-100% (Hella Sus) */

    #ef4444 100%

  );

  border-radius: 4px;

  position: absolute;

  top: 0;

  left: 0;

  transition: width 3s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smooth easing - slowed down */

  z-index: 1;

}

/* The little circle marker that shows the exact score - matches QuickFix style */

.sus-marker {

  position: absolute;

  top: 50%;

  transform: translate(-50%, -50%);

  width: 16px;

  height: 16px;

  background: white;

  border: 3px solid currentColor;

  border-radius: 50%;

  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);

  z-index: 10;

  transition: left 0.5s ease, color 0.5s ease;

  pointer-events: none;

}

.sus-marker.high-sus {

  color: #dc2626;

}

.sus-marker.medium-sus {

  color: #FFF000;

}

.sus-marker.low-sus {

  color: #00a8e8;

}

/* THE INDICATOR CIRCLE */

.progress-indicator {

  position: absolute;

  top: 50%;

  left: 0;

  transform: translate(-50%, -50%); /* CENTER on the position */

  width: 16px;

  height: 16px;

  background: white;

  border: 2px solid #1f2937;

  border-radius: 50%;

  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);

  transition: left 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Match fill timing */

  z-index: 2;

}

.progress-indicator.high-sus {

  color: #dc2626;

}

.progress-indicator.medium-sus {

  color: #FFF000;

}

.progress-indicator.low-sus {

  color: #2ecc71;

}

/* LABELS */

.progress-endpoints {

  display: flex;

  justify-content: space-between;

  font-size: 12px;

  color: #9ca3af;

  font-weight: 600;

  margin-bottom: 8px;

}



.progress-labels {

  display: flex;

  justify-content: space-between;

  font-size: 13px;

  font-weight: 700;

  color: #6b7280;

  text-align: center;

}

.score-label {

  font-size: 22px !important;

  font-weight: 900 !important;

  color: #dc2626;

  letter-spacing: 1px;

  margin: 0;

  white-space: nowrap;

  line-height: 1;

}



.score-label.sus-af {

  color: #dc2626;

}



.score-label.kinda-sus {

  color: #f59e0b;

}



.score-label.sus-free {

  color: #2ecc71;

}



#quickfixScoreLabel {

  font-size: 14px !important;

  font-weight: 600 !important;

}



/* Dynamic quote section colors */

.quote-section {

  padding: 15px;

  margin: 15px 0;

  border-radius: 10px;

  text-align: center;

  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);

}

.quote-section.high-risk {

  background: #dc2626;

  color: #fff;

}

.quote-section.medium-risk {

  background: #f59e0b;

  color: #fff;

}

.quote-section.low-risk {

  background: linear-gradient(to bottom, #00a8e8, #0b0646);

  color: #fff;

}

.quote-text { 

  color: inherit; 

  font-style: italic; 

  font-size: 14px; 

  line-height: 1.4; 

  font-weight: 600;

  margin: 0;

}

.essay-content { line-height: 1.6; font-size: 16px; color: #374151; margin: 15px 0; }



.flag-critical {

  background: #fee2e2;

  border: 2px solid #dc2626;

  padding: 2px 6px;

  border-radius: 4px;

  cursor: pointer;

  font-weight: 600;

  color: #991b1b;

  position: relative;

  display: inline-block;

}

.flag-medium {

  background: #fef3c7;

  border: 2px solid #f59e0b;

  padding: 2px 6px;

  border-radius: 4px;

  cursor: pointer;

  font-weight: 600;

  color: #92400e;

  position: relative;

  display: inline-block;

}

.flag-fixed {

  background: #d1fae5;

  border: 2px solid #2ecc71;

  padding: 2px 6px;

  border-radius: 4px;

  font-weight: 600;

  color: #065f46;

}



.red-flag {

  display: inline-block;

  font-size: 0.8em;

  margin-left: 3px;

  animation: flagWave 2s ease-in-out infinite;

  vertical-align: top;

}

.red-flag-large {

  display: inline-block;

  font-size: 1em;

  margin-right: 8px;

  animation: flagWave 2s ease-in-out infinite;

}

@keyframes flagWave {

  0%, 100% { transform: rotate(-5deg); }

  50% { transform: rotate(5deg); }

}



/* Flags blowing in the wind - for Pro Fun Fact graphic */

@keyframes flagsBlowInWind {

  0%, 100% { transform: rotate(-8deg) skewX(-4deg) scaleY(1); }

  20% { transform: rotate(-2deg) skewX(6deg) scaleY(1.03); }

  40% { transform: rotate(4deg) skewX(-5deg) scaleY(0.97); }

  60% { transform: rotate(8deg) skewX(5deg) scaleY(1.04); }

  80% { transform: rotate(2deg) skewX(-6deg) scaleY(0.98); }

}

.flags-blow-wind {

  display: inline-flex;

  gap: 4px;

  align-items: center;

  justify-content: center;

}

.flags-blow-wind span {

  display: inline-block;

  animation: flagsBlowInWind 2.8s ease-in-out infinite;

  transform-origin: bottom center;

}

.flags-blow-wind span:nth-child(1) { animation-delay: 0s; }

.flags-blow-wind span:nth-child(2) { animation-delay: 0.2s; }

.flags-blow-wind span:nth-child(3) { animation-delay: 0.4s; }



.fix-output-card {

  background: #d1fae5;

  border: 2px solid #00a8e8;

  border-radius: 16px;

  padding: 20px;

  margin: 15px 0;

  text-align: center;

}

.fix-output-card h3 {

  color: #065f46;

  margin-bottom: 12px;

  font-size: 18px;

  font-weight: 700;

}

.fixed-text-area {

  width: 100%;

  min-height: 100px;

  padding: 12px;

  border: 2px solid #00a8e8;

  border-radius: 8px;

  background: #fff;

  font-size: 16px;

  line-height: 1.6;

  resize: none;

  margin-bottom: 12px;

}



.upsell-card {

  background: linear-gradient(135deg, #ea580c, #f97316);

  color: #fff;

  text-align: center;

  padding: 20px;

}

.upsell-card h4 {

  color: #fff;

  font-weight: 700;

  font-size: 18px;

  margin-bottom: 12px;

}



.analysis-card h3 {

  font-size: 24px; /* INCREASED FONT SIZE */

  font-weight: 700;

  color: #1f2937;

  margin-bottom: 16px;

  text-align: center;

}

.btn {

  padding: 12px 20px;

  border-radius: 8px;

  font-weight: 600;

  font-size: 14px;

  cursor: pointer;

  transition: all 0.2s;

  border: none;

  flex: 1;

  min-width: 140px;

  position: relative;

}

.btn-outline {

  background: white;

  color: #374151;

  border: 2px solid #e5e7eb;

  margin-top: 12px;

  width: 100%;

}

.btn-outline:hover { background: #f9fafb; border-color: #d1d5db; }



.btn-secondary { background: #6b7280; color: white; }

.btn-action { 

  background: #ffffff; 

  color: #2ecc71; 

  border: 2px solid #2ecc71;

  width: 100%;

  padding: 14px 20px;

  font-size: 16px;

  font-weight: 700;

  margin-top: 15px;

}

.btn-action:hover {

  background: #2ecc71;

  color: white;

  transform: translateY(-2px);

}



/* FIXED TOOLTIP STYLES */

.tooltip {

  position: fixed;

  background: #1f2937;

  color: white;

  padding: 12px 16px;

  border-radius: 8px;

  font-size: 13px;

  font-weight: 600;

  max-width: 260px;

  z-index: 10000;

  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);

  pointer-events: none;

  display: none;

  line-height: 1.5;

  text-align: center;

  border: 1px solid #374151;

}



.tooltip.show {

  display: block;

  animation: fadeIn 0.2s ease-in-out;

}



@keyframes fadeIn {

  from { opacity: 0; transform: translateY(5px); }

  to { opacity: 1; transform: translateY(0); }

}



@keyframes slideUp {

  from { opacity: 0; transform: translateY(20px); }

  to { opacity: 1; transform: translateY(0); }

}



@keyframes fadeOut {

  from { opacity: 1; }

  to { opacity: 0; }

}



@keyframes slideDown {

  from { opacity: 1; transform: translateY(0); }

  to { opacity: 0; transform: translateY(20px); }

}



@keyframes slideDown {

  from {

    opacity: 0;

    max-height: 0;

    overflow: hidden;

  }

  to {

    opacity: 1;

    max-height: 500px;

    overflow: visible;

  }

}



@keyframes spin {

  from { transform: rotate(0deg); }

  to { transform: rotate(360deg); }

}



@keyframes modalSlideUp {

  from { 

    opacity: 0; 

    transform: translate(-50%, calc(-50% + 20px)); 

  }

  to { 

    opacity: 1; 

    transform: translate(-50%, -50%); 

  }

}



@keyframes slideUp {

  from {

    opacity: 1;

    max-height: 500px;

  }

  to {

    opacity: 0;

    max-height: 0;

    overflow: hidden;

  }

}



.success-message {

  position: fixed;

  top: 50%;

  left: 50%;

  transform: translate(-50%, -50%);

  background: linear-gradient(to bottom, #00a8e8, #0b0646);

  color: #fff;

  padding: 15px 25px;

  border-radius: 15px;

  font-weight: 700;

  z-index: 1002;

  box-shadow: 0 4px 20px rgba(16,185,129,.4);

}



/* --- Free Result Overlay Styles --- */

.free-result-container {

  width: 100%;

  max-width: none;

  padding: 20px;

  position: relative;

  background: #fff;

  border-radius: 10px;

  margin-top: 15px;

  overflow: visible;

}



/* Free Results Two-Column Layout */

.free-results-layout {

  display: grid;

  grid-template-columns: 1fr 1fr;

  gap: 24px;

  width: 100%;

  max-width: none;

}



.free-results-left {

  width: 100% !important;

  min-width: 0;

}



.free-results-right {

  width: 100% !important;

  min-width: 0;

}



/* Mobile: stack vertically - already using flex column, so this is handled */



/* Free Results Main Structure (NEW) */

.results-card {

  background: white;

  border-radius: 12px;

  overflow: hidden;

  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

  margin-bottom: 24px;

}



.results-header {

  background: #fff;

  padding: 16px 24px;

  border-bottom: 1px solid #e5e7eb;

  display: flex;

  align-items: center;

  gap: 8px;

  font-size: 16px;

  font-weight: 600;

  color: #dc2626;

}



.results-warning-bar {

  background: #dc2626;

  color: white;

  padding: 12px 24px;

  font-size: 14px;

  font-weight: 600;

  text-align: center;

}



.free-results-main {

  display: flex !important;

  flex-direction: column !important;

  gap: 24px !important;

  padding: 24px !important;

  width: 100% !important;

  height: auto !important;

  overflow: visible !important;

}



/* Make Free Results use single column like QuickFix/Pro */

.free-results-columns {

  display: flex !important;

  flex-direction: column !important;

  gap: 24px !important;

  width: 100% !important;

  max-width: 900px !important; /* Changed from 800px to 900px (WIDER!) */

  margin: 0 auto !important;

  height: auto !important;

  overflow: visible !important;

  align-items: flex-start;

}



/* AI Flag Pills */

.free-flags-preview {

  display: flex;

  flex-wrap: wrap;

  gap: 8px;

  margin: 12px 0;

}



.ai-flag-pill,

.trigger-chip {

  background: #fee2e2 !important;

  border: 1.5px solid #dc2626 !important;

  color: #991b1b !important;

  padding: 2px 5px !important;

  border-radius: 999px !important;

  font-size: 9px !important;

  font-weight: 600 !important;

  display: inline-block !important;

  line-height: 1.2 !important;

}



.free-flags-heading {

  color: #1e3a8a;

  font-size: 18px;

  font-weight: 700;

  margin: 0 0 8px 0;

}



.free-flags-subtext {

  color: #6b7280;

  font-size: 14px;

  margin: 0 0 12px 0;

  line-height: 1.5;

}



.upgrade-overlay {

  position: absolute;

  top: 0;

  left: 0;

  width: 100%;

  height: 100%;

  background-color: rgba(255, 255, 255, 0.5); /* REDUCED OPACITY TO 0.5 */

  color: #1f2937;

  display: flex;

  flex-direction: column;

  justify-content: center;

  align-items: center;

  font-size: 16px;

  font-weight: bold;

  padding: 20px;

  border-radius: 10px;

  text-align: center;

  border: 2px dashed #ea580c;

  z-index: 10;

  animation: shimmer 3s infinite;

}



@keyframes shimmer {

  0%, 100% { box-shadow: 0 0 0px rgba(234, 88, 12, 0.3); }

  50% { box-shadow: 0 0 15px rgba(234, 88, 12, 0.6); }

}



/* Spacing adjustments for pages with trigger words (score >= 30) */

#freeTriggerHeading {

  margin-bottom: 0px !important;

}



/* Clean No Sus page (score < 30) gets extra padding below heading */

#youreGoodCard[style*="display: block"] ~ * #freeTriggerHeading,

body:has(#youreGoodCard[style*="display: block"]) #freeTriggerHeading {

  margin-bottom: 6px !important;

}





/* Hide trigger heading for Hella Sus (70+) and Kinda Sus (30-69%) */

body:has(#hellaSusCard[style*="display: block"]) #freeTriggerHeading,

body.hella-sus-page #freeTriggerHeading,

#hellaSusCard[style*="display: block"] ~ * #freeTriggerHeading,

body:has(#kindaSusCard[style*="display: block"]) #freeTriggerHeading,

body.kinda-sus-page #freeTriggerHeading,

#kindaSusCard[style*="display: block"] ~ * #freeTriggerHeading {

  display: none !important;

  visibility: hidden !important;

  opacity: 0 !important;

  height: 0 !important;

  margin: 0 !important;

  padding: 0 !important;

  overflow: hidden !important;

}



/* Free Low Sus: thin green border on Scan Another Essay button */

body.free-low-sus-mode #scanAnotherEssayBtn {

  border: 1px solid #2ecc71 !important;

}



/* Hide trigger heading and card for Clean No Sus (0-29%) */

body:has(#youreGoodCard[style*="display: block"]) #freeTriggerHeading,

body:has(#youreGoodCard[style*="display: block"]) #freeTriggerWordsCard,

#youreGoodCard[style*="display: block"] ~ * #freeTriggerHeading,

#youreGoodCard[style*="display: block"] ~ * #freeTriggerWordsCard {

  display: none !important;

  visibility: hidden !important;

  opacity: 0 !important;

  height: 0 !important;

  margin: 0 !important;

  padding: 0 !important;

  overflow: hidden !important;

}



/* Hide red CTA box for Pro users in Step 3 - ALWAYS HIDDEN FOR PRO */

body:has(#quickfixStep6[style*="display: block"]) #quickfixStep3HellaSusCTA,

#quickfixStep3.active #quickfixStep3HellaSusCTA[data-pro="true"],

#quickfixStep3HellaSusCTA.pro-hidden,

#quickfixStep3HellaSusCTA[data-pro="true"] {

  display: none !important;

  visibility: hidden !important;

  opacity: 0 !important;

  height: 0 !important;

  margin: 0 !important;

  padding: 0 !important;

  overflow: hidden !important;

  position: absolute !important;

  left: -9999px !important;

}



/* Hide orange QuickFix upsell button ONLY when Pro dashboard (step 6) is visible. Do NOT hide when Step 3 is active for QuickFix users. */

body:has(#quickfixStep6[style*="display: block"]) #step3QuickFixUpsellButton {

  display: none !important;

  visibility: hidden !important;

  opacity: 0 !important;

  height: 0 !important;

  margin: 0 !important;

  padding: 0 !important;

  overflow: hidden !important;

  position: absolute !important;

  left: -9999px !important;

}



/* Hide the entire trigger words card section for Kinda Sus and Hella Sus to close the gap */

body:has(#kindaSusCard[style*="display: block"]) #freeTriggerWordsCard,

body.kinda-sus-page #freeTriggerWordsCard,

#kindaSusCard[style*="display: block"] ~ * #freeTriggerWordsCard,

body:has(#hellaSusCard[style*="display: block"]) #freeTriggerWordsCard,

body.hella-sus-page #freeTriggerWordsCard,

#hellaSusCard[style*="display: block"] ~ * #freeTriggerWordsCard {

  display: none !important;

  visibility: hidden !important;

  opacity: 0 !important;

  height: 0 !important;

  margin: 0 !important;

  padding: 0 !important;

  overflow: hidden !important;

}



/* Hella Sus page (70+) gets extra padding above hover hint */

body:has(#hellaSusCard[style*="display: block"]) #freeTriggerChipsHint,

body.hella-sus-page #freeTriggerChipsHint {

  margin-top: 42px !important;

}



/* Hella Sus (70+) gets extra padding below */

body:has(#hellaSusCard[style*="display: block"]) #freeExtraFlagsSummary,

body.hella-sus-page #freeExtraFlagsSummary {

  margin-top: -22px !important;

  margin-bottom: 26px !important;

}



/* Kinda Sus (30-69) - standard padding */

#freeExtraFlagsSummary {

  margin-top: -22px !important;

  margin-bottom: 20px !important;

}



.upgrade-overlay button {

  margin-top: 12px;

  padding: 12px 20px;

  border-radius: 8px;

  font-size: 14px;

  cursor: pointer;

  font-weight: 600;

  border: none;

  min-width: 140px;

  position: relative;

}



.upgrade-overlay .quickfix-btn {

  background-color: #ea580c;

  color: #fff;

  margin-right: 10px;

}



.upgrade-overlay .pro-btn {

  background: linear-gradient(to bottom, #00a8e8, #0b0646) !important;



  color: #fff;

}



.overlay-button-group {

  display: flex;

  gap: 10px;

  margin-top: 15px;

  flex-wrap: wrap;

  justify-content: center;

}



/* ================== FORCE WIDER LAYOUT FOR FREE RESULTS ONLY ================== */

/* Make Free Results wrapper match QuickFix/Pro width */

#resultsContainer .results-wrapper {

  max-width: 900px !important; /* Changed from 800px to 900px (WIDER!) */

  width: 100% !important;

  margin-left: auto !important;

  margin-right: auto !important;

}



/* Remove the media query or adjust it */

@media (min-width: 1200px) {

  #resultsContainer .results-wrapper {

    max-width: 900px !important; /* Keep it at 900px even on large screens */

  }

}



.upsell-message {

  text-align: center;

  font-style: italic;

  color: #6b7280;

  margin: 15px 0;

  font-size: 14px;

  line-height: 1.5;

  padding: 0 10px;

}



.hidden-content-note {

  text-align: center;

  color: #6b7280;

  font-size: 14px;

  margin-top: 10px;

  font-style: italic;

}



.content-blocked {

  position: relative;

}



.content-blocked::after {

  content: "";

  position: absolute;

  top: 0;

  left: 0;

  width: 100%;

  height: 100%;

  background: linear-gradient(to bottom, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.7) 100%);

  pointer-events: none;

}



.close-results-button {

  position: absolute;

  top: 5px;

  right: 20px;

  background: #6b7280;

  color: white;

  border: none;

  font-size: 12px;

  padding: 6px 12px;

  border-radius: 6px;

  cursor: pointer;

  font-weight: 600;

  transition: all 0.2s;

  z-index: 1001;

}



.close-results-button:hover {

  background: #4b5563;

  transform: translateY(-1px);

}



.hidden-text-preview {

  position: absolute;

  top: 0;

  left: 0;

  width: 100%;

  height: 100%;

  padding: 20px;

  color: rgba(0, 0, 0, 0.15);

  font-size: 14px;

  line-height: 1.4;

  pointer-events: none;

  z-index: 1;

  overflow: hidden;

}



.stripe-badge {

  text-align: center;

  margin-top: 15px;

  padding: 10px;

  font-size: 12px;

  color: #6b7280;

}



.stripe-logo {

  display: inline-block;

  margin-left: 5px;

  font-weight: 700;

  color: #635bff;

}



/* QuickFix Flow Styles */

.quickfix-flow-container {

  display: none;

  width: 100%;

  max-width: 900px; /* Changed from 800px to 900px (WIDER!) */

  margin: 0 auto; /* Add this line */

  position: relative; /* Changed from fixed */

  overflow-x: hidden;

  transform: none;

  will-change: auto;

}





.quickfix-step {

  display: none !important;

  opacity: 0;

  transform: none;

  transition: opacity 0.3s ease-out;

  visibility: hidden;

}



.quickfix-step.active {

  display: block !important;

  opacity: 1 !important;

  visibility: visible !important;

  transform: none !important;

  animation: slideIn 0.5s ease-out !important;

  width: 100%;

  margin: 0 auto;

  left: 0;

}



/* Extra specificity for Step 6 to ensure it shows */

#quickfixStep6.active {

  display: block !important;

  opacity: 1 !important;

  visibility: visible !important;

}



/* Ensure steps 2, 3, 4 are visible when active (for Pro mode) */

#quickfixStep2.active,

#quickfixStep3.active,

#quickfixStep4.active {

  display: block !important;

  opacity: 1 !important;

  visibility: visible !important;

  padding: 60px 0 40px 0 !important; /* Remove horizontal padding to match Free results width */

  background: #ffffff !important;

  min-height: 100vh;

}



/* QuickFix Step 2: Match regular scan results (Free) width - same as results-wrapper */

/* results-wrapper = 900px max-width, 24px padding â†’ 852px content. Match that. */

#quickfixFlow:has(#quickfixStep2.active) .main-container {

  max-width: 900px !important;

  padding-left: 24px !important;

  padding-right: 24px !important;

}

#quickfixFlow:has(#quickfixStep2.active) .input-section {

  padding-left: 0 !important;

  padding-right: 0 !important;

}



.lil-sus-header {

  text-align: center;

  margin-bottom: 30px;

}



.lil-sus-header h2 {

  font-size: 32px;

  font-weight: 800;

  color: #ff6b00;

  margin-bottom: 10px;

}



.lil-sus-header p {

  color: #6b7280;

  font-size: 16px;

  max-width: 700px;

  margin: 0 auto;

  line-height: 1.5;

  font-style: italic;

}



.flag-list {

  margin: 25px 0;

}



.flag-item {

  background: #fef2f2;

  border: 2px solid #fee2e2;

  border-radius: 10px;

  padding: 15px;

  margin-bottom: 12px;

  text-align: left;

}



.flag-severity {

  display: inline-flex;

  align-items: center;

  background: #dc2626;

  color: white;

  padding: 4px 10px;

  border-radius: 20px;

  font-size: 12px;

  font-weight: 700;

  margin-bottom: 8px;

}



.flag-severity.medium {

  background: #f59e0b;

}



.flag-explanation {

  color: #991b1b;

  font-size: 14px;

  font-weight: 600;

}



.quickfix-comparison {

  display: flex;

  flex-direction: column;

  gap: 20px;

  margin: 30px 0;

}



.comparison-box {

  flex: 1;

  border-radius: 12px;

  padding: 20px;

  box-shadow: 0 4px 12px rgba(0,0,0,0.1);

}



.original-box {

  background: #fef2f2;

  border: 2px solid #dc2626;

}



.fixed-box {

  background: #f0fdf4;

  border: 2px solid #2ecc71;

}



.box-header {

  display: flex;

  align-items: center;

  margin-bottom: 15px;

  font-weight: 700;

  font-size: 16px;

}

.original-header {

  color: #dc2626;

}



.fixed-header {

  color: #065f46;

}



.box-content {

  line-height: 1.6;

  font-size: 15px;

  min-height: 150px;

  max-height: 350px;

  overflow-y: auto;

  overflow-x: hidden;

  padding-right: 10px;

}



/* STAGE 2: Ensure textarea displays correctly in fixed box */

#comparisonFixed textarea {

  display: block !important;

  width: 100% !important;

  min-height: 200px !important;

  padding: 16px !important;

  border: 2px solid #e5e7eb !important;

  border-radius: 8px !important;

  font-size: 16px !important;

  line-height: 1.8 !important;

  font-family: inherit !important;

  resize: vertical !important;

  color: #333 !important;

  background: white !important;

  box-sizing: border-box !important;

}



/* NEW: Numbered flag styles */

.flag-highlight-red {

  background: #FFF000;

  border: none;

  padding: 3px 5px;

  border-radius: 4px;

  font-weight: 600;

  color: #0b0646;

  position: relative;

  display: inline-block;

  margin: 2px;

  cursor: help;

  font-size: 0.75em;

  line-height: 1.5;

}



.flag-highlight-red .flag-number {

  background: #FFFACD !important;

  color: #dc2626 !important;

}



/* Removed flag-highlight-orange - all flags now use flag-highlight-red */



.flag-number {

  background: #FFFACD;

  color: #dc2626;

  border-radius: 50%;

  width: 18px;

  height: 18px;

  display: inline-flex;

  align-items: center;

  justify-content: center;

  font-size: 11px;

  font-weight: 700;

  margin-left: 2px;

  vertical-align: super;

  cursor: help;

}



.flag-number:hover {

  transform: scale(1.2);

}



.flag-highlight-red .flag-number {

  background: #FFFACD;

  color: #dc2626 !important;

}



.flag-highlight-green {

  background: #d1fae5;

  border: 2px solid #2ecc71;

  border-radius: 4px;

  padding: 2px 6px;

  display: inline-block;

  margin: 0 1px;

  cursor: help;

}



/* FIX 3: Green numbers for fixed version */

.fix-highlight {

  background: #d1fae5;

  border: 2px solid #2ecc71;

  padding: 4px 6px;

  border-radius: 4px;

  font-weight: 600;

  color: #0b0646; /* Changed to navy */

  position: relative;

  display: inline-block;

  margin: 0 1px;

  line-height: 1.5;

}



.fix-highlight .flag-number {

  background: #2ecc71;

}



/* Clean No Sus specific styling - light green for optimizations */

.clean-no-sus-mode .flag-highlight-red,

.clean-no-sus-mode .flag-highlight-orange {

  background: #d1fae5 !important;

  border-color: #86efac !important;

  color: #065f46 !important;

}



.clean-no-sus-mode .flag-highlight-red .flag-number,

.clean-no-sus-mode .flag-highlight-orange .flag-number,

.clean-no-sus-mode .flag-number {

  background: #86efac !important;

  color: white !important;

}



.clean-no-sus-mode #quickfixCountHeading {

  color: #1e3a8a !important; /* Dark blue for Clean No Sus Pro */

}



.clean-no-sus-mode #quickfixCountHeading span {

  color: #10b981 !important; /* Green for the number */

}



.quickfix-cta-section {

  text-align: center;

  margin: 30px 0;

}



.lil-sus-footer {

  background: #f8f9fa;

  border-radius: 12px;

  padding: 20px;

  text-align: center;

  margin-top: 25px;

  border: 2px dashed #e5e7eb;

}



.lil-sus-footer p {

  color: #6b7280;

  font-size: 14px;

  font-style: italic;

  margin: 0;

  line-height: 1.5;

}



/* NEW: Fix selection styles */

.fix-selection {

  margin: 20px 0 0 0;

}



.fix-option {

  display: flex;

  align-items: flex-start;

  gap: 12px;

  margin-bottom: 12px;

  padding: 16px;

  background: white;

  border-radius: 12px;

  border: 1px solid #e5e7eb;

  box-shadow: 0 1px 3px rgba(0,0,0,0.1);

  transition: all 0.2s;

}



.fix-option.selected {

  background: #f0fdf4;

  border-color: #10b981;

  box-shadow: 0 2px 6px rgba(46, 204, 113, 0.15);

}



/* Make QuickFix Mode checkbox use green accent instead of default blue */

#selectAllFixes {

  accent-color: #10b981;

}



/* Pro Mode checkbox: WHITE when unchecked, GREEN with WHITE checkmark when clicked */

#quickfixGuaranteeBanner #selectAllFixes {

  width: 20px;

  height: 20px;

  cursor: pointer;

  appearance: none;

  -webkit-appearance: none;

  -moz-appearance: none;

  border: 2px solid rgba(255, 255, 255, 0.9);

  border-radius: 4px;

  background-color: white;

  position: relative;

  transition: background-color 0.2s ease, border-color 0.2s ease;

}



#quickfixGuaranteeBanner #selectAllFixes:checked {

  background-color: #10b981;

  border-color: #10b981;

}



#quickfixGuaranteeBanner #selectAllFixes:checked::after {

  content: 'âœ“';

  position: absolute;

  top: 50%;

  left: 50%;

  transform: translate(-50%, -50%);

  color: white;

  font-size: 16px;

  font-weight: bold;

  line-height: 1;

}



.fix-checkbox {

  margin-top: 2px;

}

    /* ===== UNIFIED TOOLTIP SYSTEM ===== */

    /* JavaScript-powered tooltip */

    .tooltip {

      position: fixed;

      background: white;

      color: #1e3a8a;

      padding: 12px 16px;

      border-radius: 8px;

      font-size: 13px;

      font-weight: 600;

      max-width: 280px;

      z-index: 10000;

      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);

      pointer-events: none;

      display: none;

      line-height: 1.5;

      text-align: center;

      word-wrap: break-word;

    }



    .tooltip.show {

      display: block;

      animation: tooltipFadeIn 0.3s ease-in-out;

    }



    @keyframes tooltipFadeIn {

      from {

        opacity: 0;

        transform: translateY(5px);

      }

      to {

        opacity: 1;

        transform: translateY(0);

      }

    }



    /* Color-coded borders on left and right */

    .tooltip.blue-border {

      border-left: 4px solid #2ecc71;

      border-right: 4px solid #2ecc71;

    }



    .tooltip.orange-border {

      border-left: 4px solid #ea580c;

      border-right: 4px solid #ea580c;

    }



    .tooltip.green-border {

      border-left: 4px solid #00a8e8;

      border-right: 4px solid #00a8e8;

    }



    @keyframes slideRight {

      0%, 100% {

        transform: translateX(0);

      }

      50% {

        transform: translateX(8px);

      }

    }



    /* ===== UNIFIED BUTTON SYSTEM ===== */

    /* Base button styles */

    button, .btn {

      border: none;

      border-radius: 12px;

      font-size: 0.95em !important;

      font-weight: 700;

      cursor: pointer;

      transition: all 0.3s;

      position: relative;

      padding: 12px 16px !important;

      display: inline-block;

      text-align: center;

      text-decoration: none;

      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

      line-height: 1.2 !important;

      height: auto !important;

    }



    /* Primary Button - Blue */

    .btn-primary, .scan-button {

      background: #2ecc71;

      color: white;

      box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);

    }



    .btn-primary:hover, .scan-button:hover {

      background: #27ae60;

      transform: translateY(-2px);

      box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);

    }



    .btn-primary:active, .scan-button:active {

      transform: translateY(0);

    }



    /* Secondary Button - Orange */

    .btn-secondary, .emergency-button {

      background: #ff6b00;

      color: white;

      box-shadow: 0 4px 12px rgba(255, 107, 0, 0.3);

    }



    .btn-secondary:hover, .emergency-button:hover {

      background: #e55a00;

      transform: translateY(-2px);

      box-shadow: 0 6px 20px rgba(255, 107, 0, 0.4);

    }



    .btn-secondary:active, .emergency-button:active {

      transform: translateY(0);

    }



    /* Success Button - Green */

    .btn-success, .pro-button {

      background: linear-gradient(to bottom, #00a8e8, #0b0646);

      color: white;

      box-shadow: 0 4px 12px rgba(0, 168, 232, 0.3);

    }



    .btn-success:hover, .pro-button:hover {

      background: linear-gradient(to bottom, #0087c4, #06082e);

      transform: translateY(-2px);

      box-shadow: 0 6px 20px rgba(0, 168, 232, 0.4);

    }



    .btn-success:active, .pro-button:active {

      transform: translateY(0);

    }



    /* Disabled state */

    button:disabled, .btn:disabled {

      background: #9ca3af;

      cursor: not-allowed;

      box-shadow: none;

      transform: none !important;

      opacity: 0.7;

    }



    /* Outline Button */

    .btn-outline {

      background: white;

      color: #374151;

      border: 2px solid #e5e7eb;

      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);

    }



    .btn-outline:hover {

      background: #f9fafb;

      border-color: #d1d5db;

      transform: translateY(-2px);

      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);

    }



    /* Size variants */

    .btn-sm {

      padding: 10px 16px;

      font-size: 0.9em;

    }



    .btn-lg {

      padding: 18px 32px;

      font-size: 1.1em;

      min-width: 200px;

    }



    /* Full width */

    .btn-block {

      display: block;

      width: 100%;

    }



    /* Button groups */

    .button-group {

      display: flex;

      gap: 10px;

      flex-wrap: wrap;

      margin: 20px 0;

    }



    .button-group button, .button-group .btn {

      flex: 1;

      min-width: 160px;

    }



    @media (max-width: 768px) {

      .button-group {

        flex-direction: column;

      }



      .button-group button, .button-group .btn {

        width: 100%;

      }

    }



    .fix-option input[type="checkbox"],

    .custom-checkbox {

      width: 20px !important;

      height: 20px !important;

      margin-right: 12px !important;

      cursor: pointer !important;

      border-radius: 4px !important;

      appearance: none !important;

      -webkit-appearance: none !important;

      -moz-appearance: none !important;

      border: 2px solid #d1d5db !important;

      background: white !important;

      position: relative !important;

      transition: all 0.2s ease !important;

    }



.fix-option input[type="checkbox"]:hover,

.custom-checkbox:hover {

  border-color: #9ca3af;

  transform: scale(1.05);

}



.fix-option input[type="checkbox"]:checked,

.custom-checkbox:checked {

  background: #10b981 !important;

  border-color: #10b981 !important;

}



.fix-option input[type="checkbox"]:checked::after,

.custom-checkbox:checked::after {

  content: 'âœ“';

  position: absolute;

  top: 50%;

  left: 50%;

  transform: translate(-50%, -50%);

  color: white !important;

  font-size: 14px;

  font-weight: 700;

  line-height: 1;

}



.fix-content {

  flex: 1;

}



.fix-original {

  color: #dc2626;

  font-weight: 600;

  margin-bottom: 4px;

}



.fix-suggestion {

  color: #065f46;

  font-weight: 600;

}



.fix-explanation {

  color: #6b7280;

  font-size: 14px;

  margin-top: 4px;

  line-height: 1.4;

}



.fix-alternatives {

  color: #2ecc71;

  font-size: 13px;

  margin-top: 4px;

  font-style: italic;

}



.alt-word-btn {

  font-size: 13px !important;

  padding: 6px 12px !important;

}



.disclaimer {

  background: #fef3c7;

  border: 2px solid #f59e0b;

  border-radius: 8px;

  padding: 15px;

  margin: 20px 0;

  text-align: center;

  font-size: 14px;

  color: #92400e;

}



.upsell-section {

  background: #f0f9ff;

  border: 2px dashed #0ea5e9;

  border-radius: 8px;

  padding: 15px;

  margin: 20px 0;

  text-align: center;

}



.upsell-title {

  color: #0369a1;

  font-weight: 600;

  margin-bottom: 8px;

}



.upsell-button {

  background: linear-gradient(to bottom, #00a8e8, #0b0646);

  color: white;

  border: none;

  padding: 10px 20px;

  border-radius: 8px;

  font-weight: 600;

  cursor: pointer;

  margin-top: 10px;

  transition: all 0.3s;

  width: 100%;

}



.upsell-button:hover {

  background: linear-gradient(to bottom, #0087c4, #06082e);

  transform: translateY(-2px);

}



.score-impact {

  display: flex;

  align-items: center;

  gap: 8px;

  margin-top: 8px;

  font-size: 13px;

  color: #6b7280;

}



.score-before, .score-after {

  font-weight: 700;

}



.score-before {

  color: #dc2626;

}



.score-after {

  color: #00a8e8;

}



.apply-selected-fixes {

  background: #00a8e8 !important;

  color: white !important;

  border: none !important;

  padding: 12px 20px !important;

  border-radius: 8px !important;

  font-weight: 600 !important;

  cursor: pointer !important;

  width: 200px !important;

  font-size: 14px !important;

  margin-top: 0 !important;

  transition: all 0.3s;

}



.apply-selected-fixes:hover {

  background: #0087c4 !important;

  transform: translateY(-2px);

}



.apply-all-fixes {

  background: #ff6b00 !important;

  color: white !important;

  border: none !important;

  padding: 12px 20px !important;

  border-radius: 8px !important;

  font-weight: 600 !important;

  cursor: pointer !important;

  width: 200px !important;

  font-size: 14px !important;

  margin-top: 0 !important;

  transition: all 0.3s;

}

.apply-all-fixes:hover {

  background: linear-gradient(to bottom, #0087c4, #06082e);

  transform: translateY(-2px);

}



/* NEW: FIXED CTA BUTTON STYLES */

.cta-button-group {

  display: flex;

  flex-direction: column; /* stack vertically */

  gap: 12px;

  margin-top: 16px;

}



/* Make all buttons in CTA group full width */

.cta-button-group button {

  width: 100%;

}



/* Make bottom CTA container full width to match sections above */

.quickfix-bottom-cta {

  width: 100% !important;

}



.cta-btn {

  padding: 8px 14px;

  font-size: 14px;

  font-weight: 500;

  border-radius: 6px;

  border: none;

  cursor: pointer;

  transition: background-color 0.2s ease;

  white-space: nowrap;

}



.blue-btn {

  background-color: #2e7bff;

  color: #ffffff;

}



.blue-btn:hover {

  background-color: #1a63db;

}



.dark-btn {

  background-color: #333333;

  color: #ffffff;

}



.dark-btn:hover {

  background-color: #222222;

}



.light-btn {

  background-color: #f1f1f1;

  color: #444444;

}



.light-btn:hover {

  background-color: #e2e2e2;

}



.cta-note {

  font-size: 12px;

  color: #666;

  text-align: center;

  margin-top: 10px;

}



/* FIX: Blue Free Rewrite Banner */

.free-rewrite-banner {

  background: linear-gradient(135deg, #2ecc71, #229954);

  color: white;

  padding: 15px;

  border-radius: 10px;

  text-align: center;

  margin: 15px 0;

  border: 2px solid #60a5fa;

  box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);

}



/* NEW: QuickFix Bottom CTA Section */

.quickfix-bottom-cta {

  background: white;

  border-radius: 16px;

  padding: 40px 30px;

  box-shadow: 0 10px 30px rgba(0,0,0,0.1);

  margin: 30px auto;

  max-width: 1200px;

  width: 100%;

}



.urgency-banner {

  border-radius: 8px;

  padding: 16px;

  margin-bottom: 24px;

  text-align: center;

}



.urgency-banner.high-risk {

  background: linear-gradient(135deg, #fee2e2, #fecaca);

  border-left: 4px solid #dc2626;

}



.urgency-banner.medium-risk {

  background: linear-gradient(135deg, #fef3c7, #fde68a);

  border-left: 4px solid #f59e0b;

}



.urgency-banner.low-risk {

  background: linear-gradient(135deg, #d1fae5, #a7f3d0);

  border-left: 4px solid #00a8e8;

}



.urgency-text {

  font-weight: 700;

  font-size: 16px;

  line-height: 1.4;

}



.urgency-banner.high-risk .urgency-text {

  color: #991b1b;

}



.urgency-banner.medium-risk .urgency-text {

  color: #92400e;

}



.urgency-banner.low-risk .urgency-text {

  color: #065f46;

}



.pitch-section {

  text-align: center;

  margin-bottom: 28px;

  border-bottom: 2px solid #f3f4f6;

  padding-bottom: 24px;

}



.pitch-title {

  font-size: 24px;

  font-weight: 800;

  color: #0b0646;

  margin-bottom: 16px;

  line-height: 1.3;

}



.pitch-copy {

  font-size: 15px;

  color: #6b7280;

  line-height: 1.6;

  margin-bottom: 12px;

}



.score-display {

  background: #f8f9fa;

  border-radius: 8px;

  padding: 14px;

  margin: 16px 0;

  font-size: 14px;

  font-weight: 600;

  color: #374151;

  text-align: center;

}



.score-display span {

  font-size: 18px;

  font-weight: 800;

}



.score-display.high-risk span {

  color: #dc2626;

}



.score-display.medium-risk span {

  color: #f59e0b;

}



.score-display.low-risk {

  border: 3px solid #2ecc71;

  position: relative;

}



.score-display.low-risk::before {

  content: '';

  position: absolute;

  top: -4px;

  left: -8px;

  width: 5px;

  height: 45px;

  background: #1a5f1a;

  z-index: 10;

}



.score-display.low-risk::after {

  content: '';

  position: absolute;

  top: -4px;

  left: -3px;

  width: 50px;

  height: 30px;

  background: #2ecc71;

  z-index: 9;

  clip-path: polygon(0 0, 100% 0, 85% 50%, 100% 100%, 0 100%);

  animation: waveFlag 1.2s ease-in-out infinite;

  transform-origin: left center;

}



@keyframes waveFlag {

  0%, 100% {

    transform: rotate(-8deg) scaleY(1);

  }

  25% {

    transform: rotate(-4deg) scaleY(1.05);

  }

  50% {

    transform: rotate(0deg) scaleY(1);

  }

  75% {

    transform: rotate(4deg) scaleY(1.05);

  }

}



.score-display.low-risk span {

  color: #00a8e8;

}



.what-happens {

  background: #f0fdf4;

  border-left: 4px solid #00a8e8;

  border-radius: 8px;

  padding: 20px;

  margin-bottom: 20px;

}



.what-happens-title {

  font-weight: 700;

  color: #065f46;

  margin-bottom: 12px;

  font-size: 15px;

}



.what-happens-list {

  list-style: none;

}



.what-happens-list li {

  margin: 8px 0;

  padding-left: 0;

  font-size: 14px;

  color: #047857;

  line-height: 1.5;

}



.what-happens-list li:before {

  content: 'â†’';

  display: inline-block;

  margin-right: 8px;

  color: #00a8e8;

  font-weight: bold;

}



.footer-disclaimer {

  text-align: center;

  font-size: 13px;

  color: #6b7280;

  line-height: 1.6;

  padding-top: 16px;

  border-top: 1px solid #e5e7eb;

}



.cta-btn.tertiary {

  background: transparent;

  color: #6b7280;

  border: 2px solid #d1d5db;

  font-weight: 600;

}



.cta-btn.tertiary:hover {

  background: #f9fafb;

  border-color: #9ca3af;

  color: #4b5563;

}



/* FIX: Orange Full Rewrite Button */

.orange-rewrite-btn {

  background: #2ecc71 !important;

  color: white !important;

  border: none !important;

  padding: 12px 20px !important;

  border-radius: 8px !important;

  font-weight: 600 !important;

  cursor: pointer !important;

  width: 200px !important;

  font-size: 14px !important;

  margin-top: 0 !important;

}



.orange-rewrite-btn:hover {

  background: #dc2626 !important;

  transform: translateY(-2px);

}



/* STEP 4 SPECIFIC STYLES */

.mobile-toggle {

  display: none;

}



@media (max-width: 768px) {

  .step4-comparison {

    display: none !important;

  }



  .mobile-toggle {

    display: flex;

  }



  .stats-grid {

    grid-template-columns: 1fr !important;

  }



  .step4-cta-btn {

    min-width: 100% !important;

  }

}



/* Optional: Make Font a Bit Smaller on Mobile */

@media (max-width: 480px) {

  .cta-btn {

    font-size: 13px;

    padding: 6px 10px;

  }

}

/* FIX 12: Mobile Optimization */

@media (max-width: 768px) {

  .button-group {

    flex-direction: column;

  }

  .scan-button, .emergency-button, .pro-button {

    min-width: auto;

    margin-bottom: 10px;

  }

  .overlay-button-group {

    flex-direction: column;

  }

  .overlay-button-group button {

    width: 100%;

    margin-right: 0;

  }

  .close-results-button {

    top: 5px;

    right: 15px;

    font-size: 11px;

    padding: 5px 10px;

  }

  .main-container {

    width: 95%;

    max-width: 95%; /* Add this */

    margin: 0 auto 20px;

    padding: 0 15px; /* Slightly reduce padding on mobile */

  }

  .input-section {

    padding: 20px 15px; /* Consistent padding */

  }



  /* Make sure results wrapper is full width on mobile */

  #resultsContainer .results-wrapper,

  .quickfix-flow-container,

  .free-results-layout {

    max-width: 95% !important;

    width: 95% !important;

    margin: 0 auto !important;

  }

  .quickfix-comparison {

    flex-direction: column;

  }

  .fix-option {

    flex-direction: column;

    gap: 8px;

  }

  .cta-button-group {

    flex-direction: column;

  }

  .cta-btn {

    width: 100%;

    margin-bottom: 10px;

  }

  .progress-labels {

    font-size: 12px;

    padding: 0 2px;

  }



  /* MOBILE: Progress bar container */

  .progress-container {

    margin: 16px 0 24px 0;

  }



  .progress-labels {

    font-size: 11px;

  }

}



/* NEW STEP 4 STYLES - ADDED FROM YOUR CODE */

.hero-header {

  text-align: center;

  margin-bottom: 40px;

  padding: 30px 0;

}



.hero-header h1 {

  font-size: 2.5em;

  font-weight: 800;

  color: #0b0646;

  margin-bottom: 15px;

  line-height: 1.2;

}



.hero-header p {

  font-size: 1.2em;

  color: #0b0646; /* Changed to navy for success messages */

  font-style: italic;

}



.rotating-message {

  font-size: 1.8em;

  font-weight: 800;

  color: #0b0646;

  margin-bottom: 15px;

  line-height: 1.2;

  text-align: center;

  min-height: 1.2em;

  transition: opacity 0.5s ease-in-out;

}



/* Rotating message container for QuickFix results */

.rotating-message-container {

  position: relative;

  min-height: 30px; /* Or whatever height you need */

  width: 100%;

  overflow: hidden;

  margin: 32px 0 20px 0; /* Increased top margin by 12px (1/2 inch) */

  padding: 10px;

  border-radius: 8px;

  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);

  background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); /* Light pink gradient matching toggle-header section */

  display: flex;

  align-items: center;

  justify-content: center;

}



/* Brighter red background for QuickFix Step 2 Hella Sus rotating phrases */

#quickfixHellaSusCard .rotating-message-container {

  background: linear-gradient(135deg, #fca5a5 0%, #ef4444 100%) !important; /* Bright vibrant red gradient */

  -webkit-backface-visibility: hidden;

  backface-visibility: hidden;

  transform: translateZ(0);

  will-change: auto;

}



/* Yellow/orange background for Kinda Sus container */

.rotating-message-container.kinda-sus-messages {

  background: #f59e0b; /* Yellow/orange background for Kinda Sus - always visible */

}



/* Green background for Clean No Sus container (Free Clean) */

#youreGoodCard .rotating-message-container {

  background: #10b981 !important; /* Chevron green - Free Clean only */

}



/* White rotating text in Free Clean green box only */

#youreGoodCard .rotating-message-container .rotating-message {

  color: #ffffff !important;

}



/* Major Red Flags Alert - crisp, no blur, clean styling */

.major-red-flags-alert {

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

  text-rendering: optimizeLegibility;

  backface-visibility: hidden;

  transform: translateZ(0);

  will-change: auto;

}



.major-red-flags-alert > div {

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

  text-rendering: optimizeLegibility;

  font-size: 16px;

  letter-spacing: 0;

  text-shadow: none !important;

  backface-visibility: hidden;

  transform: translateZ(0);

  will-change: auto;

  filter: none !important;

  -webkit-filter: none !important;

}



/* Old Step 3 rotating message CSS removed - now using alerts */

/* Step 3 Hella Sus alert styling - clean and crisp */

#quickfixStep3HellaSusRotatingPhrases.major-red-flags-alert {

  background: transparent !important;

}

#quickfixStep3HellaSusRotatingPhrases.major-red-flags-alert > div {

  background: #ef4444 !important;

  color: white !important;

  text-shadow: none !important;

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

}



/* Kinda Sus Alert - crisp, no blur, clean styling */

.kinda-sus-alert {

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

  text-rendering: optimizeLegibility;

  backface-visibility: hidden;

  transform: translateZ(0);

  will-change: auto;

}



.kinda-sus-alert > div {

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

  text-rendering: optimizeLegibility;

  font-size: 16px;

  letter-spacing: 0;

  text-shadow: none !important;

  backface-visibility: hidden;

  transform: translateZ(0);

  will-change: auto;

  filter: none !important;

  -webkit-filter: none !important;

}



/* Clean Alert - crisp, no blur, clean styling */

.clean-alert {

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

  text-rendering: optimizeLegibility;

  backface-visibility: hidden;

  transform: translateZ(0);

  will-change: auto;

}



.clean-alert > div {

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

  text-rendering: optimizeLegibility;

  font-size: 16px;

  letter-spacing: 0;

  text-shadow: none !important;

  backface-visibility: hidden;

  transform: translateZ(0);

  will-change: auto;

  filter: none !important;

  -webkit-filter: none !important;

}



/* Step 3 Kinda Sus and Clean alert styling */

#quickfixStep3KindaSusRotatingPhrases.kinda-sus-alert {

  background: transparent !important;

}

#quickfixStep3KindaSusRotatingPhrases.kinda-sus-alert > div {

  background: #f59e0b !important;

  color: white !important;

  text-shadow: none !important;

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

}



#quickfixStep3CleanNoSusRotatingPhrases.clean-alert {

  background: transparent !important;

}

#quickfixStep3CleanNoSusRotatingPhrases.clean-alert > div {

  background: #10b981 !important;

  color: white !important;

  text-shadow: none !important;

  -webkit-font-smoothing: antialiased;

  -moz-osx-font-smoothing: grayscale;

  font-smooth: always;

}

#quickfixStep3KindaSusRotatingPhrases {

  background: #f59e0b !important; /* Yellow/orange for Kinda Sus */

}

#quickfixStep3KindaSusRotatingPhrases .rotating-message {

  color: #ffffff !important;

  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3) !important;

}



.rotating-message-container {

  position: relative;

  min-height: 30px; /* Or whatever height you need */

}



.rotating-message-container .rotating-message {

  position: absolute;

  top: 0;

  left: 0;

  width: 100%;

  opacity: 0;

  transition: opacity 0.5s ease-in-out;

  padding: 0; /* Remove padding - container handles it */

  border-radius: 0; /* Remove border radius - container handles it */

  background: transparent !important; /* Transparent - container provides background */

  color: #dc2626; /* Dark red text to match section title color */

  box-shadow: none; /* Remove shadow - container handles it */

  margin-bottom: 0;

  min-height: auto;

  text-align: center;

  font-size: 18px;

  font-weight: 700;

  display: flex;

  align-items: center;

  justify-content: center;

}



.rotating-message-container .rotating-message.active {

  opacity: 1;

}



/* Old animation keyframes removed - now using JavaScript with .active class for rotation */



/* Background is set above - this section removed to avoid duplication */



/* Force visibility for interactive essay box */

.interactive-essay-box,

#freeEssayPreviewBox {

  display: block !important;

  visibility: visible !important;

  opacity: 1 !important;

  position: relative !important;

  z-index: 100 !important;

}



/* Make sure the blurred content is visible */

.interactive-essay-box > div:last-child,

#freeEssayPreviewBox > div:last-child {

  display: block !important;

  visibility: visible !important;

}



.rotating-message-container .rotating-message {

  background: transparent !important; /* Remove individual backgrounds - use container background */

}



/* Rotating text below score box: white + shadow for readability on colored backgrounds */

.rotating-message,

.rotating-text,

.score-message,

#rotatingMessage,

.quickfix-rotating-text,

.kinda-sus-message,

.rotating-message-container .rotating-message,

[class*='rotating'][class*='message'] {

  color: #FFF !important;

  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5) !important;

}



/* Kinda Sus rotating text (Free & QuickFix) */

#kindaSusCard .rotating-message-container .rotating-message,

#quickfixKindaSusCard .rotating-message-container .rotating-message {

  color: #FFF !important;

  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5) !important;

}



.rotating-results-message {

  margin: 20px 0;

  padding: 15px;

  background: linear-gradient(135deg, #0b0646 0%, #1a0f6e 100%);

  border-radius: 12px;

  color: white;

  text-align: center;

  font-size: 16px;

  font-weight: 500;

  min-height: 50px;

  box-shadow: 0 4px 12px rgba(0,0,0,0.1);

  position: relative;

}



.rotating-results-message span {

  display: none;

  padding: 10px;

}



.rotating-results-message span.active {

  display: block !important;

  animation: fadeIn 0.5s ease;

}



@keyframes fadeIn {

  from {

    opacity: 0;

    transform: translateY(-5px);

  }

  to {

    opacity: 1;

    transform: translateY(0);

  }

}



.footer-cta {

  font-size: 1.8em !important;

  font-weight: 800 !important;

  color: #2ecc71 !important;

  text-shadow: 2px 2px 4px rgba(46, 204, 113, 0.3) !important;

  margin: 20px 0 !important;

  line-height: 1.3 !important;

  text-align: center !important;

}



.stats-grid {

  display: grid;

  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));

  gap: 10px;

  margin: 15px 0;

}



.stat-card {

  padding: 10px;

  border-radius: 8px;

  text-align: center;

  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.12);

}



.stat-card.green {

  background: linear-gradient(135deg, #00a8e8, #0087c4);

  color: white;

}



.stat-card.blue {

  background: linear-gradient(135deg, #2ecc71, #229954);

  color: white;

}



.stat-card.orange {

  background: linear-gradient(135deg, #f97316, #ea580c);

  color: white;

}



.stat-card.red {

  background: linear-gradient(135deg, #ef4444, #dc2626);

  color: white;

}



.stat-number {

  font-size: 1.6em;

  font-weight: 800;

  display: block;

  margin-bottom: 3px;

}



.stat-label {

  font-size: 0.9em;

  opacity: 0.95;

}



.score-transformation {

  background: white;

  border-radius: 20px;

  padding: 30px;

  margin: 30px 0;

  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);

}



.score-comparison {

  display: flex;

  align-items: center;

  justify-content: center;

  gap: 20px;

  margin-bottom: 25px;

  flex-wrap: wrap;

}



.score-badge {

  padding: 12px 25px;

  border-radius: 25px;

  font-weight: 700;

  font-size: 1.1em;

}



.score-before {

  background: #fee2e2;

  color: #dc2626;

}



.score-after {

  background: #d1fae5;

  color: #00a8e8;

}



.score-arrow {

  font-size: 1.8em;

  color: #00a8e8;

}



.sus-meter {

  background: #f8f9fa;

  padding: 25px;

  border-radius: 15px;

}



.meter-labels {

  display: flex;

  justify-content: space-between;

  margin-bottom: 10px;

  font-size: 12px;

  font-weight: 700;

  color: #6b7280;

}



.meter-bar {

  height: 30px;

  background: #e5e7eb;

  border-radius: 15px;

  overflow: hidden;

  position: relative;

  margin-bottom: 15px;

}



.meter-fill {

  height: 100%;

  background: linear-gradient(90deg, #00a8e8, #4dd0e1);

  display: flex;

  align-items: center;

  justify-content: flex-end;

  padding-right: 15px;

  color: white;

  font-weight: 700;

  transition: width 1.5s ease;

}

.meter-message {

  text-align: center;

  color: #00a8e8;

  font-weight: 700;

  font-size: 1.1em;

}



.action-buttons {

  display: flex;

  gap: 12px;

  margin: 30px 0;

  flex-wrap: wrap;

}



.btn {

  flex: 1;

  min-width: 200px;

  padding: 16px;

  font-size: 16px;

  font-weight: 700;

  border: none;

  border-radius: 12px;

  cursor: pointer;

  transition: all 0.3s;

  display: flex;

  align-items: center;

  justify-content: center;

  gap: 8px;

}



.btn-success {

  background: linear-gradient(to bottom, #00a8e8, #0b0646);

  color: white;

}



.btn-success:hover {

  background: linear-gradient(to bottom, #0087c4, #06082e);

  transform: translateY(-2px);

}



.btn-primary {

  background: #2ecc71;

  color: white;

}



.btn-primary:hover {

  background: #27ae60;

  transform: translateY(-2px);

}



.btn-warning {

  background: #f46904;

  color: white;

}



.btn-warning:hover {

  background: #dc2626;

  transform: translateY(-2px);

}



.essay-viewer {

  background: white;

  border-radius: 20px;

  padding: 30px;

  margin: 30px 0;

  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);

}



.viewer-header {

  display: flex;

  justify-content: space-between;

  align-items: center;

  margin-bottom: 25px;

  flex-wrap: wrap;

  gap: 15px;

}



.viewer-title {

  font-size: 1.5em;

  font-weight: 700;

  color: #1f2937;

}



.toggle-switch {

  display: flex;

  justify-content: center;

  background: #f3f4f6;

  border-radius: 10px;

  padding: 4px;

  gap: 4px;

}



.toggle-btn {

  padding: 10px 20px;

  border: none;

  border-radius: 8px;

  background: transparent;

  color: #6b7280;

  font-weight: 600;

  cursor: pointer;

  transition: all 0.3s;

}



.toggle-btn.active {

  background: white;

  color: #1f2937;

  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);

}



.essay-display {

  position: relative;

  background: #f9fafb;

  border-radius: 12px;

  padding: 25px;

  max-height: 500px;

  overflow-y: auto;

  line-height: 1.8;

  font-size: 16px;

  color: #374151;

}



.essay-content {

  display: none;

  max-height: 400px;

  overflow-y: auto;

  padding: 15px;

  border-radius: 8px;

  background: white;

  border: 1px solid #e5e7eb;

}



.essay-content.active {

  display: block;

  animation: fadeIn 0.3s ease;

}



@keyframes fadeIn {

  from { opacity: 0; }

  to { opacity: 1; }

}



.flag-removed {

  background: #fee2e2;

  color: #dc2626;

  padding: 2px 6px;

  border-radius: 4px;

  text-decoration: line-through;

  font-weight: 600;

}



.flag-fixed {

  background: #d1fae5;

  color: #2ecc71;

  padding: 2px 6px;

  border-radius: 4px;

  font-weight: 600;

}



.diff-highlight {

  background: #fef3c7;

  padding: 2px 6px;

  border-radius: 4px;

  font-weight: 600;

}



.stats-banner {

  background: #f0f9ff;

  border: 2px solid #bae6fd;

  border-radius: 12px;

  padding: 20px;

  margin: 20px 0;

  display: flex;

  justify-content: space-around;

  align-items: center;

  flex-wrap: wrap;

  gap: 15px;

}



.stat-item {

  text-align: center;

}



.stat-value {

  font-size: 2em;

  font-weight: 800;

  color: #0369a1;

  display: block;

}



.stat-text {

  font-size: 0.9em;

  color: #6b7280;

}



.lil-sus-footer {

  background: white;

  padding: 50px 40px;

  border-radius: 20px;

  text-align: center;

  margin-top: 40px;

  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);

  border: 3px solid #f97316;

}



.footer-icon {

  font-size: 4em;

  margin-bottom: 20px;

}



.footer-title {

  font-size: 2.2em;

  margin-bottom: 20px;

  font-weight: 900;

  color: #00a8e8;

}



.footer-text {

  margin: 12px 0;

  color: #374151;

  line-height: 1.8;

  font-size: 1.1em;

  font-weight: 500;

}



.footer-cta {

  font-weight: 900;

  font-size: 1.6em;

  margin-top: 25px;

  color: #2ecc71;

  letter-spacing: 0.5px;

}



.modal {

  display: none;

  position: fixed;

  top: 0;

  left: 0;

  width: 100%;

  height: 100%;

  background: rgba(0, 0, 0, 0.8);

  z-index: 10000;

  align-items: center;

  justify-content: center;

  padding: 20px;

}



.modal.show {

  display: flex;

}



.modal-content {

  background: white;

  border-radius: 20px;

  max-width: 900px; /* Changed from 800px to 900px for consistency */

  width: 100%;

  max-height: 90vh;

  overflow-y: auto;

  position: relative;

}



.modal-header {

  background: linear-gradient(135deg, #2ecc71, #052e60);

  color: white;

  padding: 30px;

  text-align: center;

  border-radius: 20px 20px 0 0;

}



.modal-close {

  position: absolute;

  top: 10px;

  right: 10px;

  background: none;

  border: none;

  font-size: 32px;

  color: #999;

  cursor: pointer;

  padding: 10px 15px;

  line-height: 1;

  border-radius: 50%;

  transition: all 0.3s;

  z-index: 1;

}



.modal-body {

  padding: 30px;

}



.flag-item {

  display: flex;

  gap: 15px;

  margin-bottom: 25px;

  padding-bottom: 25px;

  border-bottom: 2px solid #f3f4f6;

}



.flag-number {

  flex-shrink: 0;

}



.flag-details {

  flex: 1;

}



.flag-change {

  margin-bottom: 12px;

}



.flag-original {

  background: #fef2f2;

  color: #dc2626;

  padding: 6px 10px;

  border-radius: 6px;

  font-weight: 600;

  display: inline-block;

}



.flag-arrow {

  margin: 0 8px;

  color: #6b7280;

}



.flag-new {

  background: #ecfdf5;

  color: #00a8e8;

  padding: 6px 10px;

  border-radius: 6px;

  font-weight: 600;

  display: inline-block;

}



.flag-explanation {

  background: #f8f9fa;

  padding: 12px;

  border-radius: 8px;

}



.modal-footer {

  padding: 20px;

  background: #f8f9fa;

  display: flex;

  gap: 12px;

  border-radius: 0 0 20px 20px;

}



.success-toast {

  position: fixed;

  top: 50%;

  left: 50%;

  transform: translate(-50%, -50%);

  background: white;

  color: #00a8e8;

  border: 3px solid #00a8e8;

  padding: 20px 30px;

  border-radius: 15px;

  font-weight: 700;

  z-index: 10001;

  box-shadow: 0 10px 30px rgba(0, 168, 232, 0.4);

  animation: slideIn 0.3s ease;

  display: none;

}



.download-toast {

  background: white;

  color: #2ecc71;

  border: 3px solid #2ecc71;

  box-shadow: 0 10px 30px rgba(46, 204, 113, 0.4);

}



.success-toast.show {

  display: block;

}



@keyframes slideIn {

  from {

    opacity: 0;

    transform: translate(-50%, -60%);

  }

  to {

    opacity: 1;

    transform: translate(-50%, -50%);

  }

}



@media (max-width: 768px) {

  .action-buttons {

    flex-direction: column;

  }



  .btn {

    min-width: auto;

    width: 100%;

  }



  .stats-grid {

    grid-template-columns: 1fr;

  }



  .score-comparison {

    flex-direction: column;

  }



  .viewer-header {

    flex-direction: column;

    align-items: flex-start;

  }



  .toggle-switch {

    width: 100%;

    justify-content: center;

  }



  .toggle-btn {

    flex: 1;

  }

}



/* Pro Feature Modal Classes */

.pro-feature {

  background: #f8f9fa;

  padding: 20px;

  border-radius: 14px;

  border: 2px solid #e5e7eb;

}



.pro-feature-icon {

  font-size: 36px;

  margin-bottom: 10px;

}



.pro-feature-title {

  color: #1e3a8a;

  margin: 0 0 8px;

  font-size: 16px;

  font-weight: 700;

}



.pro-feature-desc {

  color: #6b7280;

  font-size: 13px;

  line-height: 1.5;

  margin: 0;

}



.modal-title {

  color: #1e3a8a;

  margin: 0 0 10px;

  font-size: 28px;

  font-weight: 800;

}



.modal-subtitle {

  color: #6b7280;

  font-size: 16px;

  margin: 0;

}



.pro-upgrade-btn {

  padding: 16px 40px;

  font-size: 21px !important;

  font-weight: 700 !important;

  box-shadow: 0 4px 15px rgba(0, 168, 232, 0.3);

  margin-bottom: 15px;

}



.modal-dismiss {

  display: block;

  text-align: center;

  color: #9ca3af;

  font-size: 14px;

  text-decoration: underline;

  cursor: pointer;

  margin-top: 10px;

}



/* ====== LOCKBOX: Fix Z-INDEX & LAYERING ====== */

/* Push highlighted text to background */

#lockboxEssayPreview .flag-preview-clear,

#lockboxEssayPreview span[style*="background: #fee2e2"],

#lockboxEssayPreview span[style*="border: 1.5px solid"] {

    position: relative !important;

    z-index: 1 !important;

    pointer-events: none !important;

    opacity: 0.7 !important;

    margin: 2px !important;

    display: inline-block !important;

}



/* ====== LOCKBOX: Main container styles ====== */

#freeUnlockOverlay {

  position: relative !important;

  z-index: 9999 !important;

  margin: 30px 0 !important;

  padding: 20px !important;

  background: white !important;

  border-radius: 12px !important;

  box-shadow: 0 10px 30px rgba(0,0,0,0.1) !important;

  min-height: 450px !important;

  display: block !important;

  opacity: 1 !important;

  visibility: visible !important;

}



/* ====== LOCKBOX: Move QuickFix section down ====== */

#freeUnlockOverlay p[style*="font-size: 18px"] {

    position: relative !important;

    z-index: 100 !important;

    margin-top: 30px !important;

    margin-bottom: 5px !important;

    background: rgba(255, 255, 255, 0.95) !important;

    backdrop-filter: blur(10px) !important;

    padding: 16px 20px !important;

    border-radius: 12px !important;

    border: 1px solid rgba(0, 0, 0, 0.1) !important;

    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1) !important;

}



/* ====== LOCKBOX: Move bullet points up ====== */

#freeUnlockOverlay div[style*="background: rgba(255, 255, 255, 0.8)"] {

    position: relative !important;

    z-index: 100 !important;

    margin-top: 5px !important;

    margin-bottom: 20px !important;

    background: rgba(255, 255, 255, 0.95) !important;

    backdrop-filter: blur(10px) !important;

    padding: 12px 20px !important;

    border-radius: 12px !important;

    border: 1px solid rgba(0, 0, 0, 0.1) !important;

}



/* ====== LOCKBOX: Container adjustment ====== */

#lockboxEssayPreview {

    position: relative !important;

    z-index: 1 !important;

}



/* ====== LOCKBOX: QuickFix button and content above it ====== */

#freeUnlockOverlay button[onclick*="handleQuickFixClick"] {

    position: relative !important;

    z-index: 1000 !important;

    background: #ff6b00 !important;

}



#freeUnlockOverlay > div > div[style*="z-index: 1"] {

    position: relative !important;

}



#freeUnlockOverlay > div > div[style*="z-index: 1"] > p[style*="font-size: 18px"]:not(#quickfixPreCheckBox),

#freeUnlockOverlay > div > div[style*="z-index: 1"] > div[style*="Zero commitment"],

#freeUnlockOverlay > div > div[style*="z-index: 1"] > button {

    position: relative !important;

    z-index: 1000 !important;

    background: rgba(255, 255, 255, 0.98) !important;

}



#quickfixPreCheckBox {

    border: 2px dashed #ff6b00 !important;

    padding: 12px 16px !important;

    border-radius: 6px !important;

}



/* Rescan Comparison Modal Styles - Prevent conflicts */

#rescanComparisonModal {

    z-index: 999999 !important;

    position: fixed !important;

    top: 0 !important;

    left: 0 !important;

    width: 100vw !important;

    height: 100vh !important;

    background: rgba(0,0,0,0.8) !important;

}



#rescanComparisonModalContent {

    z-index: 1000000 !important;

    position: fixed !important;

    top: 50% !important;

    left: 50% !important;

    transform: translate(-50%, -50%) !important;

}



/* Ensure other elements don't cover the modal */

.quickfix-step, .essay-display, .input-section {

    z-index: 1 !important;

    position: relative !important;

}



/* Prevent multiple modals stacking */

.rescan-comparison-modal {

    z-index: 999999 !important;

}



/* Ensure backdrop covers everything */

body.modal-open {

    overflow: hidden !important;

}



/* Hide other modals when this one is active */

body.modal-open .quickfix-step,

body.modal-open .essay-display,

body.modal-open .input-section {

    filter: blur(2px) opacity(0.7);

    pointer-events: none;

}



/* Spinning animation for rescan button loading state */

@keyframes rescanButtonSpin {

  from { transform: rotate(0deg); }

  to { transform: rotate(360deg); }

}



#rescanAfterEditsBtn:disabled {

  cursor: not-allowed !important;

  opacity: 0.7 !important;

  pointer-events: none !important;

}



#rescanAfterEditsBtn:disabled .spinner-icon {

  display: inline-block;

  width: 14px;

  height: 14px;

  margin-right: 8px;

  border: 2px solid rgba(255, 255, 255, 0.3);

  border-top-color: white;

  border-radius: 50%;

  animation: rescanButtonSpin 0.8s linear infinite;

  vertical-align: middle;

}



</style>

</head>

<body>

<div class="page-wrapper">

<div class="panic-banner" id="panicBanner" style="display:none;">

  ðŸš¨ HIGH AI DECTION RISK - Only <span id="panicScansLeft">99</span> scan(s) left today! 

  <a href="#" onclick="handleProUpgrade(); return false;">Get Pro Now â†’</a>

</div>

<!-- QuickFix Flow Section -->

<div id="quickfixFlow" class="quickfix-flow-container">

  <div class="hero-section">

    <div style="text-align: center; margin-bottom: 16px;">

      <img src="https://i.postimg.cc/hPKB2kRp/Final-site-icon-trans.png" alt="False Flag Fixer Logo" style="width: 75px; height: 75px; display: block; margin: 0 auto; animation: slowRotate 7s linear infinite;">

    </div>

    <h1 id="mainHeaderTitle" class="hero-title">False Flag Fixerâ„¢ - <span id="mainHeaderQuickFixEmoji" style="color: #ffffff !important; display: inline-block; text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff, 0 0 30px #ffffff, 0 0 40px rgba(255, 255, 255, 0.5); filter: grayscale(100%) brightness(2) contrast(1.2) !important; font-weight: bold;">âš¡</span> QuickFix</h1>

    <p id="mainHeaderSubtitle" class="hero-subtitle" style="padding-bottom: 48px;">

      A Pro-level one-time, one price, full essay scan, full fix.

    </p>

  </div>



  <div class="main-container">

    <div class="input-section">

      <!-- STEP 1: QuickFix Landing -->

      <div id="quickfixStep1" class="quickfix-step active">

        <div class="lil-sus-header">

          <h2 style="font-family: 'Raleway', sans-serif; font-weight: 700; letter-spacing: -0.25px; color: #1e3a8a;">QuickFix â€” Fix It Fast âš¡</h2>

          <p style="font-style: normal; font-size: 15px; max-width: 800px; margin: 0 auto; line-height: 1.4; padding-bottom: 4px; color: #374151;">Those AI trigger words hiding in your essay?</p>

          <p style="font-style: normal; font-size: 15px; max-width: 800px; margin: 0 auto; line-height: 1.4; padding-bottom: 48px; color: #374151;">QuickFix finds them all and helps you fix them fast. Before Turnitin catches them.</p>

          <p style="font-style: normal; font-size: 17px; max-width: 800px; margin: 0 auto; line-height: 1.4; padding-top: 0; margin-top: 0; padding-bottom: 0; margin-bottom: 0; color: #1f2937; font-weight: 600;">Paste Your Essay Below</p>

        </div>



        <!-- Tip Info Box -->

        <div style="background: #ffe4cc; border: 1px solid #ffb366; border-radius: 8px; padding: 12px 16px; margin: 0 auto 16px auto; max-width: 800px; text-align: center;">

          <p style="margin: 0; color: #7c2d12; font-size: 14px; line-height: 1.5; font-weight: 500;">ðŸ’¡ Quick Tip: You can now paste up to 1,500 words here â€” way more than the free 500!</p>

        </div>



        <div style="position: relative; margin-top: -24px;">

          <textarea id="quickfixEssayInput" placeholder="Paste your essay here (up to 1,500 words)..." style="width:100%; height:200px; padding:15px; border:2px solid #e5e7eb; border-radius:10px; font-size:16px; font-family:inherit; resize:vertical; margin-bottom:15px; white-space: pre-wrap;"></textarea>

          <div class="quickfix-char-counter" style="position: absolute; bottom: 15px; right: 15px; text-align: right; color: #6b7280; font-size: 14px; background: rgba(255, 255, 255, 0.9); padding: 2px 6px; border-radius: 4px;"><span id="quickfixFlowCharCount">0</span>/1500</div>

        </div>



        <p style="text-align: center; margin: 8px 0 0 0; padding: 0 20px; color: #6b7280; font-size: 13px; line-height: 1.5;">ðŸ”’ Private & secure. Your essay isn't seen, stored or shared.</p>



        <button id="startQuickFix" class="btn-secondary btn-block btn-lg" style="margin-top: 20px; font-size: 18px;" data-tooltip="Find ALL AI-trigger words and fix them - $1.99. Scan up to 1,500 words.">

          <span style="color: #ffffff !important; display: inline-block; text-shadow: -1px -1px 0px #ffffff, 1px -1px 0px #ffffff, -1px 1px 0px #ffffff, 1px 1px 0px #ffffff, 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.6); filter: brightness(1) !important; font-weight: bold; -webkit- ">âš¡</span> QuickFix My Essay

        </button>



        <p style="text-align: center; margin: 0.25in auto 0; padding: 0 20px 0 20px; color: #374151; font-size: 15px; line-height: 1.5; max-width: 600px; font-weight: 600;">FYI: QuickFix is a one-time Pro-level fix. If you need more scans, go Pro ðŸ‘‡</p>



        <p style="text-align: center; margin: 16px auto 0; padding: 0.25in 20px 0 20px; color: #1e3a8a; font-size: 18px; font-weight: 700; line-height: 1.5; max-width: 600px;">Got Multiple Essays To Fix?</p>



        <div style="background: linear-gradient(to bottom, #00a8e8, #0b0646); border-radius: 16px; padding: 20px 16px; margin: 12px auto 0; width: 100%; max-width: 100%; text-align: center; box-shadow: 0 4px 12px rgba(0, 168, 232, 0.2);">

          <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">

            <span style="font-size: 24px;">ðŸš€</span>

            <h3 style="color: white; font-size: 20px; font-weight: 700; margin: 0;">Go Pro and Chill...</h3>

          </div>

          <p style="text-align: center; color: white; font-size: 14px; margin: 0 0 16px 0; line-height: 1.6; opacity: 0.95;">

            100 scans and fixes/month â€¢ Deeper AI fixes powered by Claude Haiku â€¢ Priority chat support â€¢ Cancel anytime

          </p>

          <button onclick="handleProUpgrade()" style="background: white; color: #00a8e8; border: 1px solid #00a8e8; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); transition: transform 0.2s; margin-bottom: 8px; width: 100%;">

            â†’ Get Pro - $9.99/mo

          </button>

          <div style="text-align: center; color: white; font-size: 10px; opacity: 0.9;">

            Cancel Anytime

          </div>

        </div>



        <div style="text-align:center; margin-top:15px;">

          <button class="btn-outline" onclick="hideQuickFixFlow()" style="margin-top: 15px; border: 1px dashed #0b0646 !important; color: #0b0646;">

            ðŸ  Back To Main Dashboard

          </button>

        </div>

      </div>



      <!-- STEP 2: Analysis Results (Before Fix) - IMPROVED -->

      <div id="quickfixStep2" class="quickfix-step">

        <!-- QuickFix Banner Cards -->

        <!-- HELLA SUS CARD (70-100%) -->

        <div id="quickfixHellaSusCard" class="card warning-card" style="padding: 0; overflow: visible; position: relative; display: none; margin-bottom: 20px;">

          <!-- Your AI Sus Score Title -->

          <div style="text-align: center; margin: -48px 0 48px 0; position: relative; z-index: 10;">

            <h3 style="font-size: 36px; font-weight: 700; font-family: 'Raleway', sans-serif; color: #0b0646; margin: 0 0 8px 0; text-align: center; letter-spacing: -0.25px;">Your AI Sus Score</h3>

            <p style="font-size: 14px; font-weight: 400; color: #6b7280; margin: 0; text-align: center; line-height: 1.4;">How suspicious your writing looks to AI detectors â€” even though it's 100% human ðŸ™„</p>

          </div>

          <!-- HEADER SECTION - NEW STYLE -->

          <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #dc2626; border-right: 8px solid #dc2626;">

            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

              <div style="width: 60px; height: 60px; background: #fee2e2; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3); flex-shrink: 0;">

                <span style="font-size: 36px; line-height: 1;">ðŸš©</span>

              </div>

              <div style="text-align: center;">

                <h2 id="quickfixHellaSusWarningTitle" style="font-size: 32px; font-weight: 700; font-family: 'Raleway', sans-serif; margin: 0; line-height: 1; color: #ff4444; letter-spacing: -0.25px;">Major Sus</h2>

                <p id="quickfixHellaSusLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">AI detectors are gonna lose it - time for the full glow-up âœ¨</p>

              </div>

            </div>

          </div>

        </div>



        <!-- KINDA SUS CARD (30-69%) -->

        <div id="quickfixKindaSusCard" class="card warning-card" style="padding: 0; overflow: visible; position: relative; display: none; margin-bottom: 20px;">

          <!-- Your AI Sus Score Title -->

          <div style="text-align: center; margin: -48px 0 48px 0; position: relative; z-index: 10;">

            <h3 style="font-size: 36px; font-weight: 700; font-family: 'Raleway', sans-serif; color: #0b0646; margin: 0 0 8px 0; text-align: center; letter-spacing: -0.25px;">Your AI Sus Score</h3>

            <p style="font-size: 14px; font-weight: 400; color: #6b7280; margin: 0; text-align: center; line-height: 1.4;">How suspicious your writing looks to AI detectors â€” even though it's 100% human ðŸ™„</p>

          </div>

          <!-- HEADER SECTION - NEW STYLE -->

          <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #f5a623; border-right: 8px solid #f5a623;">

            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

              <div style="width: 60px; height: 60px; background: #fef3c7; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(245, 166, 35, 0.3); flex-shrink: 0;">

                <span style="font-size: 36px; line-height: 1;">âš ï¸</span>

              </div>

              <div style="text-align: center;">

                <h2 id="quickfixKindaSusWarningTitle" style="font-size: 32px; font-weight: 700; font-family: 'Raleway', sans-serif; margin: 0; line-height: 1; color: #f5a623; letter-spacing: -0.25px;">Mid Sus</h2>

                <p id="quickfixKindaSusLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">These sentences are lowkey cooked. Not on Lil' Sus's watch.</p>

              </div>

            </div>

          </div>



          <!-- Rotating phrases for Kinda Sus -->

          <!-- Kinda Sus Alert -->

          <div class="kinda-sus-alert" style="display: none; margin: 24px 0 16px 0;">

            <div style="background: #f59e0b; color: white; font-weight: 700; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">

              <span style="font-size: 20px;">âš ï¸</span>

              <span>Some wording might come across as AI</span>

            </div>

          </div>

        </div>



        <!-- YOU'RE GOOD CARD (0-29%) -->

        <div id="quickfixYoureGoodCard" class="card warning-card" style="padding: 0; overflow: visible; position: relative; display: none; margin-bottom: 20px;">

          <!-- Your AI Sus Score Title -->

          <div style="text-align: center; margin: -48px 0 48px 0; position: relative; z-index: 10;">

            <h3 style="font-size: 36px; font-weight: 700; font-family: 'Raleway', sans-serif; color: #0b0646; margin: 0 0 8px 0; text-align: center; letter-spacing: -0.25px;">Your AI Sus Score</h3>

            <p style="font-size: 14px; font-weight: 400; color: #6b7280; margin: 0; text-align: center; line-height: 1.4;">How suspicious your writing looks to AI detectors â€” even though it's 100% human ðŸ™„</p>

          </div>

          <!-- HEADER SECTION - NEW STYLE -->

          <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #2ecc71; border-right: 8px solid #2ecc71;">

            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

              <div style="width: 60px; height: 60px; background: #d1fae5; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(46, 204, 113, 0.3); flex-shrink: 0;">

                <span style="font-size: 36px; line-height: 1;">âœ…</span>

              </div>

              <div style="text-align: center;">

                <h2 id="quickfixYoureGoodWarningTitle" style="font-size: 32px; font-weight: 700; font-family: 'Raleway', sans-serif; margin: 0; line-height: 1; color: #2ecc71; letter-spacing: -0.25px;">Low Sus</h2>

                <p id="quickfixYoureGoodLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">No AI-trigger words detected</p>

              </div>

            </div>

          </div>



          <!-- Rotating fun message for Clean No Sus Step 2 - SWAPPED: now above score (was below progress bar) -->

          <div id="quickfixCleanNoSusCTA" style="display: none; background: transparent; padding: 0; margin: 16px 0 24px 0; text-align: center; width: 100%;">

            <p id="quickfixCleanNoSusCTAText" style="color: #1e3a8a; font-size: 20px; font-weight: 700; margin: 0 0 8px 0; line-height: 1.5; transition: opacity 0.5s ease-in-out;">

              Clean as a whistle! Ready to turn it in âœ¨

            </p>

            <p id="quickfixCleanNoSusCTASubtext" style="color: #64748b; font-size: 14px; font-style: italic; margin: 0; line-height: 1.5; transition: opacity 0.5s ease-in-out;">

              Your essay just got a glow-up. Flag drop confirmed. âœ¨

            </p>

          </div>

        </div>



        <!-- FIX 3: Score moved to top -->

        <!-- Score Display - FIXED POSITION -->

        <div style="text-align:center; margin-bottom:30px;">

          <!-- Yellow CTA box for Kinda Sus - REMOVED (first duplicate phrase box) -->

          <!-- Red CTA box for Hella Sus - REMOVED (first duplicate phrase box) -->

          <div class="score-display" style="display: flex; flex-direction: column; align-items: center; gap: 4px;">

            <span class="score-number" id="quickfixOriginalScore" style="font-size: 72px; font-weight: 700; color: #2ecc71; line-height: 1;">0%</span>

            <span class="score-label" id="quickfixScoreLabel" style="font-size: 14px !important; font-weight: 600 !important; letter-spacing: 0.5px; color: #6b7280 !important; line-height: 1;">Low Sus</span>

          </div>

          <!-- Progress Bar with Dot Indicator -->

          <div class="progress-container">

            <div class="progress-bar" id="quickfixProgressBar" style="height: 8px; background: #e5e7eb; border-radius: 4px; position: relative; overflow: visible; border: 1px solid #ccc;">

              <div class="progress-fill" id="quickfixProgressFill"></div>

              <div class="progress-indicator" id="quickfixProgressIndicator"></div>

            </div>

            <div class="progress-endpoints">

              <span>0%</span>

              <span>50%</span>

              <span>100%</span>

            </div>

            <div class="progress-labels">

              <span>âœ… Low Sus</span>

              <span>âš ï¸ Mid Sus</span>

              <span>ðŸš¨ Major Sus</span>

            </div>

          </div>

        </div>



        <!-- Clean Alert - SWAPPED: now below progress bar (was above score) - QF Low Sus Step 1 ONLY -->

        <div id="quickfixStep2CleanAlert" class="clean-alert" style="display: none; margin: 24px 0 16px 0;">

          <div style="background: #10b981; color: white; font-weight: 700; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">

            <span style="font-size: 20px;">âœ…</span>

            <span>Clean as a whistle!</span>

          </div>

        </div>



        <!-- FIX 1: Dynamic flag count heading -->

        <!-- Essay with Numbered Flags -->

        <div id="quickfixEssayContainer" style="background:#f8f9fa; border-radius:12px; padding:20px 20px 10px 20px; margin:20px 0;">

            <!-- Problem Statement -->

            <h3 id="quickfixCountHeading" style="text-align:center; color:#86efac; font-size:20px; font-weight:700; margin-top:30px; margin-bottom:8px;">

              ðŸ’¡ QuickFix found <span id="quickfixCount" style="color: #10b981;">3</span> AI-trigger word<span id="quickfixCountPlural">s</span>.

            </h3>

            <!-- Instruction text (first line) -->

            <p id="quickfixInstructionText" style="text-align:center; color:#6b7280; font-size:14px; margin:4px 0 20px 0; font-weight:500;">

              Click any highlighted word to see why it sounds like AI and how to fix it.

            </p>



            <!-- Essay Content -->

            <div id="flaggedEssayContent" class="essay-content" style="line-height:1.8; max-height: 400px; overflow-y: auto; overflow-x: auto; border: 1px solid #d1d5db; border-left: 4px solid #dc2626; border-right: 4px solid #dc2626; border-radius: 8px; padding: 20px; background: white; margin-top: 39px; margin-bottom: 0; font-size: 16px;">

            <!-- Flagged content will be inserted here -->

          </div>



          <p id="quickfixTransitionCopy" style="text-align: center; color: #374151; font-size: 16px; font-weight: 600; margin: 24px 0 16px 0; line-height: 1.4;">

            Ready to fix them? Select your replacements below:

          </p>



          <!-- Copy Text CTA for QF Low Sus Step 1; Trusted section for Pro Low Sus Step 1 (replaces green CTA) -->

          <div id="quickfixCopyTextCTA" style="display: none; text-align: center; margin: 0; padding: 24px 0 24px 0;">

            <button onclick="copyQuickFixResult()" style="background: white !important; color: #047857 !important; border: 2px dashed #10b981 !important; border-radius: 8px; padding: 12px 24px; font-size: 16px; font-weight: 600; cursor: pointer; width: 100%; transition: all 0.2s; margin: 0;" onmouseover="this.style.background='#f0fdf4'; this.style.borderColor='#059669'; this.style.color='#047857';" onmouseout="this.style.background='white'; this.style.borderColor='#10b981'; this.style.color='#047857';">

              âœ… Copy & Turn It In

            </button>

          </div>

          <!-- Pro Low Sus Step 1: Dashboard buttons under Copy CTA -->

          <div id="proLowSusDashboardButtons" style="display: none; margin: 16px 0 0 0;">

            <div style="display: flex; flex-direction: column; gap: 12px;">

              <button onclick="hideQuickFixFlow()" style="background: white; border: 2px dashed #0b0646; border-radius: 12px; padding: 14px 24px; font-size: 14px; font-weight: 600; color: #0b0646; cursor: pointer; width: 100%;">

                ðŸ  Back To Main Dashboard

              </button>

              <button onclick="backToProDashboard()" style="background: white; border: 2px solid #00a8e8; border-radius: 12px; padding: 14px 24px; font-size: 14px; font-weight: 600; color: #00a8e8; cursor: pointer; width: 100%;">

                ðŸ’Ž Back To Pro Dashboard

              </button>

            </div>

          </div>

          <!-- Pro Low Sus Step 1: Trusted section (replaces green Copy CTA for Pro users) -->

          <div id="proLowSusTrustedInPlaceOfCopy" style="display: none; text-align: center; margin: 0; padding: 24px 0 24px 0;">

            <p style="color: #374151; font-size: 14px; font-weight: 600; margin: 0 0 0 0; line-height: 1.4;">

              Trusted by 10,000+ students who fixed their false flags

            </p>

            <p style="color: #6b7280; font-size: 13px; font-weight: 400; margin: 2px 0 8px 0; line-height: 1.4;">

              and turned their essays in with confidence.

            </p>

            <div style="display: flex; align-items: center; justify-content: center; gap: 4px; margin-top: 4px;">

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

            </div>

          </div>



        </div>



        <!-- LIL SUS CLEAN ESSAY MESSAGE (QuickFix Step 2 Clean No Sus only) - After Copy Text CTA, above lockbox -->

        <div id="quickfixCleanNoSusLilSusMessage" style="display: none !important; text-align: center; margin: 24px 0; padding: 20px; background: #f0fdf4 !important; border-radius: 12px; border: 2px solid #2ecc71; position: relative !important; z-index: 9999 !important; opacity: 1 !important; visibility: visible !important;">

          <div style="display: flex; align-items: center; justify-content: center; gap: 16px; flex-wrap: wrap;">

            <img src="https://i.postimg.cc/BvfyyZqm/Generated-Image-September-04-2025-10-44AM.jpg" alt="Lil Sus" style="width: 80px; height: auto; animation: pointBackForth 2s ease-in-out infinite; flex-shrink: 0;">

            <p style="font-size: 20px; font-weight: 700; color: #047857; margin: 0; line-height: 1.4;">

              Your essay is clean and ready to turn in! âœ¨

            </p>

          </div>

        </div>



        <!-- CTA UNDER-TEXT (QuickFix Step 2 Clean No Sus only) - Under green box with Lil Sus -->

        <p id="quickfixCleanNoSusCtaUndertext" style="display: none; margin: 96px 0 12px 0; font-size: 18px; color: #6b7280; text-align: center; line-height: 1.6;">

          âš ï¸ AI detectors are unpredictable â€” essays flagged 0% today can trigger tomorrow. Better safe than sus.

        </p>



        <!-- Numbered Flag Explanations with Checkboxes -->

        <div id="flagExplanationsSection" style="max-width: 700px; margin: 24px auto 0 auto;">

          <div class="modern-toggle-container" style="background: white; border: 1px solid #e5e7eb; border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.1); overflow: hidden; margin-bottom: 0;">

            <div class="toggle-header" style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%); padding: 16px 20px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s ease; border-bottom: 1px solid #fecaca; border-top: 1px solid #fecaca; border-left: 1px solid #fecaca; border-right: 1px solid #fecaca;">

              <div style="display: flex; align-items: center; gap: 12px; flex: 1; justify-content: center;">

                <div style="text-align: center;">

                  <h4 id="quickfixFixesTitle" style="color:#dc2626; margin:0; font-size: 18px; font-weight: 700;">Pick Your Fixes</h4>

                  <p id="quickfixFixesSubtitle" style="color:#6b7280; margin:4px 0 0 0; font-size: 13px;">You can auto-fix all high-risk words at once, or customize each one below.</p>



                  <!-- Select All Toggle -->

                  <div style="margin: 15px 0; text-align: center; padding-top: 0;">

                    <!-- Guarantee Banner -->

                    <div id="quickfixGuaranteeBanner" style="background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; padding: 20px 24px; margin: 20px 0; border-radius: 12px; box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3); text-align: center;">

                      <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 16px; color: white; justify-content: center; margin-bottom: 12px;">

                        <span style="font-size: 40px; animation: slideRight 2s ease-in-out infinite; line-height: 1; display: flex; align-items: center;">ðŸ‘‰</span>

                        <input type="checkbox" id="selectAllFixes" style="margin: 0; transform: scale(1.2); vertical-align: middle;">

                        <span style="font-weight: 600; font-size: 16px;">QuickFix Mode: Use Best Words</span>

                      </label>

                      <div style="font-size: 14px; opacity: 0.95;">Apply fixes â†’ See your new score</div>

                    </div>



                    <!-- Disclaimer below banner -->

                    <div style="text-align: center; margin-top: 12px; font-size: 12px; color: #6b7280;">

                      Apply our swaps - score drop is baked in. Or not. We won't stop you.<br>But Lil' Sus knows what's up. Just sayin

                    </div>



                    <!-- Toggle Arrow - Centered below Heads Up box -->

                    <div id="toggleArrowContainer" style="margin: 12px auto 0 auto; background: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 2px rgba(0,0,0,0.1); cursor: pointer;" onclick="event.stopPropagation(); toggleFixSelection();">

                      <span id="toggleArrow" style="font-size: 16px; color: #374151; transition: transform 0.3s ease; pointer-events: none;">â–¼</span>

                    </div>

                  </div>

                </div>

              </div>

            </div>

            <!-- Real-time Score Preview Box (Banner/Flag Shape) - Points to selected fix option -->

            <div id="scorePreviewBox" style="position: fixed; z-index: 1000; display: none; visibility: hidden; opacity: 0;">

              <!-- Banner body with flag shape - pointed left, notched right, LONGER -->

              <div id="scorePreviewBanner" style="position: relative; padding: 14px 35px 14px 50px; width: 320px; height: 110px; box-shadow: 0 4px 20px rgba(0,0,0,0.25); clip-path: polygon(25px 0%, 100% 0%, 100% 25%, calc(100% - 20px) 50%, 100% 75%, 100% 100%, 25px 100%, 0% 50%); transition: background 0s; display: flex; flex-direction: column; justify-content: center;">

                <div id="previewScoreLine" style="font-size: 15px; font-weight: 600; color: #ffffff; margin-bottom: 4px; text-align: left;">Your Current Sus Score: <span id="previewScore" style="font-size: 24px; font-weight: 700; color: #ffffff;">--</span></div>

                <div id="previewAfterFixes" style="font-size: 16px; font-weight: 500; color: #ffffff; text-align: left; opacity: 0.95; margin-bottom: 6px;">After Selected Fix: <span id="previewAfterFixesScore" style="font-size: 22px; font-weight: 700; color: #ffffff;"></span><span id="previewAfterFixesAsterisk" style="font-size: 14px; color: #ffffff; opacity: 0.85; cursor: help;"></span></div>

                <div id="previewImprovement" style="font-size: 12px; font-weight: 700; color: #ffffff; text-align: left; opacity: 0.95; margin-bottom: 0;"></div>

                <div id="previewEstimateLabel" style="position: absolute; bottom: 10px; right: 35px; font-size: 10px; color: #ffffff; opacity: 0.85;">*Estimate</div>

              </div>

              <!-- Pointer triangle removed -->

            </div>



            <div id="fixSelection" class="fix-selection" style="display: block; padding: 0; max-height: 400px; overflow-y: scroll; overflow-x: hidden;">

              <div id="fixSelectionInstructionBox" style="background: #f8f9fa; padding: 12px 16px; border-bottom: 1px solid #e5e7eb;">

                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">

                  <div style="background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; width: 18px; height: 18px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">âœ“</div>

                  <p style="color: #374151; font-size: 13px; margin: 0; font-weight: 600;">

                    Select the fixes you want to apply. Choose your own word replacements, or use the checkbox below to auto-select the best words â€” those with the lowest chance to trigger AI detectors.

                  </p>

                </div>

                <p style="color: #6b7280; font-size: 12px; margin: 0; line-height: 1.4;">

                  Each fix shows the original word â†’ suggested replacement with explanation, AI trigger risk, and estimated score improvement.

                </p>

              </div>

              <div style="padding: 12px 16px;">

            <!-- Fix options will be inserted here -->

              </div>

            </div>

          </div>



          <!-- Button group with proper color hierarchy -->

          <div id="quickfixButtonGroup" style="display: flex; gap: 16px; justify-content: center; align-items: center; margin: 0; padding: 48px 0 42px 0; flex-wrap: wrap; line-height: 1;">

            <!-- Animated pointing hand emoji -->

            <span id="quickfixCTAHand" style="font-size: 32px; margin-right: -8px; animation: slideRight 2s ease-in-out infinite; display: inline-block;">ðŸ‘‰</span>

            <!-- QuickFix All (Recommended) - Green -->

            <button id="applyAllFixes" class="btn-secondary" style="min-width: 300px; background: #10b981 !important; color: white !important; margin: 0; padding: 12px 24px; line-height: 1; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">

              <span style="display:inline-flex;align-items:center;justify-content:center;width:20px;height:20px;background:white;color:#10b981;border-radius:4px;font-size:12px;font-weight:700;">âœ“</span>

              QuickFix All (Recommended)

            </button>

            <!-- QuickFix Selected Words Only - Orange -->

            <button id="applySelectedFixes" class="btn-secondary" style="min-width: 300px; background: #ff6b00 !important; color: white !important; margin: 0; padding: 12px 24px; line-height: 1; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">

              QuickFix Selected Words Only (<span id="selectedCount">0</span>)

            </button>

          <button id="copyTextButton" class="btn-secondary" style="min-width: 300px; background: white !important; color: #003d7a !important; display: none; border: 1px solid #003d7a !important; border-radius: 8px; padding: 12px 24px; font-size: 16px; font-weight: 600; cursor: pointer; margin: 0; line-height: 1;">

              ðŸ“‹ Copy Text

          </button>

            <!-- Premium feature = Blue -->

          </div>



          <!-- Back To Main Dashboard - QuickFix Step 2 for all scores -->

          <div id="quickfixStep2BackToDashboard" style="display: none; text-align: center; margin: 16px 0 0 0;">

            <button onclick="hideQuickFixFlow()" style="background: white; border: 2px dashed #0b0646; border-radius: 12px; padding: 14px 24px; font-size: 14px; font-weight: 600; color: #0b0646; cursor: pointer; min-width: 320px; width: 100%; max-width: 400px;">

              ðŸ  Back To Main Dashboard

            </button>

          </div>



          <!-- QF Low Sus Step 1 ONLY: FYI Bestie (moved to after quickfixButtonGroup) -->

          <div id="qfLowSusFyiBestieBlock" style="display: none; margin: 24px 0 0 0; text-align: center; line-height: 1.6;">

            <div style="display: flex; align-items: center; justify-content: center; gap: 12px; font-size: 20px; margin-bottom: 8px; font-weight: bold;">

              <img src="https://i.postimg.cc/vT6KtkH0/LS-pointing-trans-1.png" alt="Lil Sus" class="lil-sus-pulsate" style="height: 56px; width: auto; object-fit: contain;" />

              <span style="color: #0b0646;">âš ï¸ FYI</span>

            </div>

            <p style="font-size: 14px; color: #6b7280; margin: 0 0 24px 0; line-height: 1.6; font-weight: 500;">

              AI detectors can be moody af â€” what's 'low sus' today might trigger them tomorrow. Your Pro sub already covers deeper scans with Claude Haiku, so you're good. Just sayin'.

            </p>

          </div>

          <!-- GO AHEAD! TURN IT IN! moved to white section -->

          <div id="goAheadTurnItIn" style="display: none; text-align: center; margin: 24px 0;">

            <div style="background: #10b981; color: white; border: none; border-radius: 8px; padding: 12px 20px; font-size: 18px; font-weight: 700; width: 100%; pointer-events: none;">

              ðŸŽ‰ Go Ahead! Turn It In! ðŸŽ‰

            </div>

          </div>



          <!-- QF Low Sus Step 1 ONLY: Green Get Another QuickFix CTA + Stripe (image 1 style) -->

          <div id="qfLowSusGreenCta" style="display: none; text-align: center; margin: 24px 0 16px 0;">

            <button onclick="handleQuickFixClick()" class="btn-secondary" style="min-width: 300px; background: #10b981 !important; color: white !important; margin: 0 auto 12px auto; padding: 12px 24px; line-height: 1; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; border: none;">

              <span style="display:inline-flex;align-items:center;justify-content:center;width:20px;height:20px;background:white;color:#10b981;border-radius:4px;font-size:12px;font-weight:700;">âœ“</span>

              Get Another QuickFix - $1.99

            </button>

            <p style="text-align: center; color: #6b7280; font-size: 12px; margin: 0;">

              Secure payment by <span style="font-weight: 700; color: #635bff;">Stripe</span>

            </p>

          </div>



          <!-- QF Low Sus Step 1 ONLY: QF upsell + Go Pro & Chill -->

          <div class="upsell-section" id="quickfixUpsellSection" style="background: #ffffff; border: 2px dashed #ff6b00; border-radius: 8px; padding: 32px 24px; margin: 24px 0 16px 0; text-align: center; display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.1); width: 100%; max-width: 100%; box-sizing: border-box;">

            <div style="font-size: 48px; margin-bottom: 16px;">ðŸ”’</div>

            <h3 style="font-size: 20px; font-weight: 700; margin: 0 0 8px 0; line-height: 1.3; color: #1e3a8a;">Wanna scan another essay?</h3>

            <p style="font-size: 13px; line-height: 1.6; margin: 0 0 16px 0; color: #6b7280;">Lock in peace of mind with another âš¡ QuickFix</p>

            <p style="font-size: 14px; line-height: 1.6; margin: 0 0 16px 0; color: #374151;">Did you know your 100% human-written essay can sound AI to detectors and still get flagged? Yup, that's wild AF! For $1.99, QuickFix shows you what Turnitin will flag and how to fix it. Don't turn it in yet. Fix it first.</p>

            <p style="font-size: 18px; font-weight: 600; margin: 0 auto 16px auto; color: #1f2937; border: 2px dashed #ff6b00; padding: 12px 16px; border-radius: 6px; display: block; width: fit-content; text-align: center; box-sizing: border-box;">Don't Risk It. QuickFix It.</p>

            <div style="margin-top: 16px; margin-bottom: 16px; padding-bottom: 12px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">

              <div style="font-size: 16px; display: flex; align-items: center; gap: 4px;"><span>âœ…</span><span>Zero commitment</span></div>

              <div style="font-size: 16px; display: flex; align-items: center; gap: 4px;"><span>âœ…</span><span>Zero panic</span></div>

              <div style="font-size: 16px; display: flex; align-items: center; gap: 4px;"><span>âœ…</span><span>Zero F's given</span></div>

            </div>

            <button onclick="handleQuickFixClick()" style="background: #ff6b00; color: white; border: none; padding: 12px 24px; border-radius: 6px; font-weight: 700; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; margin-bottom: 12px;"><span>âš¡</span><span>Get Another QuickFix - $1.99</span></button>

            <p style="font-size: 13px; margin: 0; color: #6b7280;">Only $1.99 for peace of mind ðŸ˜Š</p>

          </div>



          <!-- Pro Low Sus Step 1 ONLY: Fun Fact graphic (replaces QF upsell box for Pro users) -->

          <div id="proFunFactGraphicProLowSus" style="display: none; width: 100%; max-width: 672px; margin: 24px auto; box-sizing: border-box;">

            <div style="background: linear-gradient(to bottom, #00a8e8, #0b0646); border-radius: 8px; padding: 48px 24px; text-align: center; position: relative; overflow: hidden; border: 1px solid #334155;">

              <div style="position: absolute; top: 0; right: 0; width: 384px; height: 384px; background: linear-gradient(to bottom, #00a8e8, #0b0646); opacity: 0.1; border-radius: 50%; filter: blur(48px); pointer-events: none;"></div>

              <div style="position: relative; z-index: 10;">

                <div class="flags-blow-wind" style="font-size: 48px; margin: 0 auto 32px; line-height: 1; letter-spacing: 4px;"><span>ðŸš©</span><span>ðŸš©</span><span>ðŸš©</span></div>

                <h2 style="color: #ffffff; font-family: 'Raleway', sans-serif; font-weight: 600; font-size: 1.75rem; line-height: 1.25; margin: 0 0 32px 0; padding: 0 8px;">Plot Twist</h2>

                <p style="color: #ffffff; font-family: 'Raleway', sans-serif; font-weight: 400; font-size: 1.1rem; line-height: 1.4; margin: 0 0 24px 0; padding: 0 8px;">

                  Perfectly written essays trigger MORE false flags than mediocre ones.

                </p>

                <p style="color: #e2e8f0; font-weight: 600; font-size: 1rem; margin: 0 0 32px 0;">

                  High quality = high risk of AI detection.

                </p>

                <div style="display: inline-block; margin-bottom: 16px;">

                  <p style="color: #7dd3fc; font-weight: 700; font-size: 1.25rem; margin: 0;">

                    That's why Pro is the move

                  </p>

                  <div style="height: 4px; background: linear-gradient(to right, transparent, #60a5fa, transparent); margin-top: 12px;"></div>

                </div>

                <div style="margin-top: 16px;">

                  <p style="color: #ffffff; font-size: 1.1rem; font-weight: 600; margin: 0 0 0 0; padding-top: 12px;">Friends don't let friends get false flags</p>

                  <a href="javascript:void(0)" onclick="shareFalseFlagFixer(event); return false;" style="color: #22c55e; font-weight: 600; font-size: 18px; text-decoration: none; transition: color 0.2s; cursor: pointer; display: inline-block; margin-top: 24px;" onmouseover="this.style.color='#4ade80';" onmouseout="this.style.color='#22c55e';">Share False Flag Fixer<sup style="font-size: 10px; vertical-align: super;">TM</sup> with the group chat</a>

                  <div style="display: flex; justify-content: center; gap: 20px; margin-top: 24px;">

                    <a href="https://pinterest.com/pin/create/button/?url=https://falseflagfixer.com&description=Fix%20your%20AI%20false%20flags" target="_blank" style="text-decoration: none; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.7';" onmouseout="this.style.opacity='1';" title="Share on Pinterest"><svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="#E60023"><path d="M12 0C5.373 0 0 5.372 0 12c0 5.084 3.163 9.426 7.627 11.174-.105-.949-.2-2.405.042-3.441.218-.937 1.407-5.965 1.407-5.965s-.359-.719-.359-1.782c0-1.668.967-2.914 2.171-2.914 1.023 0 1.518.769 1.518 1.69 0 1.029-.655 2.568-.994 3.995-.283 1.194.599 2.169 1.777 2.169 2.133 0 3.772-2.249 3.772-5.495 0-2.873-2.064-4.882-5.012-4.882-3.414 0-5.418 2.561-5.418 5.207 0 1.031.397 2.138.893 2.738.098.119.112.224.083.345l-.333 1.36c-.053.22-.174.267-.402.161-1.499-.698-2.436-2.889-2.436-4.649 0-3.785 2.75-7.262 7.929-7.262 4.163 0 7.398 2.967 7.398 6.931 0 4.136-2.607 7.464-6.227 7.464-1.216 0-2.359-.632-2.75-1.378l-.748 2.853c-.271 1.043-1.002 2.35-1.492 3.146C9.57 23.812 10.763 24 12 24c6.627 0 12-5.373 12-12 0-6.628-5.373-12-12-12z"/></svg></a>

                    <a href="https://twitter.com/intent/tweet?text=Fix%20your%20AI%20false%20flags%20with%20False%20Flag%20Fixer!&url=https://falseflagfixer.com" target="_blank" style="text-decoration: none; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.7';" onmouseout="this.style.opacity='1';" title="Share on X"><svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="#ffffff"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a>

                    <a href="https://www.tiktok.com/" target="_blank" style="text-decoration: none; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.7';" onmouseout="this.style.opacity='1';" title="Share on TikTok"><svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="#ffffff"><path d="M19.59 6.69a4.83 4.83 0 0 1-3.77-4.25V2h-3.45v13.67a2.89 2.89 0 0 1-5.2 1.74 2.89 2.89 0 0 1 2.31-4.64 2.93 2.93 0 0 1 .88.13V9.4a6.84 6.84 0 0 0-1-.05A6.33 6.33 0 0 0 5 20.1a6.34 6.34 0 0 0 10.86-4.43v-7a8.16 8.16 0 0 0 4.77 1.52v-3.4a4.85 4.85 0 0 1-1-.1z"/></svg></a>

                  </div>

                  <p style="color: #60a5fa; font-size: 18px; font-weight: 700; margin: 12px 0 0 0;">#fthefalseflags</p>

                </div>

              </div>

            </div>

          </div>

          <!-- Pro Low Sus Step 1 ONLY: Trusted testimonial below Fun Fact -->

          <div id="proTrustedTestimonialLowSus" style="display: none; width: 100%; max-width: 672px; margin: 24px auto 0 auto; text-align: center; box-sizing: border-box;">

            <p style="color: #374151; font-size: 16px; margin: 0 0 8px 0; font-weight: 500;">Trusted by 10,000+ students who fixed their false flags and turned their essays in with confidence.</p>

            <p style="font-size: 24px; margin: 0; letter-spacing: 2px;">â­â­â­â­â­</p>

          </div>





          <!-- Go Pro & Chill - QF Low Sus Step 1 ONLY -->

          <div id="quickfixStep2GoProBanner" style="display: none; background: linear-gradient(to bottom, #00a8e8, #0b0646); border-radius: 16px; padding: 20px 16px; margin: 0 0 16px 0; text-align: center; box-shadow: 0 4px 12px rgba(0, 168, 232, 0.2); width: 100%; max-width: 100%; box-sizing: border-box;">

            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">

              <span style="font-size: 24px;">ðŸš€</span>

              <h3 style="color: white; font-size: 20px; font-weight: 700; margin: 0;">Go Pro & Chill...</h3>

            </div>

            <p style="text-align: center; color: white; font-size: 14px; margin: 0 0 8px 0; line-height: 1.6; opacity: 0.95;">

              100 scans and fixes/month â€¢ Deeper AI fixes powered by Claude Haiku â€¢ Priority chat support â€¢ Cancel anytime

            </p>

            <p style="text-align: center; color: white; font-size: 14px; margin: 0 0 16px 0; line-height: 1.6; opacity: 0.95;">

              <strong>Fix the AI flags before the AI flags you.</strong>

            </p>

            <button onclick="handleProUpgrade()" style="background: white; color: #00a8e8; border: 1px solid #00a8e8; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); transition: transform 0.2s; margin-bottom: 8px; width: 100%;">

              â†’ Get Pro - $9.99/mo

            </button>

            <div style="text-align: center; color: white; font-size: 10px; opacity: 0.9;">

              Cancel Anytime

            </div>

          </div>





          <!-- Stripe payment text (for Hella/Kinda Sus) -->

          <p id="proStripeText" style="display: none; text-align: center; color: #6b7280; font-size: 12px; margin: 8px 0 0 0;">

            Secure payment by <span style="font-weight: 700; color: #635bff;">Stripe</span>

          </p>



          <!-- Pro Step 2 Major Sus: Back To Pro Dashboard above Trusted section -->

          <div id="proStep2BackToDashboard" style="display: none; text-align: center; margin: 0 0 16px 0;">

            <button onclick="backToProDashboard()" style="background: white; border: 1px dashed #00a8e8; border-radius: 12px; padding: 14px 24px; font-size: 14px; font-weight: 600; color: #00a8e8; cursor: pointer; min-width: 320px; width: 100%; max-width: 400px;">

              ðŸ’Ž Back To Pro Dashboard

            </button>

          </div>



          <!-- Trusted by students section - PRO PAGE STEP 2 ONLY (Major Sus: padding above) -->

          <div id="step2TrustedSection" style="display: none; text-align: center; margin: 0 0 16px 0; padding-top: 24px;">

            <p style="color: #374151; font-size: 14px; font-weight: 600; margin: 0 0 0 0; line-height: 1.4;">

              Trusted by 10,000+ students who fixed their false flags

            </p>

            <p style="color: #6b7280; font-size: 13px; font-weight: 400; margin: 2px 0 8px 0; line-height: 1.4;">

              and turned their essays in with confidence.

            </p>

            <div style="display: flex; align-items: center; justify-content: center; gap: 4px; margin-top: 4px;">

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

              <span style="color: #fbbf24; font-size: 18px;">â­</span>

            </div>

          </div>



          <!-- Email Signup Form for All Users (QuickFix & Pro) - Step 2 -->

          <div id="proEmailSignupForm" style="display: none; margin-top: 48px; padding: 32px 24px; background: #f8f9fa; border: 1px solid #e5e7eb; border-radius: 12px; width: 100%;">

            <div style="text-align: center; margin-bottom: 12px;">

              <img src="https://i.postimg.cc/nhnTZ7c9/LS-BLUE-CIRCLE.png" alt="Lil Sus" style="width: 80px; height: auto; display: block; margin: 0 auto;">

            </div>

            <h3 style="font-size: 20px; font-weight: 700; color: #1e3a8a; margin: 0 0 8px 0; text-align: center;">

              Get the Deets. Better Safe than Sus.

            </h3>

            <p style="font-size: 14px; color: #6b7280; margin: 0 0 20px 0; text-align: center; line-height: 1.5;">

              Get updates on our Chrome extension, mobile app, and new features coming soon.

            </p>

            <form id="proEmailSignupFormElement" onsubmit="handleEmailSignup(event)" style="display: flex; flex-direction: column; gap: 12px;">

              <input 

                type="email" 

                id="proEmailInput" 

                placeholder="Enter your email address" 

                required

                style="padding: 12px 16px; width: 100%; border: 1px solid #d1d5db; border-radius: 8px; font-size: 14px; font-family: inherit; color: #374151; background: white; transition: border-color 0.2s; box-sizing: border-box;"

                onfocus="this.style.borderColor='#00a8e8'; this.style.outline='none';"

                onblur="this.style.borderColor='#d1d5db';"

              >

              <button 

                type="submit" 

                id="proEmailSubmitBtn"

                style="padding: 12px 24px; width: 100%; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;"

                onmouseover="this.style.background='#2c5282'; this.style.transform='translateY(-1px)';"

                onmouseout="this.style.background='#1e3a5f'; this.style.transform='translateY(0)';"

              >

                Subscribe

              </button>

            </form>

            <p style="font-size: 11px; color: #9ca3af; margin: 8px 0 0 0; text-align: center; line-height: 1.4;">

              No spam. Unsubscribe anytime.

            </p>

            <div id="proEmailSignupMessage" style="display: none; margin-top: 12px; padding: 12px; border-radius: 8px; text-align: center; font-size: 14px; font-weight: 500;"></div>

          </div>



        </div>

      </div>



      <!-- STEP 3: Rewrite Results (After Fix) -->

      <!-- STEP 3: False Flag Flowâ„¢ Results -->

      <div id="quickfixStep3" class="quickfix-step">

        <!-- SECTION 1: HEADER -->

        <div style="text-align: center; margin: -24px 0 32px 0;">

          <h3 style="font-size: 36px; font-weight: 700; font-family: 'Raleway', sans-serif; color: #1e3a8a; margin: 0 0 8px 0; text-align: center; letter-spacing: -0.25px;">

            Your Final Sus Score

          </h3>

          <p id="quickfixScanResultsSubtitle" style="font-size: 18px; font-weight: 400; color: #6b7280; margin: 0; text-align: center; line-height: 1.6;">

            Here's what our two-layer analysis found.

          </p>

        </div>



        <!-- BANNER CARDS FOR STEP 3 (Hella Sus, Kinda Sus, Clean) -->

        <!-- HELLA SUS CARD (70-100%) -->

        <div id="quickfixStep3HellaSusCard" class="card warning-card" style="padding: 0; overflow: visible; position: relative; display: none; margin-bottom: 20px;">

          <!-- HEADER SECTION - NEW STYLE -->

          <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #dc2626; border-right: 8px solid #dc2626;">

            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

              <div style="width: 60px; height: 60px; background: #fee2e2; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3); flex-shrink: 0;">

                <span style="font-size: 36px; line-height: 1;">ðŸš©</span>

          </div>

              <div style="text-align: center;">

                <h2 id="quickfixStep3HellaSusWarningTitle" style="font-size: 32px; font-weight: 700; margin: 0; line-height: 1; color: #ff4444;">Major Sus</h2>

                <p id="quickfixStep3HellaSusLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">AI detectors are gonna lose it - time for the full glow-up âœ¨</p>

          </div>

            </div>

          </div>

        </div>



        <!-- KINDA SUS CARD (30-69%) -->

        <div id="quickfixStep3KindaSusCard" class="card warning-card" style="padding: 0; overflow: visible; position: relative; display: none; margin-bottom: 20px;">

          <!-- HEADER SECTION - NEW STYLE -->

          <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #f5a623; border-right: 8px solid #f5a623;">

            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

              <div style="width: 60px; height: 60px; background: #fef3c7; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(245, 166, 35, 0.3); flex-shrink: 0;">

                <span style="font-size: 36px; line-height: 1;">âš ï¸</span>

              </div>

              <div style="text-align: center;">

                <h2 id="quickfixStep3KindaSusWarningTitle" style="font-size: 32px; font-weight: 700; margin: 0; line-height: 1; color: #f5a623;">Mid Sus</h2>

                <p id="quickfixStep3KindaSusLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">These sentences are lowkey cooked. Not on Lil' Sus's watch.</p>

              </div>

            </div>

          </div>

        </div>



        <!-- YOU'RE GOOD CARD (0-29%) -->

        <div id="quickfixStep3YoureGoodCard" class="card warning-card" style="padding: 0; overflow: visible; position: relative; display: none; margin-bottom: 20px; padding-bottom: 12px;">

          <!-- HEADER SECTION - NEW STYLE -->

          <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #2ecc71; border-right: 8px solid #2ecc71;">

            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

              <div style="width: 60px; height: 60px; background: #d1fae5; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(46, 204, 113, 0.3); flex-shrink: 0;">

                <span style="font-size: 36px; line-height: 1;">âœ…</span>

              </div>

              <div style="text-align: center;">

                <h2 id="quickfixStep3YoureGoodWarningTitle" style="font-size: 32px; font-weight: 700; margin: 0; line-height: 1; color: #2ecc71;">Low Sus</h2>

                <p id="quickfixStep3YoureGoodLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">No AI-trigger words detected</p>

              </div>

            </div>

          </div>

        </div>



        <!-- SECTION 3: REDESIGNED SCORE CARDS -->

        <div class="score-cards-redesigned" style="margin-bottom: 32px;">



          <!-- SCORE DISPLAY (Above Progress Bar) -->

          <div style="text-align: center; margin-bottom: 16px;">

            <div id="quickfixStep3ScoreDisplay" style="font-size: 35px; font-weight: 700; line-height: 1; margin-bottom: 4px; color: #10b981;">

              0%

            </div>

            <div id="quickfixStep3ScorePhrase" style="font-size: 16px; font-weight: 600; color: #6b7280; margin-top: 4px;">

              Low Sus

            </div>

          </div>



          <!-- PROGRESS BAR -->

          <div class="progress-container" style="margin-bottom: 24px; padding-top: 6px;">

          <div id="quickfixStep3ProgressBar" class="progress-bar">

            <div id="quickfixStep3ProgressFill" class="progress-fill"></div>

            <div id="quickfixStep3ProgressIndicator" class="progress-indicator"></div>

          </div>

          <div class="progress-endpoints">

            <span>0%</span>

            <span>50%</span>

            <span>100%</span>

          </div>

          <div class="progress-labels">

            <span>âœ… Clean</span>

            <span>âš ï¸ Mid Sus</span>

            <span>ðŸš¨ Major Sus</span>

          </div>

        </div>



          <!-- Rotating phrases for Clean No Sus Step 3 - BELOW PROGRESS BAR -->

          <!-- Clean Alert Step 3 -->

          <div id="quickfixStep3CleanNoSusRotatingPhrases" class="clean-alert" style="display: none; margin: 24px 0 16px 0;">

            <div style="background: #10b981; color: white; font-weight: 700; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">

              <span style="font-size: 20px;">âœ…</span>

              <span>Clean as a whistle!</span>

            </div>

          </div>

          <!-- Rotating phrases for Hella Sus Step 3 (same as free version) -->

          <!-- Major Red Flags Alert for Hella Sus Step 3 -->

          <div id="quickfixStep3HellaSusRotatingPhrases" class="major-red-flags-alert" style="display: none; margin: 24px 0 16px 0;">

            <div style="background: #ef4444; color: white; font-weight: 700; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">

              <span style="font-size: 20px;">âš ï¸</span>

              <span>Major red flags detected</span>

            </div>

          </div>

          <!-- Rotating phrases for Kinda Sus Step 3 (same as free version) -->

          <!-- Kinda Sus Alert Step 3 -->

          <div id="quickfixStep3KindaSusRotatingPhrases" class="kinda-sus-alert" style="display: none; margin: 24px 0 16px 0;">

            <div style="background: #f59e0b; color: white; font-weight: 700; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">

              <span style="font-size: 20px;">âš ï¸</span>

              <span>Some wording might come across as AI</span>

            </div>

          </div>



          <!-- Yellow CTA box for Kinda Sus (dynamic, below progress bar) -->

          <div id="quickfixStep3KindaSusCTA" style="display: none; background: #fafbfc; padding: 8px 16px; border-radius: 6px; margin: 12px 0; width: 100%; text-align: center;">

            <p id="quickfixStep3KindaSusCTAText" style="color: #374151; font-size: 18px; font-weight: 600; margin: 0; line-height: 1.4;">

              <span style="font-size: 20px;">âš ï¸</span> A couple lines are giving sus. Detectors might side-eye it, but we're getting there

            </p>

        </div>





          <!-- CTA BOXES FOR STEP 3 -->



          <!-- BOTTOM: Two-Column Summary Cards -->

          <div class="score-summary-cards" style="display: flex; flex-direction: column; gap: 16px; padding-top: 6px;">



            <!-- TEXT RISK Card (Matching IMAGE 3 Structure with Dynamic Coloring) -->

            <div id="textRiskCard" class="summary-card text-risk-card" style="padding: 16px; background: #f0fdf4; border: 2px solid #10b981; border-radius: 12px; width: 100%;">

              <!-- Fixed Changes Dropdown -->

              <details class="summary-dropdown" style="margin-bottom: 0;">

                <summary style="cursor: pointer; font-weight: 700; font-size: 16px; padding: 12px; background: #ffffff; border: 2px solid #e5e7eb; border-radius: 8px; user-select: none; display: flex; align-items: center; justify-content: center; gap: 8px; text-align: center; direction: ltr;">

                  <span class="dropdown-arrow" style="display: inline-block; width: 20px; text-align: center; flex-shrink: 0;">â–¼</span>

                  <span style="display: inline-block; direction: ltr; unicode-bidi: bidi-override;">AI TRIGGER WORDS FIXED (<span id="fixedCountDropdown" style="direction: ltr; unicode-bidi: embed;">0</span>)</span>

                </summary>



                <div style="padding: 16px; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; margin-top: 8px; max-height: 250px; overflow-y: auto;">

                  <ul id="fixedListDropdown" style="list-style: none; padding: 0; margin: 0; font-size: 14px; line-height: 1.8;">

                    <!-- Populated by JavaScript -->

              </ul>

            </div>

              </details>

            </div>





            </div>



            </div>



        <!-- Pro Scan Count Display (Pro users only) -->

        <div id="proStep3ScanCount" style="display: none; text-align: center; margin: 16px 0 24px 0; padding: 12px 20px; background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%); border: 2px solid #00a8e8; border-radius: 12px; max-width: 400px; margin-left: auto; margin-right: auto;">

          <div style="font-size: 14px; font-weight: 600; color: #0c4a6e; margin-bottom: 4px;">

            ðŸ“Š Monthly Scan Usage

          </div>

          <div id="proStep3ScanCountText" style="font-size: 18px; font-weight: 700; color: #003d7a;">

            <span id="proStep3ScansUsed">0</span> / 100 scans used

          </div>

          <div id="proStep3ScansRemaining" style="font-size: 12px; color: #075985; margin-top: 4px;">

            <span id="proStep3RemainingCount">100</span> remaining this month

          </div>

            </div>



        <!-- SECTION 2: OVERALL SCORE (Reuse Existing Progress Bar) -->

        <div style="text-align: center; margin: 32px 0;">

          <div id="quickfixOverallScoreDisplay" style="margin-bottom: 16px;">

            <!-- Removed 25% number - keeping only status text -->

            <!-- Removed duplicate status text below boxes - keeping only the version above green boxes -->

          </div>





            </div>



        <!-- SECTION 5: ESSAY VIEWS -->

        <div style="margin-top: 32px; padding: 20px; background: #f9fafb; border-radius: 12px; border: 2px solid #e5e7eb;">



          <!-- Toggle Buttons -->

          <div class="essay-toggle" style="display: flex; gap: 8px; margin: 24px 0; flex-wrap: wrap; justify-content: center;">

            <button class="toggle-btn active" onclick="showVersion('fixed')" 

                    style="padding: 12px 20px; border: 2px solid #003d7a; background: white; color: #003d7a; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s;">

              âœ… My Fixed Essay

            </button>

            <button class="toggle-btn" onclick="showVersion('diff')" 

                    style="padding: 12px 20px; border: 2px solid #e5e7eb; background: white; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s; color: #374151;">

              ðŸ” Show What Changed

            </button>

            <button class="toggle-btn" onclick="showVersion('original')" 

                    style="padding: 12px 20px; border: 2px solid #e5e7eb; background: white; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s; color: #374151;">

              âŒ Original (With Flags)

            </button>

          </div>



          <!-- Essay Display (Three Views) -->

          <div class="essay-display" style="margin-bottom: 24px;">



            <!-- Original Essay -->

            <div class="essay-content" id="originalEssay" style="background: white; border: 1px solid #003d7a; border-radius: 8px; padding: 20px; min-height: 240px; max-height: 600px; overflow-y: auto; overflow-x: hidden; font-family: 'Open Sans', sans-serif; font-size: 15px; font-weight: 500; line-height: 1.6; color: #1f2937; white-space: pre-wrap; width: 100%;">

              <!-- Populated by JavaScript -->

        </div>



            <!-- Fixed Essay (Main View) - DEFAULT VISIBLE -->

            <div class="essay-content active" id="fixedEssay" style="background: white; border: 1px solid #003d7a; border-radius: 8px; padding: 20px; min-height: 240px; max-height: 600px; overflow-y: auto; overflow-x: hidden; font-family: 'Open Sans', sans-serif; font-size: 15px; font-weight: 500; line-height: 1.6; color: #1f2937; white-space: pre-wrap; width: 100%;">

              <!-- Populated by JavaScript -->

            </div>



            <!-- Diff View (Side-by-side) -->

            <div class="essay-content" id="diffEssay" style="background: white; border: 1px solid #003d7a; border-radius: 8px; padding: 20px; min-height: 240px; max-height: 600px; overflow-y: auto; overflow-x: hidden; font-family: 'Open Sans', sans-serif; font-size: 15px; font-weight: 500; line-height: 1.6; color: #1f2937; white-space: pre-wrap; width: 100%;">

              <!-- Populated by JavaScript with highlights -->

          </div>

        </div>



          <!-- Copy Fixed Essay Button (only visible when "My Fixed Essay" is active) -->

          <div id="copyFixedEssayButton" style="display: block; text-align: center; margin: 16px 0; padding-bottom: 48px;">

            <button id="copyFixedEssayBtn" onclick="copyEssay()" 

                    style="width: 100%; padding: 12px 24px; font-size: 14px; font-weight: 700; background: white; color: #374151; border: 1px dashed #1e40af; border-radius: 8px; cursor: pointer; transition: all 0.2s;"

                    onmouseover="this.style.background='#f9fafb'; this.style.transform='translateY(-2px)';"

                    onmouseout="this.style.background='white'; this.style.transform='translateY(0)';">

              âš ï¸ Copy Anyway (<span id="copyRiskPercent">0</span>% risk)

            </button>

          </div>



          <!-- Score Drop Guaranteed CTA (Pro Step 3 Kinda/Hella Sus; and QuickFix Step 3 Kinda/Hella after bonus used) - DO NOT REMOVE -->

          <div id="scoreDropCTA" style="display: none; width: 100%; max-width: 42rem; margin: 24px auto; position: relative; background: linear-gradient(to bottom right, #f0fdf4, #dcfce7); border-radius: 8px; padding: 32px; border: 2px solid #4ade80; overflow: hidden; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); animation: bonusRescanPulse 1.2s ease-in-out infinite; transform-origin: center; box-sizing: border-box;">

            <div style="position: absolute; top: 0; right: 0; width: 128px; height: 128px; background: #86efac; opacity: 0.05; border-radius: 50%; filter: blur(24px);"></div>

            <div style="position: absolute; top: 16px; left: 16px; background: #22c55e; color: white; font-size: 12px; font-weight: 700; padding: 4px 12px; border-radius: 9999px;">âœ“ PROVEN</div>

            <div style="position: absolute; top: 16px; right: 16px; font-size: 36px;">ðŸŽ¯</div>

            <div style="position: relative; z-index: 10; padding-top: 16px; text-align: center;">

              <h2 style="font-size: 24px; font-weight: 700; color: #14532d; margin: 0 0 12px 0;">Score Drop Guaranteed</h2>

              <p style="color: #374151; margin: 0 0 24px 0; line-height: 1.625; font-weight: 600; font-size: 18px;">Custom fixes flopped. Your score's still cooked. Use our fixes instead. Score drop? Locked in. ðŸ”’</p>

              <button onclick="editProFixes();" 

                      style="background: #22c55e; color: white; font-weight: 700; padding: 12px 32px; border-radius: 8px; border: none; cursor: pointer; font-size: 16px; width: 100%; transition: all 0.2s; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);"

                      onmouseover="this.style.background='#16a34a'; this.style.transform='scale(1.02)';"

                      onmouseout="this.style.background='#22c55e'; this.style.transform='scale(1)';">

                Apply Our Fixes Now

              </button>

            </div>

          </div>



          <!-- Bonus Rescan CTA (QuickFix Step 3 Hella Sus / Kinda Sus ONLY; hidden on return after use; Unlock sends to QuickFix Step 2, NOT Pro) -->

          <div id="bonusRescanCTA" style="display: none; position: relative; background: #f0fdf4; border: 2px solid #4ade80; border-radius: 8px; padding: 24px; margin: 24px 0; text-align: center; animation: bonusRescanPulse 1.2s ease-in-out infinite; transform-origin: center; box-sizing: border-box;">

            <div style="position: absolute; top: 12px; right: 12px; background: #22c55e; color: white; font-weight: 700; font-size: 12px; padding: 4px 12px; border-radius: 9999px;">ðŸŽ BONUS</div>

            <div style="position: absolute; bottom: 16px; right: 16px; font-size: 36px; animation: bounce 1s ease-in-out infinite;">ðŸ‘</div>

            <div style="padding-right: 48px; text-align: center;">

              <h3 style="font-size: 24px; font-weight: 700; color: #1e3a8a; margin: 0 0 8px 0;">âš¡ Bonus Fix + Rescan</h3>

              <p style="color: #374151; margin: 0 0 16px 0; font-size: 16px; line-height: 1.5;">Your score's still sus. Use our fixes instead? You get a guaranteed score drop + bonus rescan.</p>

              <button id="bonusRescanUnlockBtn" onclick="goBackToQuickFixStep2FromBonusRescan();" 

                      style="background: #22c55e; color: white; font-weight: 700; padding: 12px 24px; border-radius: 8px; border: none; cursor: pointer; font-size: 16px; width: 100%; transition: all 0.2s;"

                      onmouseover="this.style.background='#16a34a';"

                      onmouseout="this.style.background='#22c55e';">

                ðŸ”“ Unlock Bonus Rescan

              </button>

            </div>

          </div>



          <!-- Clean No Sus CTA box (light green) -->

          <div id="quickfixStep3CleanNoSusCTA" style="display: none; background: #f0fdf4; border: 2px solid #10b981; padding: 24px 24px; border-radius: 10px; margin: 24px 0; width: 100%; padding-top: 48px; padding-bottom: 48px; box-shadow: 0 0 25px rgba(16, 185, 129, 0.35), 0 0 50px rgba(16, 185, 129, 0.15), 0 0 75px rgba(16, 185, 129, 0.08);">

            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px;">

              <img class="false-flag-stamp-glow" src="https://i.postimg.cc/7LdkDfxL/false-flag-stamp.png" alt="False Flag Fixed Stamp" style="width: 260px; height: auto; display: block; margin: 0 auto;">

              <p id="quickfixStep3CleanNoSusCTAText" style="color: #1e3a5f !important; font-size: 20px; font-weight: 700; margin: 0; line-height: 1.4; text-align: center;">

                Vibe check passed âœ…<br>

                No cap, it's lookin' way cleaner! ðŸŽ‰

                </p>

            </div>

            </div>



          <!-- Hidden textarea for internal copying -->

          <textarea id="quickfixFixedTextForCopy" style="display: none;"></textarea>



        </div>





        <!-- SECTION 9: ACTION BUTTONS - Orange "Get Another QuickFix" shown ONLY for Kinda Sus / Hella Sus (score >= 30); hidden for Pro, Free, QuickFix Clean -->

        <div style="text-align: center; margin: 32px 0; display: flex; flex-direction: column; gap: 12px;">

          <button id="step3QuickFixUpsellButton" onclick="showGetAnotherQuickFixModal();" 

                  style="display: none; padding: 12px 24px; font-size: 14px; font-weight: 700; background: #ff6b00; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; align-items: center; justify-content: center; gap: 8px;"

                  onmouseover="this.style.background='#e55a00'; this.style.transform='translateY(-2px)';"

                  onmouseout="this.style.background='#ff6b00'; this.style.transform='translateY(0)';">

            <span>âš¡</span><span>Get Another QuickFix - $1.99</span>

          </button>

        </div>



        <!-- Pro Step 3 CTAs - REORDERED: 1. Paste & Scan, 2. Try Different Words, 3. View Past Fixes, 4. Back to Main Dashboard -->

        <div style="text-align: center; margin-top: 20px;">

          <button id="step3BackToProDashboard" class="btn-outline" onclick="backToProDashboard()" style="background: white; border: 1px solid #00a8e8; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 600; color: #00a8e8; cursor: pointer; width: 100%; display: none;">

            ðŸ’Ž Paste & Scan Another Essay

          </button>

          <button id="step3EditFixes" class="btn-outline" onclick="editProFixes()" style="background: white; border: 1px solid #f5a623; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 600; color: #f5a623; cursor: pointer; width: 100%; display: none; margin-top: 12px;">

            â† Try Different Words

          </button>

          <button id="step3ViewPastFixes" class="btn-outline" onclick="if(typeof showProPastFixes==='function'){showProPastFixes();}else{console.error('showProPastFixes not found');alert('View Past Fixes feature is loading. Please try again in a moment.');}" style="background: white; border: 1px solid #2ecc71; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 600; color: #2ecc71; cursor: pointer; width: 100%; display: none; margin-top: 12px;">

            ðŸ“Š View Past Fixes

          </button>

          <button id="step3BackToMainDashboardButton" onclick="goBack()" 

                  style="padding: 12px 24px; margin-top: 12px; font-size: 14px; font-weight: 600; background: white; border: 1px dashed #0b0646 !important; border-radius: 8px; color: #0b0646; cursor: pointer; transition: all 0.2s; width: 100%; display: none;"

                  onmouseover="this.style.background='#f9fafb'; this.style.borderColor='#0b0646'; this.style.color='#0b0646';"

                  onmouseout="this.style.background='white'; this.style.borderColor='#0b0646'; this.style.color='#0b0646';">

            ðŸ  Back To Main Dashboard

          </button>

        </div>



        <!-- Pro Banner for Step 3 (Summary Page) - Positioned at bottom -->

        <div id="quickfixStep3ProBanner" style="display: none; background: linear-gradient(to bottom, #00a8e8, #0b0646); border-radius: 16px; padding: 20px 16px; margin: 48px 0 0 0; text-align: center; box-shadow: 0 4px 12px rgba(0, 168, 232, 0.2);">

          <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">

            <span style="font-size: 24px;">ðŸš€</span>

            <h3 style="color: white; font-size: 20px; font-weight: 700; margin: 0;">Go Pro & Chill...</h3>

          </div>

          <p id="step3ProBenefitsText" style="text-align: center; color: white; font-size: 14px; margin: 0 0 8px 0; line-height: 1.6; opacity: 0.95;">

            100 scans and fixes/month â€¢ Deeper AI fixes powered by Claude Haiku â€¢ Priority chat support â€¢ Cancel anytime

          </p>

          <p style="text-align: center; color: white; font-size: 14px; margin: 0 0 16px 0; line-height: 1.6; opacity: 0.95;">

            <strong>Fix the AI flags before the AI flags you.</strong>

          </p>

          <button onclick="showProUpsell()" style="background: white; color: #00a8e8; border: 1px solid #00a8e8; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); transition: transform 0.2s; margin-bottom: 8px; width: 100%;">

            â†’ Get Pro - $9.99/mo

          </button>

          <div style="text-align: center; color: white; font-size: 10px; opacity: 0.9;">

            Cancel Anytime

          </div>

        </div>



        <!-- Email Signup Form for All Users (QuickFix & Pro) - Step 3 -->

        <div id="quickfixStep3EmailSignupForm" style="display: none; margin-top: 48px; padding: 32px 24px; background: #f8f9fa; border: 1px solid #e5e7eb; border-radius: 12px; width: 100%;">

          <div style="text-align: center; margin-bottom: 12px;">

            <img src="https://i.postimg.cc/nhnTZ7c9/LS-BLUE-CIRCLE.png" alt="Lil Sus" style="width: 80px; height: auto; display: block; margin: 0 auto;">

          </div>

          <h3 style="font-size: 20px; font-weight: 700; color: #1e3a8a; margin: 0 0 8px 0; text-align: center;">

            Get the Deets. Better Safe than Sus.

          </h3>

          <p style="font-size: 14px; color: #6b7280; margin: 0 0 20px 0; text-align: center; line-height: 1.5;">

            Get updates on our Chrome extension, mobile app, and new features coming soon.

          </p>

          <form id="quickfixStep3EmailSignupFormElement" onsubmit="handleEmailSignup(event)" style="display: flex; flex-direction: column; gap: 12px;">

            <input 

              type="email" 

              id="quickfixStep3EmailInput" 

              placeholder="Enter your email address" 

              required

              style="padding: 12px 16px; width: 100%; border: 1px solid #d1d5db; border-radius: 8px; font-size: 14px; font-family: inherit; color: #374151; background: white; transition: border-color 0.2s; box-sizing: border-box;"

              onfocus="this.style.borderColor='#00a8e8'; this.style.outline='none';"

              onblur="this.style.borderColor='#d1d5db';"

            >

            <button 

              type="submit" 

              id="quickfixStep3EmailSubmitBtn"

              style="padding: 12px 24px; width: 100%; background: #1e3a5f; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;"

              onmouseover="this.style.background='#2c5282'; this.style.transform='translateY(-1px)';"

              onmouseout="this.style.background='#1e3a5f'; this.style.transform='translateY(0)';"

            >

              Subscribe

            </button>

          </form>

          <p style="font-size: 11px; color: #9ca3af; margin: 8px 0 0 0; text-align: center; line-height: 1.4;">

            No spam. Unsubscribe anytime.

          </p>

          <div id="quickfixStep3EmailSignupMessage" style="display: none; margin-top: 12px; padding: 12px; border-radius: 8px; text-align: center; font-size: 14px; font-weight: 500;"></div>

        </div>



        </div>



        <!-- RESPONSIVE CSS FOR MOBILE + DIFF VIEW STYLES -->

        <style>

          /* Diff view highlighting styles */

          .flag-removed {

            text-decoration: line-through;

            color: #9ca3af;

            background: #fee2e2;

          }

          .flag-fixed {

            background: #d1fae5;

            color: #10b981;

            padding: 2px 4px;

            border-radius: 2px;

            font-weight: 600;

          }



          /* Collapsible dropdown styling */

          .summary-dropdown {

            margin-bottom: 16px;

          }



          /* Style the dropdown arrow animation - only rotate the arrow */

          .summary-dropdown[open] > summary .dropdown-arrow {

            transform: rotate(180deg);

          }



          .summary-dropdown > summary .dropdown-arrow {

            display: inline-block;

            transition: transform 0.2s ease;

            flex-shrink: 0;

            width: 20px;

            text-align: center;

          }



          /* Ensure the count number and text don't get affected by transforms */

          .summary-dropdown summary span:not(.dropdown-arrow) {

            display: inline-block;

            transform: none !important;

            direction: ltr !important;

          }



          .summary-dropdown summary #fixedCountDropdown,

          .summary-dropdown summary #flaggedCountDropdown {

            direction: ltr !important;

            unicode-bidi: embed !important;

            display: inline !important;

          }



          /* Smooth opening animation */

          .summary-dropdown > div {

            animation: slideDown 0.3s ease-out;

          }



          @keyframes slideDown {

            from {

              opacity: 0;

              transform: translateY(-10px);

            }

            to {

              opacity: 1;

              transform: translateY(0);

            }

          }



          @media (max-width: 768px) {

            .score-summary-cards {

              grid-template-columns: 1fr !important;

            }



            .score-display-top {

              flex-direction: column !important;

              gap: 12px !important;

            }



            .score-display-top .score-divider {

              display: none !important;

            }

          }



          @media (max-width: 640px) {

            #quickfixTwoScoreCards {

              grid-template-columns: 1fr !important;

              gap: 16px !important;

            }

            #quickfixFixedTextArea {

              min-height: 240px !important;

              max-height: 400px !important;

              font-size: 13px !important;

            }

            #quickfixStep3 button {

              width: 100% !important;

              margin-bottom: 8px;

            }

            .essay-toggle {

              flex-direction: column !important;

            }

            .toggle-btn {

              width: 100% !important;

            }

            #quickfixStep3 .progress-container {

              margin: 16px 0 !important;

            }

            #quickfixOverallScoreNumber {

              font-size: 48px !important;

            }

            #quickfixStep3 h3 {

              font-size: 24px !important;

            }

            #quickfixStep3 h4 {

              font-size: 18px !important;

            }

          }

        </style>



      <!-- STEP 4: Pro-Level Scan Results - Found ALL Flags! -->

      <div id="quickfixStep4" class="quickfix-step">

        <div class="container">

          <!-- Pro Member Exclusive Badge -->

          <div style="text-align: center; margin-bottom: 20px;">

            <div style="display: inline-block; background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%); color: white; padding: 8px 20px; border-radius: 20px; font-size: 13px; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3);">

              âœ¨ Pro Member Exclusive

            </div>

          </div>



          <!-- Hero Header -->

          <div class="hero-header">

            <div id="rotatingMessage" class="rotating-message">ðŸ’Ž Premium Results - Every Flag Found & Fixed âœ¨</div>

            <p id="step4HeroText">Pro found 3 flags. Pro scan found 12 more! All AI-trigger words now fixed.<br>Ready to TURN IT IN.</p>

          </div>



          <!-- Big Score Display -->

          <div id="bigScoreDisplay" style="

            background: linear-gradient(135deg, #f0fdfa 0%, #ccfbf1 100%);

            border: 3px solid #14b8a6;

            border-radius: 20px;

            padding: 30px;

            margin: 30px 0;

            text-align: center;

            box-shadow: 0 8px 25px rgba(20, 184, 166, 0.3);

            position: relative;

            overflow: hidden;

          ">



            <div style="font-size: 48px; margin-bottom: 15px;">ðŸŽ‰</div>

            <h2 style="color: #1e3a8a; margin-bottom: 20px; font-size: 28px; font-weight: 700;">

              Pro Scan Complete!

            </h2>

            <div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 15px;">

              <div style="text-align: center;">

                <div style="font-size: 36px; font-weight: 700; color: #dc2626;" id="bigScoreBefore">78%</div>

                <div style="font-size: 14px; color: #6b7280; font-weight: 600;">BEFORE</div>

              </div>

              <div style="font-size: 24px; color: #14b8a6;">â†’</div>

              <div style="text-align: center;">

                <div style="font-size: 36px; font-weight: 700; color: #14b8a6;" id="bigScoreAfter">12%</div>

                <div style="font-size: 14px; color: #6b7280; font-weight: 600;">AFTER</div>

              </div>

            </div>

            <div style="font-size: 18px; color: #0b0646; font-weight: 600;" id="bigScoreImprovement">

              ðŸš€ 66% Score Drop!

            </div>

          </div>



          <!-- Comparison Stats -->

          <div class="stats-grid">

            <div class="stat-card blue">

              <span class="stat-number" id="proFlags">0</span>

              <span class="stat-label">Pro Flags Found</span>

            </div>

            <div class="stat-card green">

              <span class="stat-number" id="quickfixFlags">3</span>

              <span class="stat-label">Flags Fixed</span>

            </div>

            <div class="stat-card orange">

              <span class="stat-number" id="scoreDrop">58%</span>

              <span class="stat-label">SUS Score Drop</span>

            </div>

            <div class="stat-card red">

              <span class="stat-number">0</span>

              <span class="stat-label">Red Flags Left</span>

            </div>

          </div>



          <!-- Pro-Level Detection Explanation -->

          <div style="background: linear-gradient(135deg, #f0fdfa 0%, #ccfbf1 100%); border-radius: 12px; padding: 20px; margin: 20px 0; text-align: center; border-left: 4px solid #14b8a6; border-right: 4px solid #14b8a6; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.15);">

            <h3 style="color: #0f766e; margin: 0 0 12px; font-size: 18px; font-weight: 700;">ðŸ’Ž Premium Detection - This is What You Get</h3>

            <p style="color: #134e4a; margin: 0; font-size: 14px; line-height: 1.5; font-weight: 500;">

              Comprehensive flag detection that finds every single AI-trigger word. 

              <span id="step4ProText">Pro found all AI-trigger words in your essay and fixed them all!</span>

            </p>

          </div>



          <!-- Score Transformation -->

          <div class="score-transformation">

            <div class="score-comparison">

              <span class="score-badge score-before">Was: <span id="scoreBefore">75%</span> <span id="scoreBeforeLabel">Major Sus</span> ðŸš©</span>

              <span class="score-arrow">â†’</span>

              <span class="score-badge score-after">Now: <span id="scoreAfter">17%</span> <span id="scoreAfterLabel">Low Sus</span> âœ…</span>

            </div>



            <div class="sus-meter">

              <div class="meter-labels">

                <span>âœ… Low Sus</span>

                <span>âš ï¸ Mid Sus</span>

                <span>ðŸš¨ Major Sus</span>

              </div>

              <div class="meter-bar">

                <div class="meter-fill" id="meterFill" style="width: 17%;">

                  <span>17%</span>

                </div>

              </div>

              <p class="meter-message">âœ… Ready to Turn In</p>

            </div>



            <!-- Stats Banner -->

            <div class="stats-banner">

              <div class="stat-item">

                <span class="stat-value" id="flagsFixedCount">3</span>

                <span class="stat-text">Flags Fixed</span>

              </div>

              <div class="stat-item">

                <span class="stat-value" id="scoreImprovement">58%</span>

                <span class="stat-text">Score Dropped</span>

              </div>

              <div class="stat-item">

                <span class="stat-value" id="aiTriggerFreeScore">100%</span>

                <span class="stat-text">AI Trigger Free</span>

              </div>

            </div>

          </div>



          <!-- Essay Viewer with Toggle -->

          <div class="essay-viewer">

            <div class="viewer-header" style="justify-content: center; align-items: center; flex-direction: column;">

              <h2 class="viewer-title">Before â†’ After</h2>

              <div style="display: flex; gap: 16px; justify-content: center;">

                <button class="toggle-btn" onclick="showVersion('original')">âŒ Original</button>

                <button class="toggle-btn active" onclick="showVersion('rewrite')">âœ… My Pro-Fixed Essay</button>

                <button class="toggle-btn" onclick="showVersion('diff')">ðŸ” Show Fixes</button>

              </div>

            </div>



            <div class="essay-display">

              <!-- Original Essay -->

              <div class="essay-content" id="originalEssay">

                <p>The cutting-edge technology landscape demonstrates unprecedented levels of innovation. Furthermore, organizations must leverage their resources to achieve significant competitive advantages in the marketplace. Thus, it is important to note that comprehensive analysis reveals multifaceted approaches to problem-solving.</p>

                <p>Moreover, the data suggests that various industries are experiencing considerable transformation. Consequently, stakeholders must utilize state-of-the-art methodologies to navigate these changes effectively.</p>

              </div>



              <!-- Pro-Fixed Essay -->

              <div class="essay-content active" id="rewriteEssay">

                <p>Modern tech shows incredible innovation. Companies need to use their resources smartly to stay ahead. A closer look shows there are many ways to solve problems.</p>

                <p>Also, evidence shows that different industries are changing fast. Decision-makers should use modern methods to handle these shifts well.</p>

              </div>



              <!-- Diff View -->

              <div class="essay-content" id="diffEssay">

                <p>The <span class="flag-removed">cutting-edge</span> <span class="flag-fixed">modern</span> <span class="flag-removed">technology</span> <span class="flag-fixed">tech</span> landscape <span class="flag-removed">demonstrates unprecedented levels</span> <span class="flag-fixed">shows incredible</span> of innovation. <span class="flag-removed">Furthermore</span> <span class="flag-fixed">Also</span>, organizations must <span class="flag-removed">leverage</span> <span class="flag-fixed">use</span> their resources to achieve <span class="flag-removed">significant</span> competitive advantages in the marketplace.</p>

                <p><span class="flag-removed">Moreover</span> <span class="flag-fixed">Also</span>, the data suggests that <span class="flag-removed">various</span> <span class="flag-fixed">different</span> industries are experiencing <span class="flag-removed">considerable</span> <span class="flag-fixed">big</span> transformation.</p>

              </div>

            </div>

          </div>



          <!-- Primary Action Buttons -->

          <div class="action-buttons">

            <button class="btn btn-success" onclick="copyFullDeFlag()" style="background: #14b8a6 !important; border-color: #14b8a6 !important; color: white !important; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3) !important;">

              ðŸ“‹ Copy My Fixed Essay

            </button>

            <button class="btn btn-primary" onclick="downloadDocx()" style="background: #14b8a6 !important; border-color: #14b8a6 !important; color: white !important; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3) !important;">

              â¬‡ï¸ Download as .docx

            </button>

            <button class="btn btn-warning" onclick="openStep4FlagsModal()" style="background: #14b8a6 !important; border-color: #14b8a6 !important; color: white !important; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3) !important;">

              ðŸš© See All <span id="flagCount">12</span> Fixes

            </button>

          </div>



          <!-- Ethical Disclaimer -->

          <div style="text-align: center; margin-top: 20px; padding: 10px;">

            <p style="font-size: 11px; color: #9ca3af; line-height: 1.4; margin: 0;">

              This tool helps protect legitimate work from false AI detection. 

              Use responsibly and ensure your work meets your institution's academic integrity policies.

            </p>

          </div>



          <!-- Footer -->

          <div class="lil-sus-footer" style="background: linear-gradient(135deg, #f0fdfa 0%, #ccfbf1 100%); border: 2px solid #14b8a6; border-radius: 16px; padding: 30px; margin: 30px 0; box-shadow: 0 8px 25px rgba(20, 184, 166, 0.2);">

            <div class="footer-icon" style="font-size: 32px; margin-bottom: 15px;">ðŸ’Žâœ¨ðŸ”¥</div>

            <h4 class="footer-title" style="color: #0f766e; font-size: 24px; font-weight: 700; margin-bottom: 12px;">You've Earned This! ðŸŽ¯</h4>

            <p class="footer-text" style="color: #134e4a; font-size: 16px; font-weight: 600; margin: 8px 0;">AI-proof. Professor-ready. Turn-in approved.</p>

            <p class="footer-text" style="color: #134e4a; font-size: 15px; margin: 8px 0;">Your essay is polished and perfect. Time to shine! âœ¨</p>

            <p class="footer-cta" style="color: #14b8a6; font-size: 20px; font-weight: 800; margin-top: 20px; letter-spacing: 1px;">Go Ahead â€” Turn ðŸ‘ It ðŸ‘ In ðŸ‘</p>

          </div>



          <!-- Return To Dashboard Link -->

          <div style="text-align: center; margin-top: 30px; padding: 20px;">

            <button id="step4BackToDashboard" class="btn-outline" onclick="hideQuickFixFlow()" style="padding: 15px 30px; font-size: 16px; display: none; border: 1px dashed #0b0646 !important; color: #0b0646;">

              ðŸ  Back To Main Dashboard

            </button>

            <button id="step4BackToProDashboard" class="btn-outline" onclick="backToProDashboard()" style="padding: 15px 30px; font-size: 16px; background: white !important; border: 2px solid #14b8a6 !important; color: #14b8a6 !important; border-radius: 8px; font-weight: 600; cursor: pointer; display: none; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.2) !important;">

              ðŸ’Ž BACK TO PRO DASHBOARD

            </button>

          </div>



          <!-- Disclaimer -->

          <div style="text-align: center; margin-top: 20px; padding: 10px;">

            <p style="font-size: 11px; color: #9ca3af; line-height: 1.4; margin: 0;">

              This AI tool assists with writing improvement but cannot guarantee academic outcomes. Users are responsible for ensuring their work meets institutional standards and policies.

            </p>

          </div>

        </div>



        <!-- Flags Modal -->

        <div class="modal" id="step4FlagsModal">

          <div class="modal-content">

            <div class="modal-header">

              <button class="modal-close" onclick="closeStep4FlagsModal()" onmouseover="this.style.color='#dc2626'; this.style.background='#fee2e2';" onmouseout="this.style.color='#999'; this.style.background='none';">Ã—</button>

              <h3 style="font-size: 1.5em; margin-bottom: 8px;">ðŸ”¥ I Found & Fixed <span id="modalFlagCount">12</span> AI Triggers</h3>

            </div>



            <div class="modal-body" id="step4FlagsList">

              <!-- Flags will be inserted here -->

            </div>



            <div class="modal-footer">

              <button class="btn btn-primary" style="flex: 1; background: #14b8a6; border-color: #14b8a6; color: white; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3);" onclick="copyStep4FlagsList()">ðŸ“‹ Copy This List</button>

              <button class="btn btn-success" style="flex: 1; background: #14b8a6; border-color: #14b8a6; color: white; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3);" onclick="closeStep4FlagsModal()">Got It âœ…</button>

            </div>

          </div>

        </div>



        <!-- Rescan Comparison Modal (Pro and QuickFix only) -->

        <div id="rescanComparisonModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 10000; backdrop-filter: blur(4px); animation: fadeIn 0.3s ease;">

          <div style="position: absolute; top: 50%; left: 50%; background: white; border-radius: 16px; padding: 32px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); animation: modalSlideUp 0.4s ease;">

            <!-- Close Button -->

            <button onclick="closeRescanComparisonModal()" style="position: absolute; top: 16px; right: 16px; background: none; border: none; font-size: 28px; color: #6b7280; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.2s;" onmouseover="this.style.background='#f3f4f6'; this.style.color='#374151';" onmouseout="this.style.background='none'; this.style.color='#6b7280';">Ã—</button>



            <!-- Header -->

            <div style="text-align: center; margin-bottom: 24px;">

              <div style="font-size: 48px; margin-bottom: 12px; animation: spin 1s ease;">ðŸ”„</div>

              <h2 id="rescanModalTitle" style="font-size: 28px; font-weight: 700; color: #1f2937; margin: 0 0 8px 0;">Rescan Complete!</h2>

            </div>



            <!-- Before/After Score Comparison -->

            <div style="display: flex; gap: 16px; margin-bottom: 24px; justify-content: center;">

              <!-- Before Score Card -->

              <div id="rescanBeforeCard" style="flex: 1; background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 12px; padding: 20px; text-align: center; min-width: 140px;">

                <div style="font-size: 12px; font-weight: 600; color: #6b7280; letter-spacing: 0.5px; margin-bottom: 8px;">Before</div>

                <div id="rescanBeforeScore" style="font-size: 36px; font-weight: 700; color: #374151; margin-bottom: 4px;">0%</div>

                <div id="rescanBeforeStatus" style="font-size: 14px; font-weight: 600; color: #6b7280;">-</div>

              </div>



              <!-- Arrow -->

              <div style="display: flex; align-items: center; justify-content: center; padding: 0 8px;">

                <div id="rescanArrow" style="font-size: 32px; color: #6b7280;">â†’</div>

              </div>



              <!-- After Score Card -->

              <div id="rescanAfterCard" style="flex: 1; background: #f0fdf4; border: 2px solid #10b981; border-radius: 12px; padding: 20px; text-align: center; min-width: 140px;">

                <div style="font-size: 12px; font-weight: 600; color: #6b7280; letter-spacing: 0.5px; margin-bottom: 8px;">After</div>

                <div id="rescanAfterScore" style="font-size: 36px; font-weight: 700; color: #10b981; margin-bottom: 4px;">0%</div>

                <div id="rescanAfterStatus" style="font-size: 14px; font-weight: 600; color: #10b981;">-</div>

              </div>

            </div>



            <!-- Score Change Indicator -->

            <div id="rescanChangeIndicator" style="text-align: center; margin-bottom: 24px; padding: 16px; border-radius: 8px; background: #f0fdf4;">

              <div id="rescanChangeText" style="font-size: 18px; font-weight: 600; color: #059669; margin-bottom: 4px;">-</div>

              <div id="rescanChangeMessage" style="font-size: 14px; color: #047857; line-height: 1.5;">-</div>

            </div>



            <!-- Action Buttons -->

            <div style="display: flex; flex-direction: column; gap: 12px;">

              <button id="rescanModalViewResultsBtn" onclick="closeRescanComparisonModal()" style="width: 100%; padding: 14px 24px; font-size: 16px; font-weight: 700; background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#0099d4'; this.style.transform='translateY(-2px)';" onmouseout="this.style.background='#00a8e8'; this.style.transform='translateY(0)';">

                âœ… View Full Results

              </button>

              <button id="rescanModalEditMoreBtn" onclick="closeRescanComparisonModalAndFocusEdit()" style="width: 100%; padding: 14px 24px; font-size: 16px; font-weight: 700; background: white; color: #00a8e8; border: 2px solid #00a8e8; border-radius: 8px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f0f9ff'; this.style.transform='translateY(-2px)';" onmouseout="this.style.background='white'; this.style.transform='translateY(0)';">

                âœï¸ Edit More & Rescan

              </button>

              <button id="rescanModalCopyBtn" onclick="copyEssayFromModal()" style="width: 100%; padding: 14px 24px; font-size: 16px; font-weight: 700; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; display: none;" onmouseover="this.style.background='#059669'; this.style.transform='translateY(-2px)';" onmouseout="this.style.background='#10b981'; this.style.transform='translateY(0)';">

                ðŸ“‹ Copy My Essay

              </button>

            </div>

          </div>

        </div>



        <!-- Success Toast -->

        <div class="success-toast" id="step4SuccessToast">

          âœ… Copied to clipboard!

        </div>

      </div>

    </div>

  </div>

</div>



<!-- STEP 6: Pro Dashboard - COMPLETELY REDESIGNED -->

<div id="quickfixStep6" class="quickfix-step">

  <!-- HERO SECTION -->

  <div class="hero-section">

    <div style="text-align: center; margin-bottom: 12px;">

      <img src="https://i.postimg.cc/hPKB2kRp/Final-site-icon-trans.png" alt="False Flag Fixer Logo" style="width: 75px; height: 75px; display: block; margin: 0 auto; animation: slowRotate 7s linear infinite;">

    </div>

    <h1 class="hero-title">False Flag Fixerâ„¢ - Pro ðŸ’Ž</h1>

    <p class="hero-subtitle" style="padding-bottom: 48px;">

      <span style="font-size: 1.4em; font-weight: 600;">100 Scans A Month. No Daily Limit. Unlimited Peace of Mind.</span>

    </p>

  </div>



  <style>

    #quickfixStep6 * {

      margin: 0;

      padding: 0;

      box-sizing: border-box;

    }



    #quickfixStep6 {

      background: linear-gradient(135deg, #0b0646 0%, #1a1f6e 100%);

      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;

      min-height: 100vh;

      padding: 20px 20px 40px 20px;

    }



    #quickfixStep6 .hero-section {

      text-align: center;

      padding: 20px 20px 20px;

      color: #fff;

      width: 100%;

      box-sizing: border-box;

      display: flex;

      flex-direction: column;

      align-items: center;

      justify-content: flex-start;

      margin-bottom: 0;

    }



    /* Hero section styles within Pro dashboard */

    #quickfixStep6 .hero-section {

      text-align: center;

      padding: 10px 20px 20px;

      color: #fff;

      width: 100%;

      box-sizing: border-box;

      display: flex;

      flex-direction: column;

      align-items: center;

      justify-content: flex-start;

      margin-bottom: 0;

    }



    #quickfixStep6 .hero-title {

      font-size: clamp(2em, 5vw, 3em);

      font-weight: 700;

      font-family: 'Raleway', sans-serif;

      margin: 0 0 8px;

      line-height: 1.1;

      color: #fff;

      text-shadow: 2px 2px 4px rgba(0,0,0,.2);

      text-align: center;

      width: 100%;

      letter-spacing: -0.25px;

    }



    /* Hero section styles within Pro dashboard */

    #quickfixStep6 .hero-section {

      text-align: center;

      padding: 10px 20px 20px;

      color: #fff;

      width: 100%;

      box-sizing: border-box;

      display: flex;

      flex-direction: column;

      align-items: center;

      justify-content: flex-start;

      margin-bottom: 0;

    }



    #quickfixStep6 .hero-title {

      font-size: clamp(2em, 5vw, 3em);

      font-weight: 700;

      font-family: 'Raleway', sans-serif;

      margin: 0 0 12px;

      line-height: 1.1;

      color: #fff;

      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);

      text-align: center;

      width: 100%;

      letter-spacing: -0.25px;

    }



    #quickfixStep6 .hero-subtitle {

      font-size: clamp(1em, 2.5vw, 1.2em);

      margin: 0 auto !important;

      opacity: .95;

      max-width: 100%;

      text-align: center !important;

      width: 100%;

      display: block;

      box-sizing: border-box;

      line-height: 1.4;

      color: #fff;

      position: relative;

      left: 0 !important;

      right: 0 !important;

      transform: translateX(0) !important;

      align-self: center;

    }



    #quickfixStep6 .container {

      max-width: 1000px;

      margin: 0 auto;

      padding: 0;

    }



    #quickfixStep6 .modal-card {

      background: white;

      border-radius: 20px;

      overflow: hidden;

      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);

      max-width: 1000px;

      margin: 0 auto;

      margin-top: 0;

    }



    #quickfixStep6 .header-banner {

      background: linear-gradient(135deg, #00a8e8 0%, #0077b6 100%);

      border-radius: 16px;

      border: 1px solid rgba(255, 255, 255, 0.2);

      height: auto;

      min-height: 80px;

      position: relative;

      overflow: visible;

      display: flex;

      align-items: center;

      justify-content: space-between;

      padding: 16px 24px;

      margin-bottom: 24px;

      z-index: 1;

    }



    #quickfixStep6 .header-banner::before {

      content: '';

      position: absolute;

      top: 0;

      left: 0;

      right: 0;

      bottom: 0;

      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 200"><defs><pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse"><path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"/></pattern></defs><rect width="1200" height="200" fill="url(%23grid)"/></svg>');

      opacity: 0.3;

      pointer-events: none;

      z-index: 0;

    }



    #quickfixStep6 .settings-icon {

      position: relative;

      z-index: 10;

      pointer-events: auto;

    }



    #quickfixStep6 .header-content {

      position: relative;

      z-index: 2;

      text-align: center;

      color: white;

    }



    #quickfixStep6 .header-title {

      font-size: 32px;

      font-weight: 700;

      display: flex;

      align-items: center;

      justify-content: center;

      gap: 12px;

    }



    #quickfixStep6 .header-subtitle {

      font-size: 14px;

      opacity: 0.95;

      margin-top: 6px;

      text-align: center !important;

      width: 100%;

    }



    #quickfixStep6 .gauge-widget {

      position: absolute;

      top: 16px;

      left: 16px;

      background: rgba(255, 255, 255, 0.95);

      border-radius: 12px;

      padding: 12px;

      width: 100px;

      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);

    }



    #quickfixStep6 .mini-ring {

      width: 70px;

      height: 70px;

      position: relative;

      margin: 0 auto 8px;

    }



    #quickfixStep6 .mini-ring svg {

      width: 100%;

      height: 100%;

      transform: rotate(-90deg);

    }



    #quickfixStep6 .ring-bg {

      fill: none;

      stroke: #e8e8e8;

      stroke-width: 4;

    }



    #quickfixStep6 .ring-prog {

      fill: none;

      stroke: #00a8e8;

      stroke-width: 4;

      stroke-linecap: round;

      stroke-dasharray: 188;

      stroke-dashoffset: 169;

      animation: fillRing 2s ease-out forwards;

    }



    @keyframes fillRing {

      from {

        stroke-dashoffset: 188;

      }

      to {

        stroke-dashoffset: 169;

      }

    }



    #quickfixStep6 .ring-center {

      position: absolute;

      top: 50%;

      left: 50%;

      transform: translate(-50%, -50%);

      text-align: center;

    }



    #quickfixStep6 .ring-num {

      font-size: 18px;

      font-weight: 700;

      color: #00a8e8;

    }



    #quickfixStep6 .ring-lbl {

      font-size: 9px;

      color: #999;

      font-weight: 600;

    }



    #quickfixStep6 .gauge-text {

      text-align: center;

      font-size: 11px;

      color: #666;

      font-weight: 600;

    }



    #quickfixStep6 .content-section {

      padding: 40px;

      text-align: left;

    }



    #quickfixStep6 .status-badge {

      display: inline-block;

      background: #e8f5f9;

      color: #00a8e8;

      padding: 6px 12px;

      border-radius: 16px;

      font-size: 11px;

      font-weight: 700;

      letter-spacing: 0.5px;

      margin-bottom: 16px;

    }



    #quickfixStep6 .status-title {

      font-size: 24px;

      font-weight: 700;

      color: #333;

      margin-bottom: 8px;

    }



    #quickfixStep6 .status-subtitle {

      font-size: 14px;

      color: #666;

      margin-bottom: 32px;

    }



    #quickfixStep6 .input-section {

      margin-bottom: 24px;

    }



    #quickfixStep6 .textarea {

      width: 100%;

      min-height: 180px;

      padding: 16px;

      border: 2px solid #e8e8e8;

      border-radius: 12px;

      font-family: inherit;

      font-size: 14px;

      resize: vertical;

      transition: all 0.2s;

    }



    #quickfixStep6 .textarea:focus {

      outline: none;

      border-color: #00a8e8;

      box-shadow: 0 0 0 3px rgba(0, 168, 232, 0.1);

    }



    #quickfixStep6 textarea:focus {

      outline: none;

      border-color: #00a8e8;

      box-shadow: 0 0 0 3px rgba(0, 168, 232, 0.1);

    }



    #quickfixStep6 .char-count {

      text-align: right;

      font-size: 12px;

      color: #999;

      margin-top: 8px;

      margin-bottom: 20px;

    }



    #quickfixStep6 .scan-button {

      width: 100%;

      background: linear-gradient(135deg, #00a8e8 0%, #0077b6 100%);

      color: white;

      border: none;

      padding: 16px;

      border-radius: 12px;

      font-size: 18px;

      font-weight: 700;

      cursor: pointer;

      transition: all 0.3s;

      letter-spacing: 0.5px;

      margin-bottom: 24px;

      box-shadow: 0 4px 15px rgba(0, 168, 232, 0.3);

      position: relative;

      overflow: hidden;

    }



    #quickfixStep6 .scan-button::before {

      content: '';

      position: absolute;

      top: 0;

      left: -100%;

      width: 100%;

      height: 100%;

      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);

      transition: left 0.5s;

      pointer-events: none;

    }



    #quickfixStep6 .scan-button:hover:not(:disabled)::before {

      left: 100%;

    }



    #quickfixStep6 .scan-button:hover:not(:disabled) {

      transform: translateY(-2px);

      box-shadow: 0 6px 20px rgba(0, 168, 232, 0.4);

    }



    @keyframes wave {

      0%, 100% { transform: rotate(-10deg); }

      50% { transform: rotate(10deg); }

    }





    #quickfixStep6 .scan-button:active:not(:disabled) {

      transform: translateY(0);

    }



    #quickfixStep6 .scan-button:disabled {

      background: #9ca3af !important;

      cursor: not-allowed;

      opacity: 0.6;

      box-shadow: none !important;

    }



    /* Hide Apply Pro Fixes button in Pro Step 2 ONLY for Clean cases (score < 30) */

    /* This is now handled by JavaScript, so we don't need aggressive CSS rules */



    #quickfixStep6 .scan-button:not(:disabled) {

      background: linear-gradient(135deg, #00a8e8 0%, #0077b6 100%) !important;

    }



    #quickfixStep6 .footer-buttons {

      display: flex;

      gap: 12px;

    }



    #quickfixStep6 .footer-btn {

      flex: 1;

      padding: 12px;

      border: 2px solid #e8e8e8;

      background: white;

      border-radius: 12px;

      font-size: 12px;

      font-weight: 600;

      cursor: pointer;

      transition: all 0.2s;

      color: #333;

      letter-spacing: 0.3px;

    }



    #quickfixStep6 .footer-btn:hover {

      border-color: #00a8e8;

      color: #00a8e8;

      background: #f9f9f9;

    }



    @media (max-width: 600px) {

      #quickfixStep6 .content-section {

        padding: 24px;

      }



      #quickfixStep6 .header-banner {

        min-height: auto;

        padding: 16px;

        margin-bottom: 16px;

      }



      #quickfixStep6 .modal-card {

        margin: 20px;

        border-radius: 16px;

      }



      #quickfixStep6 .header-title {

        font-size: 22px;

      }



      #proHeroStats {

        grid-template-columns: 1fr !important;

        gap: 12px !important;

      }



      #proScansRemainingCard {

        grid-column: span 1 !important;

      }



      #proRecentScansGrid {

        grid-template-columns: 1fr !important;

      }



      #quickfixStep6 .footer-buttons {

        flex-direction: column;

      }



      #quickfixStep6 .status-title {

        font-size: 20px;

      }

    }



  
/* Pro Chat Support Widget */
@keyframes chatTyping {
  0%, 60%, 100% { transform: translateY(0); }
  30% { transform: translateY(-4px); }
}

@keyframes chatSlideIn {
  from { opacity: 0; transform: translateY(20px) scale(0.95); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

@keyframes chatPulse {
  0%, 100% { box-shadow: 0 4px 12px rgba(0,168,232,0.3); }
  50% { box-shadow: 0 4px 20px rgba(0,168,232,0.5); }
}

#proChatWidget {
  animation: chatSlideIn 0.3s ease-out;
}

#chatToggleBtn {
  animation: chatPulse 2s infinite;
}

#chatToggleBtn:hover {
  transform: scale(1.1);
}

.chat-message-user {
  background: linear-gradient(135deg, #00a8e8, #0077b6) !important;
  color: white !important;
  margin-left: auto !important;
  border-bottom-right-radius: 4px !important;
}

.chat-message-assistant {
  background: #f1f5f9 !important;
  color: #1e293b !important;
  border-bottom-left-radius: 4px !important;
}
</style>



  <div class="container">

    <div class="modal-card">

      <!-- COMPACT HEADER -->

      <div class="header-banner">

        <div style="display: flex; align-items: center; gap: 12px;">

          <span style="font-family: 'Raleway', sans-serif; font-size: 20px; font-weight: 600; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">False Flag Fixerâ„¢</span>

          <div style="background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); color: #78350f; padding: 6px 16px; border-radius: 20px; font-size: 12px; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);">ðŸ’Ž Pro Fixer</div>

        </div>

        <button type="button" onclick="if(typeof window.showManageSubscription === 'function') { window.showManageSubscription(); } else { console.error('showManageSubscription not found'); }" class="settings-icon" style="display: flex; align-items: center; gap: 8px; background: transparent; border: none; cursor: pointer; padding: 8px 12px; border-radius: 8px; transition: all 0.2s; position: relative; z-index: 10; pointer-events: auto;" onmouseover="this.style.background='rgba(255, 255, 255, 0.1)';" onmouseout="this.style.background='transparent';" title="Manage Subscription">

          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="white" stroke-width="2" style="pointer-events: none;">

            <circle cx="10" cy="10" r="7" fill="none"/>

            <circle cx="10" cy="7" r="2" fill="none"/>

            <path d="M5 16c0-2.5 2-5 5-5s5 2.5 5 5" fill="none"/>

          </svg>

          <span style="color: white; font-size: 14px; font-weight: 600; white-space: nowrap;">Manage Your Subscription</span>

        </button>

      </div>



      <div class="content-section" style="padding: 40px;">

        <!-- HERO STATS SECTION - 3 EQUAL COLUMNS -->

        <div id="proHeroStats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 24px; min-width: 0;">

          <!-- Card 1: Scans Remaining -->

          <div id="proScansRemainingCard" style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); transition: transform 0.2s; min-width: 0; overflow: hidden;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 30px rgba(0,0,0,0.15)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 20px rgba(0,0,0,0.1)';">

            <div style="font-size: 12px; font-weight: 600; letter-spacing: 0.5px; color: #64748b; margin-bottom: 8px;">Scans Remaining</div>

            <div id="proScansRemainingNumber" style="font-size: 32px; font-weight: 800; line-height: 1; margin-bottom: 4px; background: linear-gradient(135deg, #00a8e8 0%, #0077b6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">500</div>

            <div id="proScansRenewalText" style="font-size: 12px; color: #94a3b8; margin-top: 4px; margin-bottom: 12px;">Resets Feb 28, 2026</div>

            <div style="width: 100%; height: 6px; background: #e2e8f0; border-radius: 3px; overflow: hidden; margin-top: 12px;">

              <div id="proScansProgressBar" style="height: 100%; background: linear-gradient(90deg, #00a8e8 0%, #0077b6 100%); border-radius: 3px; width: 0%; transition: width 0.3s ease;"></div>

            </div>

          </div>

          <!-- Card 2: Essays Fixed -->

          <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); transition: transform 0.2s; min-width: 0; overflow: hidden;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 30px rgba(0,0,0,0.15)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 20px rgba(0,0,0,0.1)';">

            <div style="font-size: 12px; font-weight: 600; letter-spacing: 0.5px; color: #64748b; margin-bottom: 8px;">Essays Fixed</div>

            <div id="proEssaysFixedNumber" style="font-size: 32px; font-weight: 800; line-height: 1; margin-bottom: 4px; background: linear-gradient(135deg, #00a8e8 0%, #0077b6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">0</div>

            <div style="font-size: 12px; color: #94a3b8; margin-top: 4px;">This month</div>

          </div>

          <!-- Card 3: Avg Score Drop -->

          <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); transition: transform 0.2s; min-width: 0; overflow: hidden;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 30px rgba(0,0,0,0.15)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 20px rgba(0,0,0,0.1)';">

            <div style="font-size: 12px; font-weight: 600; letter-spacing: 0.5px; color: #64748b; margin-bottom: 8px;">Avg Score Drop</div>

            <div id="proAvgScoreDrop" style="font-size: 32px; font-weight: 800; line-height: 1; margin-bottom: 4px; background: linear-gradient(135deg, #00a8e8 0%, #0077b6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">â€”</div>

            <div style="font-size: 12px; color: #94a3b8; margin-top: 4px;">Per scan</div>

          </div>

        </div>



        <!-- SCAN SECTION -->

        <div class="scan-section" style="background: white; border-radius: 16px; padding: 32px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); margin-bottom: 24px;">

          <div class="scan-header" style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">

            <h2 class="scan-title" style="font-size: 18px; font-weight: 700 !important; font-family: 'Raleway', sans-serif !important; color: #64748b; margin: 0;">Upload/Paste Your Essay</h2>

            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#00a8e8" stroke-width="2" style="flex-shrink: 0; cursor: pointer; transition: all 0.2s;" onclick="document.getElementById('proFileInput').click();" onmouseover="this.style.stroke='#0077b6'; this.style.transform='scale(1.1)';" onmouseout="this.style.stroke='#00a8e8'; this.style.transform='scale(1)';" title="Upload document">

              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>

              <polyline points="14 2 14 8 20 8"/>

              <line x1="16" y1="13" x2="8" y2="13"/>

              <line x1="16" y1="17" x2="8" y2="17"/>

              <polyline points="10 9 9 9 8 9"/>

            </svg>

            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#00a8e8" stroke-width="2" style="flex-shrink: 0; cursor: pointer; transition: all 0.2s;" onclick="document.getElementById('proFileInput').click();" onmouseover="this.style.stroke='#0077b6'; this.style.transform='scale(1.1)';" onmouseout="this.style.stroke='#00a8e8'; this.style.transform='scale(1)';" title="Upload file">

              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>

              <polyline points="7 10 12 15 17 10"/>

              <line x1="12" y1="15" x2="12" y2="3"/>

            </svg>

          </div>



          <!-- Hidden file input for Pro upload -->

          <input type="file" id="proFileInput" style="display: none;" accept=".txt,.doc,.docx,.rtf,.html,.pdf" onchange="handleProFileSelect(event)">



          <!-- PRO TIP CALLOUT -->

          <div id="proCharacterReminder" style="background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%); border-left: 4px solid #0ea5e9; border-radius: 12px; padding: 14px 16px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px;">

            <span style="font-size: 20px; flex-shrink: 0;">ðŸ’¡</span>

            <span style="font-size: 13px; color: #0c4a6e; font-weight: 600; line-height: 1.5;">Pro Tip: You can paste up to 1,500 words! Scan full assignments, reports, and longer essays â€” no more character limits holding you back.</span>

          </div>



          <div class="input-section">

            <textarea id="proScanInput" class="textarea" placeholder="Paste your essay here (up to 1,500 words)..." style="width: 100%; height: 180px; border: 2px solid #e2e8f0; border-radius: 12px; padding: 16px; font-family: inherit; font-size: 15px; resize: vertical; transition: border-color 0.2s; margin-bottom: 12px; white-space: pre-wrap;"></textarea>

            <div class="char-count" id="proCharCount" style="text-align: right; font-size: 13px; color: #64748b; margin-bottom: 16px;">0 / 1,500</div>

          </div>



          <button id="proScanButton" class="scan-button" onclick="startProScan()" disabled style="width: 100%; background: linear-gradient(135deg, #00a8e8 0%, #0077b6 100%); color: white; border: none; padding: 16px; border-radius: 12px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.3s; letter-spacing: 0.5px; box-shadow: 0 4px 15px rgba(0, 168, 232, 0.3); position: relative; overflow: hidden;">ðŸš€ Start Pro Scan</button>



          <div class="security-note" style="text-align: center; color: #64748b; font-size: 12px; margin-top: 12px;">ðŸ”’ Private & secure. Your essay isn't seen, stored or shared.</div>

        </div>



        <!-- RECENT SCANS SECTION -->

        <div id="proRecentScansSection" style="background: white; border-radius: 16px; padding: 28px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); margin-bottom: 24px;">

          <div class="recent-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">

            <h2 class="recent-title" style="font-size: 18px; font-weight: 700 !important; font-family: 'Raleway', sans-serif !important; color: #64748b; margin: 0;">Recent Scans</h2>

            <a href="javascript:void(0)" onclick="showProPastFixes()" class="view-all" style="color: #00a8e8; font-size: 14px; font-weight: 600; text-decoration: none; transition: color 0.2s;" onmouseover="this.style.color='#0077b6';" onmouseout="this.style.color='#00a8e8';">View All â†’</a>

          </div>

          <div id="proRecentScansGrid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">

            <!-- Recent scans will be dynamically inserted here -->

            <div class="empty-state" style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #94a3b8;">

              <div class="empty-icon" style="font-size: 60px; margin-bottom: 12px; opacity: 0.5;">ðŸ“</div>

              <div class="empty-text" style="font-size: 15px; font-weight: 600;">No scans yet â€” let's fix your first essay!</div>

            </div>

          </div>

        </div>



        <button class="back-button" onclick="hideProDashboard()" style="width: 100%; background: white; color: #0b0646; border: 2px dashed #0b0646; padding: 14px; border-radius: 12px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; margin-top: 24px; letter-spacing: 0.5px;" onmouseover="this.style.borderColor='#0b0646'; this.style.color='#0b0646'; this.style.background='#f0f4f8';" onmouseout="this.style.borderColor='#0b0646'; this.style.color='#0b0646'; this.style.background='white';">â† Back To Main Dashboard</button>

      </div>



      <!-- Pro Results Display Area (hidden initially) -->

      <div id="proResultsArea" style="display: none;">

        <!-- Results will be dynamically inserted here -->

      </div>

    </div>

  </div>

</div>



<!-- Manage Subscription Page -->

<div id="manageSubscriptionPage" style="display:none !important;position:relative !important;min-height:0 !important;background:linear-gradient(135deg, #0b0646 0%, #1a1f6e 100%);padding:40px 20px;">

  <div class="container" style="max-width:1000px;margin:0 auto;padding:30px;position:relative;background:#fff;border-radius:16px;box-shadow:0 8px 32px rgba(0,0,0,0.2);">



    <!-- Header -->

    <div style="margin-bottom:30px;padding-top:10px;">

      <div style="text-align:center;">

        <h1 style="color:#1e3a8a;font-size:2em;margin-bottom:10px;">Manage Your Subscription</h1>

        <p style="color:#6b7280;">Manage your Pro subscription and billing</p>

      </div>

    </div>



    <!-- Combined Grid Layout -->

    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:24px;align-items:stretch;margin-bottom:10px;">



      <!-- Current Subscription Status -->

      <div style="background:#f8f9fa;border-radius:16px;padding:25px;box-shadow:0 2px 8px rgba(0,0,0,0.05);">

        <h3 style="color:#1e3a8a;margin-bottom:20px;font-size:1.2em;font-weight:700;">Current Subscription</h3>

        <div style="display:flex;flex-direction:column;gap:15px;">

          <div>

            <p style="color:#6b7280;font-size:13px;margin-bottom:5px;">Plan</p>

            <p style="color:#0b0646;font-size:18px;font-weight:600;" id="subPlan">Pro - $9.99/month</p>

          </div>

          <div>

            <p style="color:#6b7280;font-size:13px;margin-bottom:5px;">Status</p>

            <p style="color:#00a8e8;font-size:18px;font-weight:600;" id="subStatus">Active</p>

          </div>

          <div>

            <p style="color:#6b7280;font-size:13px;margin-bottom:5px;">Next Billing Date</p>

            <p style="color:#0b0646;font-size:18px;font-weight:600;" id="subNextBilling">Dec 15, 2024</p>

          </div>

        </div>

      </div>



      <!-- Billing History -->

      <div style="background:#f8f9fa;border-radius:16px;padding:25px;box-shadow:0 2px 8px rgba(0,0,0,0.05);">

        <h3 style="color:#1e3a8a;margin-bottom:20px;font-size:1.2em;font-weight:700;">Billing History</h3>

        <div id="billingHistoryList">

          <!-- Billing history will be dynamically inserted here -->

          <div style="padding:15px;background:#fff;border-radius:8px;margin-bottom:10px;border:1px solid #e5e7eb;">

            <div style="display:flex;justify-content:space-between;align-items:center;gap:16px;">

              <div>

                <p style="color:#0b0646;font-weight:600;margin-bottom:5px;">Nov 15, 2024</p>

                <p style="color:#6b7280;font-size:13px;">Pro Subscription</p>

              </div>

              <div style="text-align:right;">

                <p style="color:#0b0646;font-weight:600;margin:0;">$9.99</p>

              </div>

            </div>

          </div>

          <button class="btn-outline" style="padding:6px 12px;font-size:12px;min-width:auto;line-height:1.2;margin-top:5px;align-self:flex-start;">Download</button>

        </div>

      </div>



      <!-- Usage Stats -->

      <div style="background:#f8f9fa;border-radius:16px;padding:25px;box-shadow:0 2px 8px rgba(0,0,0,0.05);">

        <h3 style="color:#1e3a8a;margin-bottom:20px;font-size:1.2em;font-weight:700;">Usage This Month</h3>

        <div style="margin-bottom:15px;">

          <div style="display:flex;justify-content:space-between;margin-bottom:10px;">

            <span style="color:#6b7280;">Scans Used</span>

            <span style="color:#0b0646;font-weight:600;" id="subScansUsed">45/500</span>

          </div>

          <div style="background:#e5e7eb;border-radius:8px;height:12px;overflow:hidden;">

            <div id="subUsageBar" style="background:#2ecc71;height:100%;width:9%;transition:width 0.3s;"></div>

          </div>

        </div>

        <p style="color:#6b7280;font-size:13px;margin-top:10px;">Resets on <span id="subResetDate">Dec 1, 2024</span></p>

      </div>



      <!-- Billing Information -->

      <div style="background:#f8f9fa;border-radius:16px;padding:25px;box-shadow:0 2px 8px rgba(0,0,0,0.05);">

        <h3 style="color:#1e3a8a;margin-bottom:20px;font-size:1.2em;font-weight:700;">Billing Information</h3>

        <div>

          <p style="color:#6b7280;font-size:13px;margin-bottom:5px;">Payment Method</p>

          <p style="color:#0b0646;font-size:16px;font-weight:600;margin-bottom:15px;" id="subPaymentMethod">â€¢â€¢â€¢â€¢ â€¢â€¢â€¢â€¢ â€¢â€¢â€¢â€¢ 4242</p>

          <button onclick="showUpdatePaymentModal()" class="btn-outline" style="padding:10px 20px;width:100%;">

            Update Payment Method

          </button>

        </div>

      </div>



      <!-- Subscription Actions -->

      <div style="background:#f8f9fa;border-radius:16px;padding:25px;box-shadow:0 2px 8px rgba(0,0,0,0.05);grid-column:1 / -1;">

        <h3 style="color:#1e3a8a;margin-bottom:20px;font-size:1.2em;font-weight:700;text-align:center;">Subscription Actions</h3>

        <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;">

          <button onclick="showCancelSubscriptionModal()" class="btn-outline" style="padding:12px 24px;color:#dc2626;border-color:#dc2626;min-width:220px;">

            Cancel Subscription

          </button>

          <button onclick="openProChatOrRedirect()" class="btn-outline" style="padding:12px 24px;min-width:220px;">

            Contact Support

          </button>

          <button onclick="hideManageSubscription()" class="btn-outline" style="padding:12px 24px;min-width:220px;">

            ðŸ’Ž Back To Pro Dashboard

          </button>

        </div>

      </div>

    </div>

  </div>

</div>



<!-- Main Input Section -->

<!-- Test Mode Toggle Button -->

<div id="testModeToggle" onclick="window.toggleProStatus()" title="Click to toggle between Pro and Free user modes for testing">

  <span class="test-mode-icon">ðŸ§ª</span>

  <span class="test-mode-text">Test: <span id="testModeStatus">Free</span></span>

</div>



<div id="inputSection" style="display:block;">

  <div class="hero-section">

    <div style="text-align: center; margin-bottom: 16px;">

      <img src="https://i.postimg.cc/hPKB2kRp/Final-site-icon-trans.png" alt="False Flag Fixer Logo" style="width: 75px; height: 75px; display: block; margin: 0 auto; animation: slowRotate 7s linear infinite;">

    </div>

    <h1 class="hero-title">False Flag Fixerâ„¢</h1>

    <p class="hero-subtitle" style="padding-bottom: 48px;">

      <span style="font-size: 1.4em; font-weight: 600;">See What Turnitin Will Flag BEFORE you Turn It In</span><br><span style="display: block; margin-top: 24px; font-size: 1.2em; font-weight: 700;">Find the Flags. ðŸš© Fix Them Fast.</span>

    </p>

  </div>



  <div class="main-container">

    <div class="input-section" id="upload-section">

      <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">

        <div style="font-size:2.5em; margin-bottom:10px;">ðŸ“„</div>

        <p style="margin:0 0 8px 0; color:#6b7280; font-size:0.85em; font-weight:400;">Supported formats: .docx, .pdf, .txt</p>

        <h3 style="margin:0 0 10px; color:#1e3a8a; font-size:1.2em;">

          Drag & Drop Your Essay Here

        </h3>

        <p style="margin:0; color:#6b7280; font-size:0.9em; font-weight:400;">Upload, paste, or click to browse â€¢ Check your work for false flags</p>

      </div>



      <!-- Hidden file input for click-to-upload -->

      <input type="file" id="fileInput" style="display: none;" accept=".txt,.doc,.docx,.rtf,.html,.pdf" onchange="handleFileSelect(event)">



      <script>

      // Early wrapper for updateCounter - will be replaced by full function later

      if (typeof window.updateCounter === 'undefined') {

        window.updateCounter = function() {

          const essayInput = document.getElementById('essayInput');

          const charCount = document.getElementById('charCount');

          if (essayInput && charCount) {

            const text = essayInput.value ? essayInput.value.trim() : ''; const wordCount = text ? text.split(/\s+/).filter(w => w.length > 0).length : 0; const len = wordCount;

            let wc = (textValue || "").trim().split(/\s+/).filter(w => w.length > 0).length; charCount.textContent = wc.toLocaleString();

            console.log('ðŸ“Š Early updateCounter - word count:', wordCount);

          }

        };

      }



      // Early wrapper for getScansUsed - will be replaced by full function later

      if (typeof window.getScansUsed === 'undefined') {

        window.getScansUsed = function() {

          try {

            const today = new Date().toDateString();

            const key = 'scans_' + today;

            const lastResetDate = localStorage.getItem('lastScanResetDate');



            // If it's a new day, reset the count

            if (lastResetDate !== today) {

              localStorage.setItem('lastScanResetDate', today);

              return 0;

            }



            return parseInt(localStorage.getItem(key) || '0', 10);

          } catch (e) {

            console.error('Error getting scan count:', e);

            return 0;

          }

        };

      }



      // Button click handlers - simple and direct

      // CRITICAL: Centralized function to reset scan button state

      function resetScanButton() {

        const btn = document.getElementById('scanButton');

        if (btn) {

          btn.disabled = false;

          btn.dataset.scanning = 'false';

          btn.style.background = '#2ecc71';

          btn.style.color = 'white';

          btn.style.cursor = 'pointer';

          btn.style.pointerEvents = 'auto';

          btn.style.opacity = '1';



          // Reset text

          const scansUsed = window.getScansUsed ? window.getScansUsed() : 0;

          const TEST_SCAN_LIMIT = 50;

          btn.innerHTML = `ðŸ” Free Scan (<span id="scanCounter">${scansUsed}/${TEST_SCAN_LIMIT}</span>)`;



          console.log('âœ… resetScanButton: Button state reset - data-scanning:', btn.dataset.scanning, 'disabled:', btn.disabled);

        }



        // Clear any intervals

        if (window.scanTimerInterval) {

          clearInterval(window.scanTimerInterval);

          window.scanTimerInterval = null;

        }



        // Clear timeout safeguard

        if (window._scanTimeoutSafeguard) {

          clearTimeout(window._scanTimeoutSafeguard);

          window._scanTimeoutSafeguard = null;

        }



        // Reset abort controller

        if (window._currentAbortController) {

          try { window._currentAbortController.abort(); } catch (e) {}

          window._currentAbortController = null;

        }



        // Clear animatedBars

        if (typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

          animatedBars.clear();

        }

      }



      // Make it globally accessible

      window.resetScanButton = resetScanButton;



      // EMERGENCY FIX: Function to unblock all clicks

      window.emergencyUnblock = function() {

        console.log('ðŸš¨ EMERGENCY: Unblocking all clicks...');



        // Remove modal-open class from body

        document.body.classList.remove('modal-open');

        document.body.style.overflow = '';

        document.body.style.pointerEvents = '';



        // Remove ALL modal overlays

        document.querySelectorAll('[id*="modal"], [class*="modal"], [id*="overlay"], [class*="overlay"]').forEach(el => {

          if (el.style.position === 'fixed' || el.style.zIndex > 1000) {

            el.style.display = 'none';

            el.remove();

          }

        });



        // Reset all pointer-events

        document.querySelectorAll('*').forEach(el => {

          if (el.style.pointerEvents === 'none') {

            el.style.pointerEvents = '';

          }

        });



        // Use centralized reset function

        resetScanButton();



        console.log('âœ… Emergency unblock complete - try clicking now');

      };



      window.handleScanClick = function(e) {

        // CRITICAL: Check if Pro user - redirect to Pro dashboard

        if (window.appState?.isProUser) {

          console.log('ðŸ’Ž Pro user clicked scan - redirecting to Pro dashboard');

          if (typeof showProDashboard === 'function') {

            showProDashboard();

          } else {

            console.warn('âš ï¸ showProDashboard function not found');

          }

          if (e) {

            e.preventDefault();

            e.stopPropagation();

          }

          return false;

        }



        // CRITICAL: Prevent duplicate scans

        if (window._scanInProgress) {

          console.warn('âš ï¸ Scan already in progress - ignoring duplicate click');

          return false;

        }

        if (e) {

          e.preventDefault();

          e.stopPropagation();

        }

        console.log('ðŸ”˜ Scan button clicked');



        // CRITICAL: Check if button is already scanning - prevent double clicks

        const scanButton = document.getElementById('scanButton');

        if (window._scanInProgress) {

          console.log('âš ï¸ Scan already in progress (global flag), ignoring click');

          return false;

        }

        if (scanButton) {

          if (scanButton.dataset.scanning === 'true' || scanButton.disabled) {

            console.log('âš ï¸ Scan already in progress (button state), ignoring click');

            return false;

          }

        }



        // FIRST: Reset any previous state (ensures clean start)

        resetScanButton();



        // Now set scanning state

        if (scanButton) {

          scanButton.dataset.scanning = 'true';

          scanButton.disabled = true;

          scanButton.style.background = '#9ca3af';

          scanButton.style.cursor = 'not-allowed';

          scanButton.style.opacity = '0.7';

          scanButton.innerHTML = 'â³ Scanning...';

        }



        // Check daily limit

        const scansUsed = window.getScansUsed ? window.getScansUsed() : 0;

        const TEST_SCAN_LIMIT = 50;

        const remaining = Math.max(0, TEST_SCAN_LIMIT - scansUsed);

        const isFreeUserExhausted = remaining === 0 && !appState.isProUser;



        if (isFreeUserExhausted) {

          resetScanButton();

          alert('Daily limit reached! You\'ve used all ' + TEST_SCAN_LIMIT + ' test scans. Upgrade to Pro for 100 monthly scans.');

          return;

        }



        // Validate inputs

        const cb = document.getElementById('authorshipCheckbox');

        const input = document.getElementById('essayInput');

        if (!cb || !cb.checked) {

          resetScanButton();

          showAuthorshipConfirmationModal();

          return;

        }

        if (!input || !input.value.trim() || input.value.trim().length < 50) {

          resetScanButton();

          alert('Please enter your essay first (at least 50 characters)!');

          return;

        }



        // Call scanEssay with error handling

        if (window.scanEssay) {

          console.log('âœ… Calling scanEssay');



          // Timeout safeguard

          const timeoutId = setTimeout(() => {

            console.error('â±ï¸ Scan timeout safeguard triggered');

            resetScanButton();

            if (typeof showSuccessMessage === 'function') {

              showSuccessMessage('Scan timed out. Please try again.', '#dc2626');

            }

          }, 15000); // 15 seconds



          window._scanTimeoutSafeguard = timeoutId;



          // Wrap scanEssay in try-catch to ensure cleanup

          try {

          window.scanEssay().finally(() => {

              // ALWAYS cleanup

            if (window._scanTimeoutSafeguard) {

              clearTimeout(window._scanTimeoutSafeguard);

              window._scanTimeoutSafeguard = null;

            }

              // Reset button state after scan completes

              setTimeout(resetScanButton, 500); // Small delay to ensure UI updates

            });

          } catch (error) {

            console.error('âŒ scanEssay error:', error);

            resetScanButton();

            if (typeof showSuccessMessage === 'function') {

              showSuccessMessage('Scan failed. Please try again.', '#dc2626');

            }

          }

        } else {

          resetScanButton();

          console.error('âŒ scanEssay not found');

          alert('Page is still loading. Please wait a moment and try again.');

        }

      };



      // Also expose as direct function for HTML onclick handlers

      function handleScanClick(e) {

        return window.handleScanClick(e);

      }



      window.handleQuickFixClick = function(e) {

        // CRITICAL: Check if Pro user - redirect to Pro dashboard

        if (window.appState?.isProUser) {

          console.log('ðŸ’Ž Pro user clicked QuickFix - redirecting to Pro dashboard');

          if (typeof showProDashboard === 'function') {

            showProDashboard();

          } else {

            console.warn('âš ï¸ showProDashboard function not found');

          }

          if (e) {

            e.preventDefault();

            e.stopPropagation();

          }

          return false;

        }



        if (e) {

          e.preventDefault();

          e.stopPropagation();

        }

        console.log('ðŸ”˜ QuickFix button clicked');



        // Close the essay too long modal if it's open

        const essayTooLongModal = document.getElementById('essayTooLongModal');

        if (essayTooLongModal && essayTooLongModal.style.display !== 'none') {

          essayTooLongModal.style.display = 'none';

          document.body.classList.remove('modal-open');

        }



        // TEMPORARY: Use test limit for testing (revert to FREE_SCAN_LIMIT before launch)

        const TEST_SCAN_LIMIT = 50;

        const scansUsed = window.getScansUsed ? window.getScansUsed() : 0;

        const remaining = Math.max(0, TEST_SCAN_LIMIT - scansUsed);

        const isFreeUserExhausted = remaining === 0 && !appState.isProUser;



        if (isFreeUserExhausted) {

          // Show upgrade modal instead of QuickFix

          alert('Free scans exhausted! Upgrade to Pro for unlimited scans and fixes, or wait until midnight for free scans to reset.');

          // Optionally trigger Pro upgrade modal here

          if (window.startProCTA) {

            window.startProCTA();

          }

          return;

        }



        const cb = document.getElementById('authorshipCheckbox');

        const input = document.getElementById('essayInput');

        if (!cb || !cb.checked) {

          showAuthorshipConfirmationModal();

          return;

        }

        if (!input || !input.value.trim() || input.value.trim().length < 50) {

          alert('Please enter your essay first (at least 50 characters)!');

          return;

        }

        if (window.showQuickFixConfirmationModal) {

          console.log('âœ… Calling showQuickFixConfirmationModal');

          window.showQuickFixConfirmationModal();

        } else {

          console.error('âŒ showQuickFixConfirmationModal not found - page may not be fully loaded');

          alert('Page is still loading. Please wait a moment and try again.');

        }

      };



      // Also expose as direct function for HTML onclick handlers

      function handleQuickFixClick(e) {

        return window.handleQuickFixClick(e);

      }



      window.handleProClick = function(e) {

        if (e) {

          e.preventDefault();

          e.stopPropagation();

        }

        console.log('ðŸ”˜ Pro button clicked');

        const cb = document.getElementById('authorshipCheckbox');

        const input = document.getElementById('essayInput');

        if (!cb || !cb.checked) {

          showAuthorshipConfirmationModal();

          return;

        }

        if (!input || !input.value.trim() || input.value.trim().length < 50) {

          alert('Please enter your essay first (at least 50 characters)!');

          return;

        }

        if (window.startProCTA) {

          console.log('âœ… Calling startProCTA');

          window.startProCTA();

        } else if (window.handleProUpgrade) {

          console.log('âœ… Calling handleProUpgrade');

          window.handleProUpgrade();

        } else {

          console.error('âŒ Pro functions not found - page may not be fully loaded');

          alert('Page is still loading. Please wait a moment and try again.');

        }

      };



      console.log('âœ… Button handlers defined');



      // Test if functions are available after page loads

      window.addEventListener('load', function() {

        console.log('ðŸ“‹ Page loaded - checking functions:');

        console.log('  scanEssay:', typeof window.scanEssay);

        console.log('  showQuickFixConfirmationModal:', typeof window.showQuickFixConfirmationModal);

        console.log('  startProCTA:', typeof window.startProCTA);

        console.log('  handleProUpgrade:', typeof window.handleProUpgrade);

      });

      </script>



      <textarea id="essayInput" placeholder="Paste your essay here (minimum 50 words)..." onchange="if(typeof updateCounter === 'function') updateCounter();" style="white-space: pre-wrap;"></textarea>



      <p style="text-align: center; margin: 8px 0 0 0; padding: 0 20px; color: #6b7280; font-size: 13px; line-height: 1.5;">ðŸ”’ Private & secure. Your essay isn't seen, stored or shared.</p>



      <!-- Authorship Confirmation Checkbox -->

      <div id="authorshipSection" style="margin: 20px 0; padding: 15px; background: #fef2f2; border: 2px solid #fecaca; border-radius: 8px; display: flex; align-items: center; gap: 15px;">

        <!-- Lil Sus Animated Image -->

        <img src="https://i.postimg.cc/BvfyyZqm/Generated-Image-September-04-2025-10-44AM.jpg" alt="Lil Sus" id="lilSusImage" style="width: 80px; height: auto; flex-shrink: 0; animation: pointBackForth 2s ease-in-out infinite;">

        <label style="display: flex; align-items: flex-start; gap: 10px; cursor: pointer; font-size: 14px; line-height: 1.4; flex: 1;">

          <input type="checkbox" id="authorshipCheckbox" required style="margin-top: 2px; transform: scale(1.2);">

          <span style="color: #dc2626; font-weight: 600;">

            Hey, you wrote this yourself, right?

            <br>

            <small style="color: #7f1d1d; font-weight: 400; font-size: 12px; margin-top: 4px; display: block;">

              By checking this, you're confirming this is your original workâ€”written by you, not AI.

            </small>

          </span>

        </label>

      </div>



      <div class="char-counter"><span id="charCount">0</span> / 1,500</div>

      <div class="scans-left" id="scansLeft">3 free scans remaining today</div>



      <!-- COLLAPSIBLE INFO BOX - SCORE EXPLANATION -->

      <div style="margin-bottom: 24px; max-width: 600px; margin-left: auto; margin-right: auto;">

        <div id="scoreInfoToggle" 

             style="display: flex; align-items: center; justify-content: center; gap: 12px; 

                    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);

                    padding: 14px 16px;

                    border-radius: 8px;

                    cursor: pointer;

                    user-select: none;

                    transition: all 0.2s ease;"

             onmouseover="this.style.backgroundColor='#e0f2fe'"

             onmouseout="this.style.backgroundColor=''">

          <span id="scoreInfoArrow" 

                style="display: inline-block; 

                       transition: transform 0.3s ease;

                       font-size: 18px;">â–¼</span>

          <span style="font-weight: 600; 

                       color: #0b0646; 

                       font-size: 14px;">

            What You'll Get

          </span>

        </div>



        <div id="scoreInfoContent" 

             style="display: none;

                    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);

                    border-top: none;

                    padding: 16px;

                    border-radius: 0 0 8px 8px;

                    margin-top: -4px;

                    animation: slideDownInfo 0.3s ease;

                    text-align: center;">

          <div style="font-size: 13px; color: #374151; line-height: 1.8;">

            <div style="margin-bottom: 12px;">

              <strong style="color: #0b0646;">âœ“ Your Sus Score (Low Sus, Mid Sus, or Major Sus)</strong><br>

              Based on AI trigger words and writing patterns

            </div>



            <div style="margin-bottom: 12px;">

              <strong style="color: #0b0646;">âœ“ Highlighted trigger words</strong><br>

              See exactly what's flagging detectors

            </div>



            <div>

              <strong style="color: #0b0646;">âœ“ Low-trigger alternatives</strong><br>

              Swap risky phrases for safer options

            </div>

          </div>

        </div>

      </div>



      <div class="button-group" style="display: flex !important; gap: 16px !important; margin-top: 20px; justify-content: center !important; flex-wrap: nowrap !important;">

        <button id="scanButton" type="button" class="btn-primary" onclick="handleScanClick(event);">ðŸ” Free Scan (<span id="scanCounter">1/3</span>)</button>

        <button id="emergencyButton" type="button" class="btn-secondary"

                data-tooltip="Find ALL AI-trigger words and fix them - $1.99. Scan up to 1,500 words."

                onclick="handleQuickFixClick(event);"><span style="color: #ffffff !important; display: inline-block; text-shadow: -1px -1px 0px #ffffff, 1px -1px 0px #ffffff, -1px 1px 0px #ffffff, 1px 1px 0px #ffffff, 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.6); filter: brightness(1) !important; font-weight: bold; -webkit-text-stroke: 1px #ffffff; text-stroke: 1px #ffffff;">âš¡</span> QuickFix ($1.99)</button>

        <button id="proButton" type="button" class="btn-success"

                data-tooltip="100 monthly scans + fixes - $9.99/month. Scan up to 1,500 words."

                onclick="handleProClick(event);">ðŸ’Ž False Flag Fixerâ„¢ Pro ($9.99/mo)</button>

      </div>



      <div style="text-align:center; margin-top:12px;">

        <p style="font-size:11px; color:#9ca3af; line-height:1.3;">

          QuickFixâ„¢ fixes this essay completely ($1.99 one-time) â€¢ Pro includes 100 monthly scans up to 1,500 words each and can be cancelled anytime

        </p>

      </div>

      <div class="stripe-badge">

        Secure payment by <span class="stripe-logo">Stripe</span>

      </div>

    </div>

  </div>

</div>



<!-- UNLOCK BOX OVERLAY ON TOP OF BLURRED TEXT -->

<div id="resultsContainer" class="results-container">

  <div class="hero-section" style="padding-bottom: 0px;">

    <div style="text-align: center; margin-bottom: 16px;">

      <img src="https://i.postimg.cc/hPKB2kRp/Final-site-icon-trans.png" alt="False Flag Fixer Logo" style="width: 75px; height: 75px; display: block; margin: 0 auto; animation: slowRotate 7s linear infinite;">

    </div>

    <h1 class="hero-title">False Flag Fixerâ„¢ - Free <span style="vertical-align: middle;">ðŸ†“</span></h1>

    <p class="hero-subtitle" style="padding-bottom: 72px;">

      <span style="font-size: 1.4em; font-weight: 600;">See What Turnitin Will Flag BEFORE you Turn It In</span><br><span style="display: block; margin-top: 24px; font-size: 1.2em; font-weight: 700;">Find the Flags. ðŸš© Fix Them Fast.</span>

    </p>

  </div>

  <div class="results-wrapper">



    <!-- CARD 1: HELLA SUS VERSION (70%+) -->

    <div id="hellaSusCard" class="card warning-card" style="padding: 24px 28px; overflow: visible; position: relative; display: none; margin-bottom: 20px; box-sizing: border-box;">

      <button onclick="minimizeResults()" style="position: absolute; top: 12px; right: 15px; background: none; border: none; font-size: 20px; color: #ffe4e4; cursor: pointer; z-index: 2;">Ã—</button>



      <!-- Your AI Sus Score Title -->

      <div style="text-align: center; margin: 0 0 48px 0; position: relative; z-index: 10; padding: 0;">

        <h3 style="font-size: 36px; font-weight: 700; font-family: 'Raleway', sans-serif; color: #0b0646; margin: 0 0 8px 0; text-align: center; letter-spacing: -0.25px;">Your AI Sus Score</h3>

        <p style="font-size: 14px; font-weight: 400; color: #6b7280; margin: 0; text-align: center; line-height: 1.4;">How suspicious your writing looks to AI detectors â€” even though it's 100% human ðŸ™„</p>

      </div>

      <!-- HEADER SECTION - NEW STYLE -->

      <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #dc2626; border-right: 8px solid #dc2626;">

        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

          <div style="width: 60px; height: 60px; background: #fee2e2; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3); flex-shrink: 0;">

            <span style="font-size: 36px; line-height: 1;">ðŸš©</span>

          </div>

          <div style="text-align: center;">

            <h2 id="hellaSusWarningTitle" style="font-size: 32px; font-weight: 700; font-family: 'Raleway', sans-serif; margin: 0; line-height: 1; color: #ff4444; letter-spacing: -0.25px;">Major Sus</h2>

            <p id="hellaSusLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">AI detectors are gonna lose it - time for the full glow-up âœ¨</p>

          </div>

        </div>

      </div>



      <!-- Major Red Flags Alert for Hella Sus -->

      <div class="major-red-flags-alert" style="display: none; margin: 24px 0 16px 0;">

        <div style="background: #ef4444; color: white; font-weight: 700; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">

          <span style="font-size: 20px;">âš ï¸</span>

          <span>Major red flags detected</span>

        </div>

      </div>



      <!-- Score Display - FIXED POSITION (matches QuickFix) -->

      <div style="text-align:center; margin-bottom:30px;">

        <div class="score-display" style="display: flex; flex-direction: column; align-items: center; gap: 4px;">

          <span class="score-number" id="hellaSusScoreNumber" style="font-size: 72px; font-weight: 700; color: #dc2626; line-height: 1;">0%</span>

          <span class="score-label" id="hellaSusScoreLabel" style="font-size: 14px !important; font-weight: 600 !important; letter-spacing: 0.5px; color: #6b7280 !important; line-height: 1;">Major Sus</span>

        </div>

        <!-- Progress Bar with Dot Indicator -->

        <div class="progress-container">

          <div class="progress-bar" id="hellaSusProgressBar" style="height: 8px; background: #e5e7eb; border-radius: 4px; position: relative; overflow: visible; border: 1px solid #ccc;">

            <div class="progress-fill" id="hellaSusProgressFill"></div>

            <div class="progress-indicator" id="hellaSusProgressIndicator"></div>

          </div>

          <div class="progress-endpoints">

            <span>0%</span>

            <span>50%</span>

            <span>100%</span>

          </div>

          <div class="progress-labels">

            <span>âœ… Low Sus</span>

            <span>âš ï¸ Mid Sus</span>

            <span>ðŸš¨ Major Sus</span>

          </div>

        </div>

      </div>

    </div>



    <!-- CARD 1: YOU'RE GOOD VERSION (0-29%) -->

    <div id="youreGoodCard" class="card warning-card" style="padding: 24px 28px; overflow: visible; position: relative; display: none; margin-bottom: 20px; box-sizing: border-box;">

      <button onclick="minimizeResults()" style="position: absolute; top: 12px; right: 15px; background: none; border: none; font-size: 20px; color: #d1fae5; cursor: pointer; z-index: 2;">Ã—</button>



      <!-- Your AI Sus Score Title -->

      <div style="text-align: center; margin: 0 0 48px 0; position: relative; z-index: 10; padding: 0;">

        <h3 style="font-size: 36px; font-weight: 700; font-family: 'Raleway', sans-serif; color: #0b0646; margin: 0 0 8px 0; text-align: center; letter-spacing: -0.25px;">Your AI Sus Score</h3>

        <p style="font-size: 14px; font-weight: 400; color: #6b7280; margin: 0; text-align: center; line-height: 1.4;">How suspicious your writing looks to AI detectors â€” even though it's 100% human ðŸ™„</p>

      </div>

      <!-- HEADER SECTION - NEW STYLE -->

      <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #2ecc71; border-right: 8px solid #2ecc71;">

        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

          <div style="width: 60px; height: 60px; background: #d1fae5; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(46, 204, 113, 0.3); flex-shrink: 0;">

            <span style="font-size: 36px; line-height: 1;">âœ…</span>

          </div>

          <div style="text-align: center;">

            <h2 id="youreGoodWarningTitle" style="font-size: 32px; font-weight: 700; font-family: 'Raleway', sans-serif; margin: 0; line-height: 1; color: #2ecc71; letter-spacing: -0.25px;">Low Sus</h2>

            <p id="youreGoodLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">No AI-trigger words detected</p>

          </div>

        </div>

      </div>



      <!-- Clean Alert -->

      <div class="clean-alert" style="display: none; margin: 24px 0 16px 0;">

        <div style="background: #10b981; color: white; font-weight: 700; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">

          <span style="font-size: 20px;">âœ…</span>

          <span>Clean as a whistle!</span>

        </div>

      </div>



      <!-- Score Display - FIXED POSITION (matches QuickFix) -->

      <div style="text-align:center; margin-bottom:30px;">

        <div class="score-display" style="display: flex; flex-direction: column; align-items: center; gap: 4px;">

          <span class="score-number" id="youreGoodScoreNumber" style="font-size: 72px; font-weight: 700; color: #2ecc71; line-height: 1;">0%</span>

          <span class="score-label" id="youreGoodScoreLabel" style="font-size: 14px !important; font-weight: 600 !important; letter-spacing: 0.5px; color: #6b7280 !important; line-height: 1;">Low Sus</span>

        </div>

        <!-- Progress Bar with Dot Indicator -->

        <div class="progress-container">

          <div class="progress-bar" id="youreGoodProgressBar" style="height: 8px; background: #e5e7eb; border-radius: 4px; position: relative; overflow: visible; border: 1px solid #ccc;">

            <div class="progress-fill" id="youreGoodProgressFill"></div>

            <div class="progress-indicator" id="youreGoodProgressIndicator"></div>

          </div>

          <div class="progress-endpoints">

            <span>0%</span>

            <span>50%</span>

            <span>100%</span>

          </div>

          <div class="progress-labels">

            <span>âœ… Low Sus</span>

            <span>âš ï¸ Mid Sus</span>

            <span>ðŸš¨ Major Sus</span>

          </div>

        </div>

      </div>



      <!-- CONGRATULATORY MESSAGE FOR CLEAN/NO SUS -->

      <div style="background: #d1fae5; border-radius: 8px; padding: 24px; margin: 20px; text-align: center;">

        <div style="font-size: 48px; margin-bottom: 12px;">ðŸŽ‰</div>

        <h2 style="font-size: 28px; font-weight: 800; color: #047857; margin: 0 0 12px 0;">Vibe Check Passed!</h2>

        <p style="font-size: 18px; font-weight: 600; color: #065f46; margin: 0;">No AI-trigger words detected</p>

      </div>



      <!-- ROTATING SUCCESS MESSAGES -->

      <div id="rotatingCleanMessage" style="text-align: center; margin: 20px; padding: 16px; font-size: 20px; font-weight: 700; color: #1e3a8a; min-height: 30px; transition: opacity 0.5s ease-in-out;">

        <!-- Messages will rotate here -->

      </div>



      <!-- ESSAY PREVIEW (FREE Clean No Sus) - Exact copy from QuickFix Step 2 Clean No Sus - ABOVE GREEN BOX -->

      <div id="freeCleanNoSusEssayContainer" style="background:#f8f9fa; border-radius:12px; padding:20px 20px 10px 20px; margin:20px 0; display: none;">

        <!-- Heading for Clean No Sus -->

        <h3 style="text-align:center; color:#2ecc71; font-size:20px; font-weight:700; margin-top:10px; margin-bottom:8px;">

          âœ… Your Essay is Low Sus!

        </h3>

        <p style="text-align:center; color:#6b7280; font-size:14px; margin-bottom:20px; font-weight:500;">

          No AI-trigger words detected. Your essay is ready to turn in!

        </p>



        <!-- Essay Content - Same structure as quickfixEssayContainer > flaggedEssayContent -->

        <div id="freeCleanNoSusEssayContent" class="essay-content" style="line-height:1.8; max-height: 400px; overflow-y: auto; overflow-x: auto; border: 1px solid #d1d5db; border-right: 4px solid #2ecc71; border-radius: 8px; padding: 20px; background: white; margin-top: 0; margin-bottom: 0; font-size: 16px; position: relative;">

          <!-- Essay content will be inserted here - same as flaggedEssayContent for Clean No Sus -->

        </div>



        <!-- Copy Text CTA for FREE Clean No Sus - Same as QuickFix -->

        <div id="freeCleanNoSusCopyTextCTA" style="display: none; text-align: center; margin: 0; padding: 24px 0 24px 0;">

          <button id="freeCleanNoSusCopyButton" onclick="copyFreeCleanNoSusResult()" style="background: #2ecc71 !important; color: white !important; border: 1px solid #2ecc71 !important; border-radius: 8px; padding: 12px 24px; font-size: 16px; font-weight: 600; cursor: pointer; width: 100%; transition: all 0.2s; margin: 0;" onmouseover="this.style.background='#27ae60'; this.style.borderColor='#27ae60'; this.style.color='white';" onmouseout="this.style.background='#2ecc71'; this.style.borderColor='#2ecc71'; this.style.color='white';">

            âœ… Copy & Turn It In

          </button>

        </div>

      </div>



      <!-- REMOVED: GREEN BOX WITH MAIN CHARACTER ENERGY MESSAGE - User requested removal -->

      <!-- This box is permanently hidden for FREE Clean No Sus page -->

      <div id="freeCleanNoSusMainCharacterBox" style="display: none !important; visibility: hidden !important; opacity: 0 !important; position: absolute !important; left: -9999px !important; text-align: center; margin: 24px 20px; padding: 20px; background: #f0fdf4; border-radius: 12px; border: 2px solid #2ecc71; height: 0 !important; overflow: hidden !important;">

        <p style="font-size: 20px; font-weight: 700; color: #047857; margin: 0; line-height: 1.4;">

          ðŸ‘Œ This is giving main character energy ðŸ’…

        </p>

      </div>

    </div>



    <!-- CARD 1: KINDA SUS VERSION (30-69%) -->

    <div id="kindaSusCard" class="card warning-card" style="padding: 24px 28px; overflow: visible; position: relative; display: none; margin-bottom: 20px; box-sizing: border-box;">

      <button onclick="minimizeResults()" style="position: absolute; top: 12px; right: 15px; background: none; border: none; font-size: 20px; color: #fef3c7; cursor: pointer; z-index: 2;">Ã—</button>



      <!-- Your AI Sus Score Title -->

      <div style="text-align: center; margin: 0 0 48px 0; position: relative; z-index: 10; padding: 0;">

        <h3 style="font-size: 36px; font-weight: 700; font-family: 'Raleway', sans-serif; color: #0b0646; margin: 0 0 8px 0; text-align: center; letter-spacing: -0.25px;">Your AI Sus Score</h3>

        <p style="font-size: 14px; font-weight: 400; color: #6b7280; margin: 0; text-align: center; line-height: 1.4;">How suspicious your writing looks to AI detectors â€” even though it's 100% human ðŸ™„</p>

      </div>

      <!-- HEADER SECTION - NEW STYLE -->

      <div style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin: 20px 0; border-left: 8px solid #f5a623; border-right: 8px solid #f5a623;">

        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px;">

          <div style="width: 60px; height: 60px; background: #fef3c7; border-radius: 8px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(245, 166, 35, 0.3); flex-shrink: 0;">

            <span style="font-size: 36px; line-height: 1;">âš ï¸</span>

          </div>

          <div style="text-align: center;">

            <h2 id="kindaSusWarningTitle" style="font-size: 32px; font-weight: 700; font-family: 'Raleway', sans-serif; margin: 0; line-height: 1; color: #f5a623; letter-spacing: -0.25px;">Mid Sus</h2>

            <p id="kindaSusLabel" style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px; color: #6b7280; margin-top: 6px;">These sentences are lowkey cooked. Not on Lil' Sus's watch.</p>

          </div>

        </div>

      </div>



      <!-- Kinda Sus Alert -->

      <div class="kinda-sus-alert" style="display: none; margin: 24px 0 16px 0;">

        <div style="background: #f59e0b; color: white; font-weight: 700; padding: 12px 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">

          <span style="font-size: 20px;">âš ï¸</span>

          <span>Some wording might come across as AI</span>

        </div>

      </div>



      <!-- Score Display - FIXED POSITION (matches QuickFix) -->

      <div style="text-align:center; margin-bottom:30px;">

        <div class="score-display" style="display: flex; flex-direction: column; align-items: center; gap: 4px;">

          <span class="score-number" id="kindaSusScoreNumber" style="font-size: 72px; font-weight: 700; color: #f5a623; line-height: 1;">0%</span>

          <span class="score-label" id="kindaSusScoreLabel" style="font-size: 14px !important; font-weight: 600 !important; letter-spacing: 0.5px; color: #6b7280 !important; line-height: 1;">Mid Sus</span>

        </div>

        <!-- Progress Bar with Dot Indicator -->

        <div class="progress-container">

          <div class="progress-bar" id="kindaSusProgressBar" style="height: 8px; background: #e5e7eb; border-radius: 4px; position: relative; overflow: visible; border: 1px solid #ccc;">

            <div class="progress-fill" id="kindaSusProgressFill"></div>

            <div class="progress-indicator" id="kindaSusProgressIndicator"></div>

          </div>

          <div class="progress-endpoints">

            <span>0%</span>

            <span>50%</span>

            <span>100%</span>

          </div>

          <div class="progress-labels">

            <span>âœ… Low Sus</span>

            <span>âš ï¸ Mid Sus</span>

            <span>ðŸš¨ Major Sus</span>

          </div>

        </div>

      </div>

    </div>



    <!-- URGENCY CTA WITH LIL SUS - MOVED ABOVE INTERACTIVE ESSAY BOX -->

    <div id="urgencyCTASection" style="text-align: center; margin: 24px 0 20px 0;">

      <!-- Heading: Don't Turn It In Yet - Centered with Lil Sus inline -->

      <h2 style="font-size: 30px; font-weight: 800; color: #1a1f6e; margin: 0 0 12px 0; line-height: 1.3; display: flex; align-items: center; justify-content: center; gap: 16px;">

        <img src="https://i.postimg.cc/BvfyyZqm/Generated-Image-September-04-2025-10-44AM.jpg" alt="Lil Sus" style="width: 100px; height: auto; animation: pointBackForth 2s ease-in-out infinite; flex-shrink: 0;">

        <span>ðŸ›‘ Don't Turn It In Yet</span>

      </h2>



      <!-- Dynamic Warning Message - Centered -->

      <div id="urgencyWarningMessage" style="color: #374151; font-size: 16px; margin: 0 0 22px 0; line-height: 1.6; font-weight: 500; max-width: 700px; margin-left: auto; margin-right: auto; display: block !important; visibility: visible !important; opacity: 1 !important;">

        <!-- JavaScript will populate this -->

      </div>

    </div>



    <!-- AI TRIGGER WORDS SECTION -->

    <div id="freeTriggerWordsCard" class="card" style="padding: 20px; margin-bottom: 20px;">

      <!-- TRIGGER HEADING WITH BADGE COUNTS -->

      <p id="freeTriggerHeading" style="color: #1e3a8a; font-size: 24px; font-weight: 800; margin: 0 0 0px 0; padding-bottom: 0px; text-align: center;">

        <span id="freeTriggerHeadingText" style="font-size: 20px; font-weight: 800;">âš¡ AI Trigger Words/Phrases: <span style="color: #dc2626; font-weight: 800;">0</span> Shown <span style="color: #dc2626; font-weight: 800;">0</span> Detected</span>

      </p>



      <!-- TRIGGER WORDS SUBTITLE -->

      <p id="freeTriggerWordsSubtitle" style="font-size: 14px; color: #6b7280; margin: 0 0 40px 0; line-height: 1.6; text-align: center; display: none;">

        Unlock QuickFix or Pro to view them all and reduce your Sus Score and reset the free scans

      </p>



      <!-- Hover instruction -->

      <p id="freeTriggerChipsHint" style="font-size: 12px; color: #9ca3af; margin: 0 0 12px 0; text-align: center; font-style: italic; opacity: 0.7;">Hover over each trigger word for to see why it might get flagged</p>



      <!-- TRIGGER CHIPS (red pill-shaped buttons with lock icons) -->

      <div id="freeTriggerChips" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-bottom: 16px;">

        <!-- JavaScript populates this -->

      </div>



      <!-- URGENT TRIGGER WARNING CARD - REMOVED -->

    </div>



    <!-- LIL SUS CLEAN ESSAY MESSAGE (shown only for Clean/No Sus) -->

    <div id="cleanEssayLilSusMessage" style="display: none !important; text-align: center; margin: 24px 0; padding: 20px; background: #f0fdf4 !important; border-radius: 12px; border: 2px solid #2ecc71; position: relative !important; z-index: 9999 !important; opacity: 1 !important; visibility: visible !important;">

      <div style="display: flex; align-items: center; justify-content: center; gap: 16px; flex-wrap: wrap;">

        <img src="https://i.postimg.cc/BvfyyZqm/Generated-Image-September-04-2025-10-44AM.jpg" alt="Lil Sus" style="width: 80px; height: auto; animation: pointBackForth 2s ease-in-out infinite; flex-shrink: 0;">

        <p style="font-size: 20px; font-weight: 700; color: #047857; margin: 0; line-height: 1.4;">

          Your essay is clean and ready to turn in! âœ¨

        </p>

      </div>

    </div>



    <!-- CTA UNDER-TEXT (Clean/No Sus only) -->

    <div id="cleanNoSusCtaUndertext" style="margin: 16px 0 12px 0; text-align: center; line-height: 1.6; display: none;">

      <div style="display: flex; align-items: center; justify-content: center; gap: 12px; font-size: 20px; margin-bottom: 8px; font-weight: bold;">

        <img src="https://i.postimg.cc/vT6KtkH0/LS-pointing-trans-1.png" alt="Lil Sus" class="lil-sus-pulsate" style="height: 56px; width: auto; object-fit: contain;" />

        <span style="color: #1e3a8a;">âš ï¸ FYI, Bestie</span>

      </div>

      <p style="font-size: 14px; color: #6b7280; margin: 0; line-height: 1.6; font-weight: 500;">

        AI detectors are unpredictable â€” a low sus essay today can trigger AI detectors tomorrow.<br><strong>Upgrade below for deeper AI scans & fixes powered by Claude Haiku. Better safe than sus.</strong>

      </p>

      </div>



    <!-- Can't Decide Message -->

    <p id="cantDecideMessage" style="text-align: center; color: #1f2937; font-size: 16px; margin: 20px 0 24px 0; line-height: 1.6; font-weight: 600; display: block !important; visibility: visible !important; opacity: 1 !important; background: #fef3c7; padding: 12px 20px; border-radius: 8px; border: 1px solid #fbbf24;">

      Can't decide? Scroll down to see what you actually get with each option ðŸ‘‡

    </p>



    <!-- LOCKBOX CARD - Dynamic colors based on score -->

    <div id="freeUnlockOverlay" style="position: relative; margin-bottom: 20px; padding: 0; overflow: hidden; min-height: 450px; opacity: 1; visibility: visible;">



      <!-- BLURRED BACKGROUND - User's Essay Goes Here -->

      <div id="lockboxBlurredBackground" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 0; padding: 32px 24px; filter: blur(6px); opacity: 0.9; pointer-events: none;">

        <div style="font-size: 13px; line-height: 1.6; color: #6b7280; white-space: pre-wrap; word-wrap: break-word; max-height: 400px; overflow: hidden;">

          [Essay preview will appear here]

        </div>

    </div>



      <!-- OVERLAY CONTENT (Lock icon, text, button) -->

      <div style="position: relative !important; z-index: 9999 !important; padding: 32px 24px !important; text-align: center !important; border: 2px dashed #dc2626 !important; border-radius: 8px !important; background: white !important; box-shadow: 0 10px 30px rgba(0,0,0,0.1) !important; opacity: 1 !important; visibility: visible !important; margin: 0 !important;">

        <div style="font-size: 48px; margin-bottom: 16px;">ðŸ”’</div>

        <h3 id="lockboxHeading" style="font-size: 20px; font-weight: 700; margin: 0 0 12px 0; line-height: 1.3;">Need a Quick Last Minute Fix?</h3>

        <p style="font-size: 14px; line-height: 1.6; margin: 0 0 16px 0; color: #374151;">Did you know your 100% human-written essay can sound AI to detectors and still get flagged? Yup, that's wild AF! For $1.99, QuickFix shows you what Turnitin will flag and how to fix it. Don't turn it in yet. Fix it first.</p>

        <p id="quickfixPreCheckBox" style="font-size: 18px; font-weight: 600; margin: 0 auto 16px auto; color: #1f2937; border: 2px dashed #ff6b00 !important; padding: 12px 16px; border-radius: 6px; display: block; width: fit-content; text-align: center; box-sizing: border-box;">Don't Risk It. QuickFix It.</p>

        <div style="margin-top: 16px; margin-bottom: 16px; padding-bottom: 12px; display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">

          <div style="font-size: 16px; display: flex; align-items: center; gap: 4px;"><span>âœ…</span><span>Zero commitment</span></div>

          <div style="font-size: 16px; display: flex; align-items: center; gap: 4px;"><span>âœ…</span><span>Zero panic</span></div>

          <div style="font-size: 16px; display: flex; align-items: center; gap: 4px;"><span>âœ…</span><span>Zero F's given</span></div>

        </div>

        <button onclick="handleQuickFixClick()" style="background: #ff6b00; color: white; border: none; padding: 12px 24px; border-radius: 6px; font-weight: 700; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; margin-bottom: 12px;"><span>âš¡</span><span>Unlock QuickFix -$1.99</span></button>

        <p style="font-size: 13px; margin: 0; color: #6b7280;">Only $1.99 for peace of mind ðŸ¤</p>

      </div>

    </div>





    <!-- ===== UPSELL SECTION ===== -->

    <!-- MOVED TO LOCKBOX OVERLAY - This section is now hidden -->

    <div id="freeUpsellSection" class="card" style="display: none; padding: 20px; background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; text-align: center; margin-bottom: 20px;">

      <h3 id="freeUpsellHeading" style="color: #fff; font-weight: 800; font-size: 22px; margin: 0 0 12px 0; display: flex; align-items: center; justify-content: center; gap: 8px;">

        <span id="freeUpsellHeadingText">ðŸ’Ž Go Pro and Chill...</span>

      </h3>

      <p id="freeUpsellText" style="color: #fff; font-size: 13px; margin: 0 0 12px 0; line-height: 1.5;">

        100 monthly scans â€¢ Catch ALL triggers before your prof does â€¢ 1,500 word limit

      </p>

      <button onclick="handleProUpgrade()" style="background: white; color: #00a8e8; border: none; padding: 10px 20px; border-radius: 8px; font-weight: 700; font-size: 13px; cursor: pointer; width: 100%;">

        â†’ Get Pro - $9.99/mo

      </button>

    </div>



<!-- ===== FOOTER BUTTONS ===== -->

    <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">

      <button id="scanAnotherEssayBtn" onclick="scanNewText()" style="padding: 12px 20px; font-size: 13px; font-weight: 600; border-radius: 8px; cursor: pointer; background: white; border: 2px solid #2ecc71; color: #2ecc71; flex: 1; min-width: 140px;">

        ðŸ“ Scan Another Essay

      </button>

      <button onclick="minimizeResults()" style="padding: 12px 20px; font-size: 13px; font-weight: 600; border-radius: 8px; cursor: pointer; background: white; border: 1px dashed #0b0646 !important; color: #0b0646; flex: 1; min-width: 140px;">

        ðŸ  Back To Main Dashboard

      </button>

    </div>



  </div>

</div>



<!-- Stripe Payment Modal -->

<div id="stripePaymentModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100vh;background:rgba(0,0,0,0.8);z-index:10000;align-items:center;justify-content:center;flex-direction:column;">

  <div style="background:#fff;padding:40px;border-radius:20px;max-width:500px;width:90%;position:relative;max-height:90vh;overflow-y:auto;">

    <button onclick="closeStripePaymentModal()" style="position:absolute;top:15px;right:15px;background:none;border:none;font-size:32px;color:#999;cursor:pointer;padding:5px 15px;line-height:1;border-radius:50%;transition:all 0.3s;" onmouseover="this.style.color='#dc2626'; this.style.background='#fee2e2';" onmouseout="this.style.color='#999'; this.style.background='none';">Ã—</button>



    <h2 style="color:#1e3a8a;margin:0 0 10px;font-size:1.8em;font-weight:800;">ðŸ’Ž Upgrade to Pro</h2>

    <p style="color:#666;margin:0 0 25px;font-size:1em;line-height:1.4;">100 scans and fixes/month â€¢ Deeper AI fixes powered by Claude Haiku â€¢ Priority chat support â€¢ Cancel anytime</p>



    <div style="background:#f8f9fa;border-radius:12px;padding:20px;margin-bottom:20px;">

      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">

        <span style="color:#0b0646;font-weight:600;">Pro Subscription</span>

        <span style="color:#0b0646;font-size:24px;font-weight:800;">$9.99/mo</span>

      </div>

      <p style="color:#6b7280;font-size:13px;margin:0;">Billed monthly â€¢ Cancel anytime</p>

    </div>



    <!-- Stripe Payment Form -->

    <form id="stripePaymentForm">

      <div id="stripeCardElement" style="padding:15px;border:2px solid #e5e7eb;border-radius:8px;margin-bottom:20px;">

        <!-- Stripe Elements will mount here -->

      </div>

      <div id="stripeCardErrors" role="alert" style="color:#dc2626;font-size:14px;margin-bottom:15px;min-height:20px;"></div>



      <button type="submit" id="stripeSubmitBtn" class="btn-success btn-block" style="padding:15px;font-size:16px;font-weight:600;margin-bottom:15px;">

        Subscribe for $9.99/month

      </button>



      <div class="stripe-badge" style="text-align:center;font-size:12px;color:#6b7280;">

        ðŸ”’ Secure payment by <span class="stripe-logo" style="color:#635bff;font-weight:700;">Stripe</span>

      </div>

    </form>

  </div>

</div>



<!-- Update Payment Modal -->

<div id="updatePaymentModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100vh;background:rgba(0,0,0,0.8);z-index:10000;align-items:center;justify-content:center;flex-direction:column;">

  <div style="background:#fff;padding:40px;border-radius:20px;max-width:500px;width:90%;position:relative;">

    <button onclick="closeUpdatePaymentModal()" style="position:absolute;top:15px;right:15px;background:none;border:none;font-size:32px;color:#999;cursor:pointer;padding:5px 15px;line-height:1;border-radius:50%;transition:all 0.3s;" onmouseover="this.style.color='#dc2626'; this.style.background='#fee2e2';" onmouseout="this.style.color='#999'; this.style.background='none';">Ã—</button>



    <h2 style="color:#1e3a8a;margin:0 0 10px;font-size:1.8em;font-weight:800;">ðŸ’³ Update Payment Method</h2>

    <p style="color:#666;margin:0 0 25px;font-size:1em;">Update your payment information</p>



    <form id="updatePaymentForm">

      <div id="updateCardElement" style="padding:15px;border:2px solid #e5e7eb;border-radius:8px;margin-bottom:20px;">

        <!-- Stripe Elements will mount here -->

      </div>

      <div id="updateCardErrors" role="alert" style="color:#dc2626;font-size:14px;margin-bottom:15px;min-height:20px;"></div>



      <button type="submit" class="btn-success btn-block" style="padding:15px;font-size:16px;font-weight:600;">

        Update Payment Method

      </button>

    </form>

  </div>

</div>



<!-- Essay Too Long Modal -->

<div id="essayTooLongModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background: rgba(0, 0, 0, 0.7); display: none; align-items: center; justify-content: center; z-index: 9999;">

  <div style="background: white; padding: 32px 24px; border-radius: 12px; max-width: 400px; text-align: center;">

    <img src="https://i.postimg.cc/43BxxmMf/ls-sitting-on-book.png" alt="Lil Sus" style="width: 80px; height: auto; margin-bottom: 16px; display: block; margin-left: auto; margin-right: auto;">



    <h2 style="font-size: 20px; font-weight: 800; color: #1e3a8a; margin: 0 0 12px 0;">Essay too thicc</h2>



    <p style="color: #6b7280; font-size: 14px; margin: 0 0 8px 0; line-height: 1.6;">

      You're at <span id="essayTooLongCharCount" style="font-weight: 700; color: #0b0646;">1,544</span> chars â€¢ Free tier taps out at 500

    </p>



    <p style="color: #9ca3af; font-size: 13px; margin: 0 0 24px 0;">

      Unlock QuickFix or Pro to scan up to 1,500 words no cap ðŸ”“

    </p>



    <button onclick="handleQuickFixClick()" style="width: 100%; padding: 12px 20px; margin-bottom: 8px; background: #ff9500; color: white; border: none; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">

      âš¡ QuickFix It ($1.99)

    </button>



    <button onclick="handleProUpgrade()" style="width: 100%; padding: 12px 20px; margin-bottom: 8px; background: #0ea5e9; color: white; border: none; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer;">

      ðŸ’Ž Go Pro ($9.99/mo)

    </button>



    <button onclick="scanFirst500Chars()" style="width: 100%; padding: 12px 20px; background: #f3f4f6; color: #6b7280; border: none; border-radius: 8px; font-weight: 600; font-size: 14px; cursor: pointer;">

      Nah, trim it down

    </button>

  </div>

</div>



<!-- Cancel Subscription Modal -->

<div id="cancelSubscriptionModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100vh;background:rgba(0,0,0,0.8);z-index:10000;align-items:center;justify-content:center;flex-direction:column;">

  <div style="background:#fff;padding:40px;border-radius:20px;max-width:500px;width:90%;position:relative;text-align:center;">

    <button onclick="closeCancelSubscriptionModal()" style="position:absolute;top:15px;right:15px;background:none;border:none;font-size:32px;color:#999;cursor:pointer;padding:5px 15px;line-height:1;border-radius:50%;transition:all 0.3s;" onmouseover="this.style.color='#dc2626'; this.style.background='#fee2e2';" onmouseout="this.style.color='#999'; this.style.background='none';">Ã—</button>



    <h2 style="color:#1e3a8a;margin:0 0 15px;font-size:1.8em;font-weight:800;">Cancel Subscription?</h2>

    <p style="color:#666;margin:0 0 25px;font-size:1em;line-height:1.5;">Your Pro access will continue until <span id="cancelEndDate" style="font-weight:600;">Dec 15, 2024</span>. After that, you'll lose access to all Pro features.</p>



    <div style="display:flex;gap:15px;justify-content:center;margin-top:30px;">

      <button onclick="closeCancelSubscriptionModal()" class="btn-outline" style="padding:12px 30px;">

        Keep Subscription

      </button>

      <button onclick="confirmCancelSubscription()" class="btn-success" style="padding:12px 30px;background:#dc2626;border-color:#dc2626;">

        Yes, Cancel

      </button>

    </div>

  </div>

</div>

<script>

// Sample data - replace with your actual data

const sampleData = {

  originalScore: 75,

  newScore: 17,

  flagsFixed: 12,

  wordsChanged: 847,

  sentencesRewritten: 23,

  originalEssay: "The cutting-edge technology landscape demonstrates unprecedented levels of innovation. Furthermore, organizations must leverage their resources to achieve significant competitive advantages in the marketplace. Thus, it is important to note that comprehensive analysis reveals multifaceted approaches to problem-solving.\n\nMoreover, the data suggests that various industries are experiencing considerable transformation. Consequently, stakeholders must utilize state-of-the-art methodologies to navigate these changes effectively.",

  rewriteEssay: "Modern tech shows incredible innovation. Companies need to use their resources smartly to stay ahead. A closer look shows there are many ways to solve problems.\n\nAlso, evidence shows that different industries are changing fast. Decision-makers should use modern methods to handle these shifts well.",

  flags: [

    {

      original: "cutting-edge",

      fixed: "modern",

      explanation: "AI detectors flag this as overly formal and commonly used by ChatGPT"

    },

    {

      original: "unprecedented levels",

      fixed: "incredible",

      explanation: "This phrase screams AI - it's one of the most flagged phrases"

    },

    {

      original: "Furthermore",

      fixed: "Also",

      explanation: "Formal transitions like this are AI red flags. More casual = more human"

    },

    {

      original: "leverage",

      fixed: "use",

      explanation: "Corporate buzzword that AI loves. Simple words are more natural"

    },

    {

      original: "significant",

      fixed: "(removed)",

      explanation: "Filler word that adds no value. Humans are more direct"

    },

    {

      original: "it is important to note",

      fixed: "note that",

      explanation: "Classic AI padding phrase. Get straight to the point"

    },

    {

      original: "comprehensive analysis",

      fixed: "closer look",

      explanation: "Too formal. Real students use simpler language"

    },

    {

      original: "multifaceted approaches",

      fixed: "many ways",

      explanation: "Academic jargon that screams bot. Keep it conversational"

    },

    {

      original: "Moreover",

      fixed: "Also",

      explanation: "Another formal transition. Vary your connectors naturally"

    },

    {

      original: "various",

      fixed: "different",

      explanation: "Generic descriptor that AI overuses"

    },

    {

      original: "considerable",

      fixed: "fast",

      explanation: "Vague adjective. Be more specific and direct"

    },

    {

      original: "utilize",

      fixed: "use",

      explanation: "Unnecessarily fancy word. Simple = human"

    }

  ]

};

// Initialize the page with REAL data from appState

function initializeStep4Page() {

  // Use actual data from appState instead of hardcoded sampleData

  const originalScore = appState.quickfixOriginalScore || 75;

  const newScore = appState.quickfixNewScore || 17;

  const flagsFixed = appState.quickfixFlags ? appState.quickfixFlags.length : 0;

  const originalText = appState.quickfixOriginalText || '';

  const fixedText = appState.quickfixFixedText || '';



  // Only update elements that actually exist

  const scoreDrop = document.getElementById('scoreDrop');

  if (scoreDrop) scoreDrop.textContent = (originalScore - newScore) + '%';



  const scoreBefore = document.getElementById('scoreBefore');

  if (scoreBefore) scoreBefore.textContent = originalScore + '%';



  const scoreAfter = document.getElementById('scoreAfter');

  if (scoreAfter) scoreAfter.textContent = newScore + '%';



  // Set dynamic tier labels

  const scoreBeforeLabel = document.getElementById('scoreBeforeLabel');

  if (scoreBeforeLabel) {

    if (originalScore >= 71) {

      scoreBeforeLabel.textContent = 'Major Sus';

    } else if (originalScore >= 31) {

      scoreBeforeLabel.textContent = 'Mid Sus';

    } else {

      scoreBeforeLabel.textContent = "Low Sus";

    }

  }



  const scoreAfterLabel = document.getElementById('scoreAfterLabel');

  if (scoreAfterLabel) {

    if (newScore >= 71) {

      scoreAfterLabel.textContent = 'Major Sus';

    } else if (newScore >= 31) {

      scoreAfterLabel.textContent = 'Mid Sus';

    } else {

      scoreAfterLabel.textContent = "Low Sus";

    }

  }



  const flagCount = document.getElementById('flagCount');

  if (flagCount) flagCount.textContent = flagsFixed;



  const modalFlagCount = document.getElementById('modalFlagCount');

  if (modalFlagCount) modalFlagCount.textContent = flagsFixed;



  const proFlags = document.getElementById('proFlags');

  if (proFlags) proFlags.textContent = flagsFixed;



  const flagsFixedCount = document.getElementById('flagsFixedCount');

  if (flagsFixedCount) flagsFixedCount.textContent = flagsFixed;



  const scoreImprovement = document.getElementById('scoreImprovement');

  if (scoreImprovement) scoreImprovement.textContent = (originalScore - newScore) + '%';



  const aiTriggerFreeScore = document.getElementById('aiTriggerFreeScore');

  if (aiTriggerFreeScore) aiTriggerFreeScore.textContent = '100%';



  // Update big score display

  const bigScoreBefore = document.getElementById('bigScoreBefore');

  if (bigScoreBefore) bigScoreBefore.textContent = originalScore + '%';



  const bigScoreAfter = document.getElementById('bigScoreAfter');

  if (bigScoreAfter) bigScoreAfter.textContent = newScore + '%';



  const bigScoreImprovement = document.getElementById('bigScoreImprovement');

  if (bigScoreImprovement) {

    const improvement = originalScore - newScore;

    bigScoreImprovement.textContent = `ðŸš€ ${improvement}% Score Drop!`;

  }



  const meterFill = document.getElementById('meterFill');

  if (meterFill) {

    meterFill.style.width = newScore + '%';

    // Update the text inside the progress bar

    const meterText = meterFill.querySelector('span');

    if (meterText) meterText.textContent = newScore + '%';

  }



  // CRITICAL FIX: Don't touch Step 3 essay elements!

  // displayQuickFixResults() is called for Step 4, but Step 3 also has elements with same IDs

  // We MUST check if we're in Step 4 before modifying any essay elements

  // Step 3's essay elements are managed by displayStep3Results() - don't interfere!



  // Only populate Step 4 elements (they're inside #quickfixStep4)

  const rewriteEssay = document.getElementById('rewriteEssay');

  if (rewriteEssay && rewriteEssay.closest('#quickfixStep4')) {

    rewriteEssay.innerHTML = formatEssay(fixedText);

  }



  // DO NOT touch originalEssay, fixedEssay, or diffEssay - they're Step 3 elements!

  // displayStep3Results() will populate them correctly



  // Update dynamic text based on actual flag counts - check Pro mode

  const isPro = appState.isProUser || false;

  const step4HeroText = document.getElementById('step4HeroText');

  if (step4HeroText) {

    if (isPro) {

      step4HeroText.innerHTML = `ðŸ’Ž Pro found all ${flagsFixed} AI-trigger words! All fixed.<br>Ready to TURN IT IN.`;

    } else {

      step4HeroText.innerHTML = `QuickFix found all ${flagsFixed} AI-trigger words! All fixed.<br>Ready to TURN IT IN.`;

    }

  }



  const step4ProText = document.getElementById('step4ProText');

  if (step4ProText) {

    if (isPro) {

      step4ProText.textContent = `ðŸ’Ž Pro found all ${flagsFixed} AI-trigger words in your essay and fixed them all!`;

    } else {

      step4ProText.textContent = `QuickFix found all ${flagsFixed} AI-trigger words in your essay and fixed them all!`;

    }

  }



  // Set premium header for Pro users

  if (isPro) {

    const rotatingMessage = document.getElementById('rotatingMessage');

    if (rotatingMessage) {

      rotatingMessage.textContent = 'ðŸ’Ž Premium Results - Every Flag Found & Fixed âœ¨';

    }

  }



  renderStep4FlagsList();

}



function formatEssay(text) {

  return text.split('\n\n').map(p => `<p>${p}</p>`).join('');

}



function formatEssayWithFlags(text, flags) {

  console.log('formatEssayWithFlags called with:', { text, flags });

  let formatted = text;

  flags.forEach((flag, index) => {

    console.log('Processing flag:', flag);

    const regex = new RegExp(flag.phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

    formatted = formatted.replace(regex, `<span class="flag-removed" title="${flag.explanation}">${flag.phrase}</span>`);

  });

  console.log('Formatted result:', formatted);

  return formatted.split('\n\n').map(p => `<p>${p}</p>`).join('');

}



function generateDiffView(text, flags) {

  let formatted = text;

  flags.forEach((flag, index) => {

    const regex = new RegExp(flag.phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

    formatted = formatted.replace(regex, 

      `<span class="flag-removed">${flag.phrase}</span> <span class="flag-fixed">${flag.suggestedFix}</span>`

    );

  });

  return formatted.split('\n\n').map(p => `<p>${p}</p>`).join('');

}



// Build diff view with highlighting for Step 3

function buildDiffView(data) {

  const diffEl = document.getElementById('diffEssay');



  if (!data || !data.flags || !diffEl) {

    console.log('Missing data for diff view');

    return;

  }



  // Helper function to escape HTML

  const escapeHtml = (text) => {

    const div = document.createElement('div');

    div.textContent = text;

    return div.innerHTML;

  };



  const flags = data.flags;

  let diffHTML = data.fixedEssay || '';



  console.log('Building diff with:', flags.length, 'flags');



  // First, create a map of each flag with its original index (for numbering)

  // This ensures numbering matches the dropdown order exactly

  const flagInfoMap = new Map();

  flags.forEach((flag, originalIndex) => {

    const replacement = flag.replacement || flag.suggestedFix;

    const original = flag.original || flag.phrase;

    if (replacement && original) {

      // Store flag info with original index (1-based for display)

      flagInfoMap.set(originalIndex, {

        flag: flag,

        original: original,

        replacement: replacement,

        flagNumber: originalIndex + 1, // Number for dropdown (1-based)

        severity: flag.severity || flag.risk || flag.type || 'medium'

      });

    }

  });



  // Sort flags by replacement length (longest first) to avoid nested replacements

  // But we'll use the original index from flagInfoMap for numbering

  const sortedFlags = [...flags].map((flag, originalIndex) => ({

    flag: flag,

    originalIndex: originalIndex

  })).sort((a, b) => {

    const aReplacement = (a.flag.replacement || a.flag.suggestedFix || '').length;

    const bReplacement = (b.flag.replacement || b.flag.suggestedFix || '').length;

    return bReplacement - aReplacement;

  });



  // For each flag, show original (red/strikethrough) + replacement (green) with numbered badge

  sortedFlags.forEach((sortedFlag) => {

    const flagInfo = flagInfoMap.get(sortedFlag.originalIndex);

    if (!flagInfo) return;



    const { original, replacement, flagNumber, severity } = flagInfo;



    // Use light green background with dark green numbering

    const circleBg = '#C8E6C9'; // Light green background

    const circleTextColor = '#059669'; // Dark green text



    const escapedReplacement = replacement.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    // Match replacement as whole word(s), optionally followed by punctuation (comma, period, etc.)

    const regex = new RegExp(`(\\b${escapedReplacement}\\b)(?=[\\s,.]|$)`, 'g');



    diffHTML = diffHTML.replace(regex, (match) => {

      // Check if already wrapped (avoid double-wrapping)

      if (match.includes('<span')) return match;



      // Show original (red/strikethrough) + replacement (green) with badge

      return `<span style="text-decoration: line-through; background-color: #fee2e2; color: #dc2626; padding: 2px 4px; border-radius: 3px; display: inline;">${escapeHtml(original)}</span><span style="background-color: #d1fae5; color: #10b981; font-weight: 600; padding: 2px 4px; border-radius: 3px; display: inline;">${escapeHtml(replacement)}<sup style="background: ${circleBg}; color: ${circleTextColor}; border-radius: 50%; width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 700; margin-left: 2px; vertical-align: super; line-height: 1; flex-shrink: 0; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'" title="Click to see fix details">${flagNumber}</sup></span>`;

    });

  });



  diffEl.innerHTML = diffHTML;

  console.log('Diff view set with original (red) + replacement (green) and numbered badges, final length:', diffEl.innerHTML.length);

}



function renderStep4FlagsList() {

  const container = document.getElementById('step4FlagsList');

  const flags = appState.quickfixFlags || [];

  const html = flags.map((flag, index) => `

    <div class="flag-item">

      <div class="flag-number">${index + 1}</div>

      <div class="flag-details">

        <div class="flag-change">

          <span class="flag-original">"${flag.phrase}"</span>

          <span class="flag-arrow">â†’</span>

          <span class="flag-new">"${flag.suggestedFix}"</span>

        </div>

        <div class="flag-explanation">

          <strong>Why I fixed it:</strong> ${flag.explanation}

        </div>

      </div>

    </div>

  `).join('');

  container.innerHTML = html;

}



function showVersion(version) {

  console.log('ðŸ”„ showVersion called with:', version);



  // Hide all essay views with !important to override inline CSS

  const originalEssay = document.getElementById('originalEssay');

  const fixedEssay = document.getElementById('fixedEssay');

  const diffEssay = document.getElementById('diffEssay');



  console.log('Elements found:', {

    original: !!originalEssay,

    fixed: !!fixedEssay,

    diff: !!diffEssay

  });



  // Hide all with !important

  if (originalEssay) {

    originalEssay.style.setProperty('display', 'none', 'important');

    console.log('Hidden originalEssay with !important');

  }

  if (fixedEssay) {

    fixedEssay.style.setProperty('display', 'none', 'important');

    console.log('Hidden fixedEssay with !important');

  }

  if (diffEssay) {

    diffEssay.style.setProperty('display', 'none', 'important');

    console.log('Hidden diffEssay with !important');

  }



  // Show selected view with !important to override inline CSS

  const copyButton = document.getElementById('copyFixedEssayButton');



  if (version === 'original' && originalEssay) {

    originalEssay.style.setProperty('display', 'block', 'important');

    if (copyButton) copyButton.style.display = 'none';

    console.log('âœ… Showing originalEssay with !important, content length:', originalEssay.textContent.length);

  } else if (version === 'fixed' && fixedEssay) {

    fixedEssay.style.setProperty('display', 'block', 'important');

    if (copyButton) copyButton.style.display = 'block';

    console.log('âœ… Showing fixedEssay with !important, content length:', fixedEssay.textContent.length);

  } else if (version === 'diff' && diffEssay) {

    diffEssay.style.setProperty('display', 'block', 'important');

    if (copyButton) copyButton.style.display = 'none';

    console.log('âœ… Showing diffEssay with !important, content length:', diffEssay.textContent.length);

  }



  // Update button styles

  const buttons = document.querySelectorAll('.toggle-btn');

  buttons.forEach(btn => {

    btn.style.borderColor = '#e5e7eb';

    btn.style.background = 'white';

    btn.style.color = '#374151';

    btn.classList.remove('active');

  });



  // Highlight active button - all buttons use white with dark blue border when active

  // Button order: 0 = fixed, 1 = diff, 2 = original

  const buttonIndex = version === 'fixed' ? 0 : version === 'diff' ? 1 : 2;

  const activeButton = buttons[buttonIndex];

  if (activeButton) {

    // All buttons use white background with dark blue border when active

    activeButton.style.borderColor = '#003d7a';

    activeButton.style.borderWidth = '2px';

    activeButton.style.background = 'white';

    activeButton.style.color = '#003d7a';

    activeButton.classList.add('active');

    console.log('âœ… Button', buttonIndex, 'activated');

  }

}



function copyFullDeFlag() {

  const textToCopy = appState.quickfixFixedText || '';

  if (textToCopy) {

    navigator.clipboard.writeText(textToCopy).then(() => {

      showSuccessMessage('âœ… Essay copied to clipboard!', '#00a8e8'); // Green for copy button

    }).catch(() => {

      showSuccessMessage('âŒ Failed to copy. Please try again.', '#00a8e8'); // Green for copy button

    });

  } else {

    showSuccessMessage('âŒ No text to copy. Please scan an essay first.', '#00a8e8'); // Green for copy button

  }

}



function downloadDocx() {

  const textToDownload = appState.quickfixFixedText || '';

  if (textToDownload) {

    // Create a simple text file download (Word would require more complex library)

    const blob = new Blob([textToDownload], { type: 'text/plain' });

    const url = window.URL.createObjectURL(blob);

    const a = document.createElement('a');

    a.href = url;

    a.download = 'pro-fixed-essay.txt';

    document.body.appendChild(a);

    a.click();

    document.body.removeChild(a);

    window.URL.revokeObjectURL(url);

    showSuccessMessage('âœ… Essay downloaded as text file!', '#2ecc71'); // Blue for download button

  } else {

    showSuccessMessage('âŒ No text to download. Please scan an essay first.', '#2ecc71'); // Blue for download button

  }

}



function openStep4FlagsModal() {

  // Populate the modal with the flagged words list

  const flagsList = document.getElementById('step4FlagsList');

  const flagCount = document.getElementById('modalFlagCount');



  if (flagsList && appState.quickfixFlags) {

    let flagsHtml = '';

    appState.quickfixFlags.forEach((flag, index) => {

      flagsHtml += `

        <div class="flag-item" style="display: flex; justify-content: space-between; align-items: center; padding: 12px; margin: 8px 0; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #dc2626;">

          <div style="flex: 1;">

            <div style="font-weight: 600; color: #dc2626; margin-bottom: 4px;">"${flag.phrase}"</div>

            <div style="font-size: 14px; color: #6b7280;">â†’ "${flag.suggestedFix}"</div>

            <div style="font-size: 12px; color: #9ca3af; margin-top: 4px;">${flag.explanation}</div>

          </div>

          <div style="background: #dc2626; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 700;">

            ${index + 1}

          </div>

        </div>

      `;

    });



    flagsList.innerHTML = flagsHtml;

    flagCount.textContent = appState.quickfixFlags.length;

  }



  document.getElementById('step4FlagsModal').classList.add('show');

  document.body.classList.add('modal-open');

}



function closeStep4FlagsModal() {

  document.getElementById('step4FlagsModal').classList.remove('show');

  document.body.classList.remove('modal-open');

}



function copyStep4FlagsList() {

  if (!appState.quickfixFlags) return;



  let flagsText = 'Flags Fixed:\n\n';

  appState.quickfixFlags.forEach((flag, index) => {

    flagsText += `${index + 1}. "${flag.phrase}" â†’ "${flag.suggestedFix}"\n   ${flag.explanation}\n\n`;

  });



  navigator.clipboard.writeText(flagsText).then(() => {

    showStep4Toast('Flags list copied!', 'download');

  }).catch(() => {

    showStep4Toast('Copy failed', 'error');

  });

}





function showStep4Toast(message, type = 'success') {

  const toast = document.getElementById('step4SuccessToast');

  toast.textContent = message;

  toast.className = 'success-toast'; // Reset classes

  if (type === 'download') {

    toast.classList.add('download-toast');

  } else {

    toast.classList.add('success-toast');

  }

  toast.classList.add('show');

  setTimeout(() => {

    toast.classList.remove('show');

  }, 3000);

}



// Initialize Step 4 when shown

function showFullDeFlagPage() {

  console.log('ðŸ”„ Showing Pro Scan Page (Step 4)');

  showQuickFixStep(4);

  initializeStep4Page();



  // Update labels if in Pro mode

  if (appState.isProUser) {

    setTimeout(() => {

      updateStepLabels(true);

    }, 100);

  }



  // Scroll to top of the form

  setTimeout(() => {

    window.scrollTo({ top: 0, behavior: 'smooth' });

  }, 100);



  // No upsell popup for Pro members - they already have Pro!

}



// Gen Z Upsell Popup for Step 4

function showGenZUpsellPopup() {

  // Don't show upsell popup for Pro users - they already have Pro!

  if (appState.isProUser || (appState.proSubscription && appState.proSubscription.active)) {

    return;

  }



  const modal = document.createElement('div');

  modal.id = 'genzUpsellModal';

  modal.style.cssText = `

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background: rgba(0, 0, 0, 0.5);

    display: flex;

    justify-content: center;

    align-items: center;

    z-index: 10000;

    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

  `;



  const popup = document.createElement('div');

  popup.style.cssText = `

    background: white;

    border-radius: 16px;

    padding: 30px;

    max-width: 400px;

    width: 90%;

    text-align: center;

    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);

    position: relative;

  `;



  popup.innerHTML = `

    <button onclick="document.getElementById('genzUpsellModal').remove(); document.body.classList.remove('modal-open');" 

            style="position: absolute; top: 15px; right: 20px; background: none; border: none; font-size: 24px; color: #999; cursor: pointer; padding: 5px">Ã—</button>



    <div style="font-size: 48px; margin-bottom: 15px;">ðŸ˜</div>



    <h2 style="color: #1f2937; margin: 0 0 15px; font-size: 24px; font-weight: 800;">

      Aren't you glad you used the Pro fix?

    </h2>



    <p style="color: #6b7280; margin: 0 0 20px; font-size: 16px; line-height: 1.5;">

      Bestie, that was just <strong>ONE</strong> Pro scan... imagine having <strong>500</strong>! ðŸ”¥

    </p>



    <p style="color: #374151; margin: 0 0 25px; font-size: 14px; line-height: 1.4;">

      Get Pro & Chill - never stress about AI detection again! ðŸ’Ž

    </p>



    <div style="display: flex; flex-direction: column; gap: 12px;">

      <button onclick="document.getElementById('genzUpsellModal').remove(); document.body.classList.remove('modal-open'); window.open('/pro', '_blank');" 

              style="background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none; padding: 15px 25px; border-radius: 12px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s;">

        ðŸ’Ž Get Pro & Chill - $9.99/mo

      </button>



      <button onclick="document.getElementById('genzUpsellModal').remove(); document.body.classList.remove('modal-open');" 

              style="background: #f3f4f6; color: #6b7280; border: none; padding: 12px 25px; border-radius: 12px; font-size: 14px; cursor: pointer; transition: all 0.2s;">

        Maybe Later

      </button>

    </div>

  `;



  modal.appendChild(popup);

  document.body.appendChild(modal);

  document.body.classList.add('modal-open');



  // Close on outside click

  modal.addEventListener('click', function(e) {

    if (e.target === modal) {

      modal.remove();

      document.body.classList.remove('modal-open');

    }

  });

}



const FREE_SCAN_LIMIT = 50; // 50 free scans for testing (was 3)



// NEW: Dynamic messaging system

const dynamicMessages = {

  susFree: {

    headers: [

      "No cap, it's lookin' way cleaner ðŸ‘Œ",

      "Fam, this is looking fire ðŸ”¥",

      "Bestie, you're in the clear ðŸ™Œ",

      "This essay is professor-ready ðŸ’¯",

      "Clean as a whistle! Ready to turn it in âœ¨",

      "Fam, this is absolutely slaying ðŸš€"

    ],

    subtitle: "Your essay just got a glow-up. Flag drop confirmed. âœ¨",

    message: "That's a solid glow-up â€” ${improvement}% less sus! âœ¨",

    ctaText: "This essay is professor-ready! But if you want perfection, Pro scan is free!"

  },

  kindaSus: {

    headers: [

      "Not totally sus, but could be cleaner ðŸ¤”",

      "You're in the safe zone, but let's make it bulletproof ðŸ›¡ï¸",

      "Fam, this is borderline - let's fix it ðŸŽ¯",

      "Almost there, but your prof might still clock it ðŸ‘€",

      "This needs a little more work before turning in âœ¨",

      "Bestie, let's make this 100% professor-proof ðŸ’¯"

    ],

    subtitle: "You're in the safe zone, but let's make it 100% false flag free",

    message: "A few tweaks away from being totally undetectable â€” ${improvement}% improvement",

    ctaText: "Almost there, but your prof might still clock it. Pro scan is free!"

  },

  susAf: {

    headers: [

      "Oof, this is way too sus for your prof ðŸ˜¬",

      "Yikes, this is looking sus af ðŸš¨",

      "Fam, this is screaming AI-generated ðŸ“¢",

      "Bestie, this needs serious work before turning in ðŸš©",

      "This essay is in the danger zone ðŸš¨",

      "Fam, you're gonna get caught with this one ðŸ”"

    ],

    subtitle: "Let's make this 100% false flag free before turning in",

    message: "AI detectors would flag this for sure ðŸ˜¬ â€” only ${improvement}% improvement",

    ctaText: "Fam, this is way too sus for your prof. Pro scan is free!"

  }

};



// Lil' Sus phrases for different score ranges

const lilSusPhrases = {

  lowRisk: [

    "You're in the clear ðŸ™Œ â€“ nothing sus here.",

    "Clean as a whistle! Ready to turn it in ðŸ’¯",

    "No red flags detected â€“ you're good to go! ðŸŽ‰",

    "This essay is looking human AF â€“ submit with confidence!",

    "Zero AI vibes detected â€“ you're all clear! âœ¨"

  ],

  mediumRisk: [

    "Hmm... lil sus not gonna lie ðŸ‘€. Could go either way.",

    "A few sketchy spots but you might get away with it ðŸ¤ž",

    "Borderline vibes â€“ some parts might raise eyebrows",

    "Not totally sus but not totally safe either ðŸ˜",

    "Could pass as human... or could get flagged âš–ï¸"

  ],

  highRisk: [

    "Yikes. This one's mad sus ðŸ˜¬. Proceed with caution.",

    "ðŸš¨ MAJOR AI VIBES DETECTED! Don't submit this yet!",

    "This is screaming AI to detectors â€“ high risk of getting flagged!",

    "Too many AI markers â€“ this needs fixing!",

    "Your professor would flag this in seconds â°"

  ]

};



var appState = {

  maxChars: 500, // Free version limited to 500 characters

  minChars: 50,

  scansUsed: 0,

  originalText: '',

  lastClickedFixOption: null, // Track the last clicked fix option for banner pointer

  flagData: [],

  currentScore: 0,

  isProUser: false,

  hasUnlimitedFixes: false,

  freeRewritesUsed: 0,

  maxFreeRewrites: 1,

  isQuickFixUser: false,

  quickfixOriginalText: '',

  quickfixFlags: [],

  quickfixOriginalScore: 0,

  quickfixFixedText: '',

  quickfixNewScore: 0,

  quickfixBonusRescanUsed: false, // Bonus Rescan card: hide on return once used (Kinda/Hella Sus Step 3 only)

  lastClickedFixOption: null, // Track the last clicked fix option element for banner pointer

  // Pro scan data

  proOriginalText: '',

  proFlags: [],

  proOriginalScore: 0,

  proFixedText: '',

  proNewScore: 0,

  // Pro subscription tracking

  proSubscription: {

    active: false,

    scansUsed: 0,

    scansLimit: 500,

    nextBillingDate: null,

    paymentMethod: null,

    subscriptionId: null

  },

  stripe: null, // Stripe instance

  stripeCardElement: null, // Stripe card element

  stripeUpdateCardElement: null, // Stripe update card element

  stripeConfigured: null // Whether Stripe is properly configured (null = not checked, false = not configured, true = configured)

};

// NEW: Dynamic CTA system

function getDynamicCTAs(score) {

  let ctas = '';



  if (score <= 30) { // You're Good

    ctas = 

      `<button class="btn-primary" onclick="copyQuickFixResult()">âœ… Copy Fixed Text</button>

      <button class="btn-outline" onclick="showProUpsell()">ðŸ’Ž Go Pro</button>

      <button class="btn-outline" onclick="scanNewText()">ðŸ“ Scan Another Essay</button>

      <button class="btn-outline" onclick="hideQuickFixFlow()" style="border: 1px dashed #0b0646 !important; color: #0b0646;">ðŸ  Back To Main Dashboard</button>`;

  } else if (score > 30 && score < 70) { // Kinda Sus (31-69)

    ctas = 

      `<button class="btn-primary" onclick="copyQuickFixResult()">âœ… Copy Fixed Text</button>

      <button class="btn-outline" onclick="scanNewText()">ðŸ“ Scan Another Essay</button>

      <button class="btn-outline" onclick="hideQuickFixFlow()" style="border: 1px dashed #0b0646 !important; color: #0b0646;">ðŸ  Back To Main Dashboard</button>`;

  } else { // Hella Sus

    ctas = 

      `<button class="btn-primary" onclick="copyQuickFixResult()">âœ… Copy Fixed Text</button>

      <button class="btn-outline" onclick="scanNewText()">ðŸ“ Scan Another Essay</button>

      <button class="btn-outline" onclick="hideQuickFixFlow()" style="border: 1px dashed #0b0646 !important; color: #0b0646;">ðŸ  Back To Main Dashboard</button>`;

  }



  return ctas;

}



// NEW: Dynamic messaging based on score

function updateResultsMessaging(score, improvement, overallScore = null) {

  // CRITICAL: Clear any existing rotation intervals to prevent stacking

  if (window.headerRotationInterval) {

    clearInterval(window.headerRotationInterval);

    window.headerRotationInterval = null;

  }

  if (window._rotationInterval) {

    clearInterval(window._rotationInterval);

    window._rotationInterval = null;

  }



  // Check if elements exist before trying to update them (old Step 3 structure)

  const header = document.getElementById('resultsHeader');

  const subtitle = document.getElementById('resultsSubtitle');

  const message = document.getElementById('resultsMessage');

  const emoji = document.getElementById('resultsEmoji');



  if (!header) {

    // Element doesn't exist in new Step 3 structure - skip silently

    return;

  }

  const ctas = document.getElementById('dynamicCTAs');



  // Add null checks - return early if critical elements don't exist (old Step 3 structure)

  if (!header) {

    // Element doesn't exist in new Step 3 structure - skip silently

    return;

  }



  let messaging;



  if (score <= 30) {

    messaging = dynamicMessages.susFree;

    if (emoji) emoji.textContent = 'âœ…';

  } else if (score >= 30 && score < 70) {

    messaging = dynamicMessages.kindaSus;

    if (emoji) emoji.textContent = 'ðŸ¤”';

  } else {

    messaging = dynamicMessages.susAf;

    if (emoji) emoji.textContent = 'ðŸš¨';

  }



  // Set ALL rotating phrases to dark blue (#1e3a8a) - force with !important

  if (score >= 70) {

    header.style.setProperty('color', '#1e3a8a', 'important'); // Dark blue for Hella Sus headers

  } else if (score >= 30) {

    header.style.setProperty('color', '#1e3a8a', 'important'); // Dark blue for Kinda Sus headers

  } else {

    header.style.setProperty('color', '#1e3a8a', 'important'); // Dark blue for You're Good headers

  }



  // Make subtitle dark blue for all tiers (dynamic rotating phrases) - force with !important

  if (subtitle) {

    subtitle.style.setProperty('color', '#1e3a8a', 'important'); // Dark blue for subtitle

  }



  // Start with first message for the tier

  header.textContent = messaging.headers[0];



  // Reduce font size of dynamic phrases

    header.style.fontSize = '18px';



  // Add padding above resultsHeader container

  const headerContainer = header.closest('.lil-sus-header');

  if (headerContainer) {

    headerContainer.style.paddingTop = '24px';

  }



  // Rotate through messages within the same score tier every 6 seconds

  let currentIndex = 0;

  const rotationInterval = setInterval(() => {

    if (header) {

    currentIndex = (currentIndex + 1) % messaging.headers.length;

    header.textContent = messaging.headers[currentIndex];

    } else {

      clearInterval(rotationInterval);

      if (window._rotationInterval === rotationInterval) {

        window._rotationInterval = null;

      }

    }

  }, 6000);



  // Store interval ID globally so we can clear it if needed

  window._rotationInterval = rotationInterval;

  window.headerRotationInterval = rotationInterval;



  if (subtitle) {

  subtitle.textContent = messaging.subtitle;

  }



  // Update message text - different for Clean vs others

  if (message) {

  if (score <= 30) {

    // Success message for Clean pages

    message.innerHTML = `That's a solid <strong>${improvement}%</strong> glow-up! âœ¨<br>Your essay is looking clean and ready to turn in.`;

  } else {

    // Warning message for Kinda Sus/Hella Sus pages

    message.innerHTML = `Detectors would still roast this ðŸ˜¬ â€” only a <strong>${improvement}%</strong> glow-up so far.<br>Keep fixing to drop your score even lower.`;

  }



  // Set color for resultsMessage on QuickFix summary page based on score

    if (message.id === 'resultsMessage') {

    if (score <= 30) {

      message.style.color = '#2ecc71'; // Green

    } else if (score > 30 && score < 70) {

      message.style.color = '#fbbf24'; // Yellow

    } else {

      message.style.color = '#dc2626'; // Red

      }

    }

  }



  // Update dynamic CTA section based on score tier (use overallScore if provided, otherwise use score)

  updateQuickFixBottomCTA(overallScore || score, improvement);

}

function updateQuickFixBottomCTA(score, improvement) {

  const ctaContainer = document.getElementById('quickfixBottomCTA');

  if (!ctaContainer) return;



  const isPro = appState.isProUser || false;

  let riskLevel, urgencyBanner, pitchTitle, pitchCopy, scoreDisplay, buttons, whatHappens, disclaimer;



  if (score <= 30) {

    // LOW RISK (You're Good)

    riskLevel = 'low-risk';

    urgencyBanner = ``;

    pitchTitle = "";

    pitchCopy = ``;

    scoreDisplay = `Started at: <span>${score + improvement}%</span> | Now: <span>${score}%</span>`;

    disclaimer = "";

    // Clean result: CTAs based on Pro vs QuickFix

    if (isPro) {

      // Pro users: No upsell, different CTAs

    buttons = `

        <button onclick="backToProDashboard()" style="width: 100%; background: white; color: #00a8e8; border: 1px solid #00a8e8; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

          ðŸ“ Scan Another Essay

          </button>

        <button onclick="showProPastFixes()" style="width: 100%; background: white; color: #2ecc71; border: 1px solid #2ecc71; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

          ðŸ“Š View Past Fixes

          </button>

        <button onclick="backToProDashboard()" style="width: 100%; background: white; color: #000000; border: 1px solid #003d7a; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer;">

          ðŸ’Ž Back to Pro Dashboard

        </button>

      `;

    } else {

      // QuickFix users: Include Pro upsell

      buttons = `

        <button onclick="showGetAnotherQuickFixModal();" style="width: 100%; background: white; color: #2ecc71; border: 2px solid #2ecc71; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

            ðŸ“ Scan Another Essay

          </button>

        <div style="background: linear-gradient(to bottom, #00a8e8, #0b0646); border-radius: 16px; padding: 20px 16px; margin: 12px 0; text-align: center; box-shadow: 0 4px 12px rgba(0, 168, 232, 0.2);">

          <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">

            <span style="font-size: 24px;">ðŸš€</span>

            <h3 style="color: white; font-size: 20px; font-weight: 700; margin: 0;">Go Pro and Chill...</h3>

        </div>

          <p style="text-align: center; color: white; font-size: 14px; margin: 0 0 16px 0; line-height: 1.6; opacity: 0.95;">

            You nailed this one. Lock in the wins with Pro â€¢ Catch triggers on EVERY essay before your prof does â€¢ 100 monthly scans â€¢ Stay undefeated

          </p>

          <button onclick="showProUpsell()" style="background: white; color: #00a8e8; border: 1px solid #00a8e8; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); transition: transform 0.2s; margin-bottom: 8px; width: 100%;">

            â†’ Get Pro - $9.99/mo

          </button>

          <div style="text-align: center; color: white; font-size: 10px; opacity: 0.9;">

            Cancel Anytime

        </div>

      </div>

        <button onclick="hideQuickFixFlow()" style="width: 100%; background: white; color: #0b0646; border: 1px dashed #0b0646 !important; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer;">

          ðŸ  Back To Main Dashboard

        </button>

    `;

    }

  } else if (score >= 30 && score < 70) {

    // MEDIUM RISK (Kinda Sus)

    riskLevel = 'medium-risk';

    urgencyBanner = ``;

    pitchTitle = "Almost there, but your prof might still clock it.";

    pitchCopy = ``;

    scoreDisplay = `Your score: <span>${score}%</span> | Pro scan gets you to: <span>20% or below</span>`;



    if (isPro) {

      // Pro users: Get More Fix Suggestions, Scan Another, View Past Fixes, Back to Dashboard

    buttons = `

        <button onclick="editProFixes()" style="width: 100%; background: white; color: #f5a623; border: 1px solid #f5a623; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

          âœï¸ Get More Fix Suggestions

        </button>

        <button onclick="backToProDashboard()" style="width: 100%; background: white; color: #00a8e8; border: 1px solid #00a8e8; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

          ðŸ“ Scan Another Essay

        </button>

        <button onclick="showProPastFixes()" style="width: 100%; background: white; color: #2ecc71; border: 1px solid #2ecc71; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

          ðŸ“Š View Past Fixes

        </button>

        <button onclick="backToProDashboard()" style="width: 100%; background: white; color: #000000; border: 1px solid #003d7a; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer;">

          ðŸ’Ž Back to Pro Dashboard

        </button>

      `;

    } else {

      // QuickFix users: Get Another QuickFix, Pro upsell, Back to Dashboard

      buttons = `

        <button onclick="showGetAnotherQuickFixModal();" style="width: 100%; background: white; color: #2ecc71; border: 2px solid #2ecc71; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

            <span style="color: #ffffff !important; display: inline-block; text-shadow: -1px -1px 0px #ffffff, 1px -1px 0px #ffffff, -1px 1px 0px #ffffff, 1px 1px 0px #ffffff, 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.6); filter: brightness(1) !important; font-weight: bold; -webkit- ">âš¡</span> Get Another QuickFix - $1.99

          </button>

        <div style="background: linear-gradient(to bottom, #00a8e8, #0b0646); border-radius: 16px; padding: 20px 16px; margin: 12px 0; text-align: center; box-shadow: 0 4px 12px rgba(0, 168, 232, 0.2);">

          <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">

            <span style="font-size: 24px;">ðŸš€</span>

            <h3 style="color: white; font-size: 20px; font-weight: 700; margin: 0;">Go Pro and Chill...</h3>

        </div>

          <p style="text-align: center; color: white; font-size: 14px; margin: 0 0 16px 0; line-height: 1.6; opacity: 0.95;">

            100 scans and fixes/month â€¢ Deeper AI fixes powered by Claude Haiku â€¢ Priority chat support â€¢ Cancel anytime

          </p>

          <button onclick="showProUpsell()" style="background: white; color: #00a8e8; border: 1px solid #00a8e8; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); transition: transform 0.2s; margin-bottom: 8px; width: 100%;">

            â†’ Get Pro - $9.99/mo

          </button>

          <div style="text-align: center; color: white; font-size: 10px; opacity: 0.9;">

            Cancel Anytime

        </div>

      </div>

        <button onclick="hideQuickFixFlow()" style="width: 100%; background: white; color: #0b0646; border: 1px dashed #0b0646 !important; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer;">

          ðŸ  Back To Main Dashboard

        </button>

    `;

    }

    disclaimer = "";

  } else {

    // HIGH RISK (Hella Sus)

    riskLevel = 'high-risk';

    urgencyBanner = ``;

    pitchTitle = "";

    pitchCopy = `<div style="text-align: center; margin-bottom: 8px; padding: 16px; background: white; border-radius: 8px; border: 2px solid #dc2626;">

        <p style="margin: 0 0 8px 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">âš ï¸ Your score's still high because some flagged words weren't fixed.</p>

        <p style="margin: 0 0 8px 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">QuickFix only works when you apply the suggested swaps â€” that's how you get the lowest, safest score.</p>

        <p style="margin: 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">Run another QuickFix to finish the clean-up, or go Pro and tweak it till it's chef's kiss. âœ¨</p>

      </div>`;

    scoreDisplay = "";



    if (isPro) {

      // Pro users: Get More Fix Suggestions (very prominent), Scan Another, View Past Fixes, Back to Dashboard

    buttons = `

        <button onclick="editProFixes()" style="width: 100%; background: #f5a623; color: white; border: none; padding: 16px 24px; font-size: 18px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px; box-shadow: 0 4px 12px rgba(245, 166, 35, 0.3);">

          âœï¸ Get More Fix Suggestions

        </button>

        <button onclick="backToProDashboard()" style="width: 100%; background: white; color: #00a8e8; border: 1px solid #00a8e8; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

          ðŸ“ Scan Another Essay

        </button>

        <button onclick="showProPastFixes()" style="width: 100%; background: white; color: #2ecc71; border: 1px solid #2ecc71; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

          ðŸ“Š View Past Fixes

        </button>

        <button onclick="backToProDashboard()" style="width: 100%; background: white; color: #000000; border: 1px solid #003d7a; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer;">

          ðŸ’Ž Back to Pro Dashboard

        </button>

      `;

    } else {

      // QuickFix users: Get Another QuickFix, Pro upsell, Back to Dashboard

      buttons = `

        <button onclick="showGetAnotherQuickFixModal();" style="width: 100%; background: white; color: #2ecc71; border: 2px solid #2ecc71; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer; margin-bottom: 12px;">

            <span style="color: #ffffff !important; display: inline-block; text-shadow: -1px -1px 0px #ffffff, 1px -1px 0px #ffffff, -1px 1px 0px #ffffff, 1px 1px 0px #ffffff, 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.6); filter: brightness(1) !important; font-weight: bold; -webkit- ">âš¡</span> Get Another QuickFix - $1.99

          </button>

        <div style="background: linear-gradient(to bottom, #00a8e8, #0b0646); border-radius: 16px; padding: 20px 16px; margin: 12px 0; text-align: center; box-shadow: 0 4px 12px rgba(0, 168, 232, 0.2);">

          <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 12px;">

            <span style="font-size: 24px;">ðŸš€</span>

            <h3 style="color: white; font-size: 20px; font-weight: 700; margin: 0;">Go Pro and Chill...</h3>

        </div>

          <p style="text-align: center; color: white; font-size: 14px; margin: 0 0 16px 0; line-height: 1.6; opacity: 0.95;">

            100 scans and fixes/month â€¢ Deeper AI fixes powered by Claude Haiku â€¢ Priority chat support â€¢ Cancel anytime

          </p>

          <button onclick="showProUpsell()" style="background: white; color: #00a8e8; border: 1px solid #00a8e8; border-radius: 8px; padding: 12px 24px; font-size: 14px; font-weight: 700; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); transition: transform 0.2s; margin-bottom: 8px; width: 100%;">

            â†’ Get Pro - $9.99/mo

          </button>

          <div style="text-align: center; color: white; font-size: 10px; opacity: 0.9;">

            Cancel Anytime

        </div>

      </div>

        <button onclick="hideQuickFixFlow()" style="width: 100%; background: white; color: #0b0646; border: 1px dashed #0b0646 !important; padding: 14px 24px; font-size: 16px; font-weight: 700; border-radius: 8px; cursor: pointer;">

          ðŸ  Back To Main Dashboard

        </button>

    `;

    }

    disclaimer = "";

  }



  ctaContainer.innerHTML = `

    ${urgencyBanner ? `<div class="urgency-banner ${riskLevel}">

      <div class="urgency-text">${urgencyBanner}</div>

    </div>` : ''}



    ${pitchCopy ? pitchCopy : ''}



    <div class="pitch-section">

      <div class="pitch-title">${pitchTitle}</div>

      ${pitchCopy && !pitchCopy.includes('Your score\'s still high') ? `<p class="pitch-copy">${pitchCopy}</p>` : ''}

      <div class="score-display ${riskLevel}">${scoreDisplay}</div>

      ${score <= 30 ? `<div style="text-align: center; margin-top: 44px;">

        <img src="https://i.postimg.cc/JhsvMWLJ/Lil-Sus-Trans-Bg.png" alt="Lil Sus" style="width: 240px; height: auto; display: block; margin: 0 auto 16px auto; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));">

        <div style="font-size: 28px; font-weight: 700; color: #2ecc71;">Now, Turn It In! ðŸŽ‰</div>

      </div>` : ''}

    </div>



    ${score > 30 && score < 70 ? `<div style="text-align: center; margin-bottom: 20px; padding: 16px; background: white; border-radius: 8px; border: 1px solid #e5e7eb;">

        ${(appState.isProUser || false) ? `<p style="margin: 0 0 8px 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">âš ï¸ Your score's still high because some flagged words weren't fixed.</p>

        <p style="margin: 0 0 8px 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">Pro only works when you apply the suggested swaps â€” that's how you get the lowest, safest score.</p>

        <p style="margin: 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">Run another scan to tweak it till it's chef's kiss. âœ¨</p>` : `<p style="margin: 0 0 8px 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">âš ï¸ Your score's still high because some flagged words weren't fixed.</p>

        <p style="margin: 0 0 8px 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">QuickFix only works when you apply the suggested swaps â€” that's how you get the lowest, safest score.</p>

        <p style="margin: 0; font-size: 14px; font-weight: 400; color: #374151; line-height: 1.5;">Run another QuickFix to finish the clean-up, or go Pro and tweak it till it's chef's kiss. âœ¨</p>`}

      </div>

      <div class="copy-anyway-cta" style="text-align: center; margin: 24px 0 20px 0; padding-bottom: 48px;">

        <button class="copy-btn" onclick="copyQuickFixResult()" style="background: white; color: #0b0646; border: 1px solid #0b0646; padding: 14px 24px; font-size: 16px; font-weight: 700; cursor: pointer; border-radius: 8px; width: 100%; margin-bottom: 8px;">ðŸ˜¬ Nah, I'll Copy It Anyway</button>

        <p class="not-recommended" style="margin: 0; font-size: 13px; color: #6b7280; font-weight: 400;">âš ï¸ Not recommended â€” detectors can still flag this. You can submit it, but your score isn't fully optimized yet.</p>

      </div>` : ''}

    ${score >= 70 ? `<div class="copy-anyway-cta" style="text-align: center; margin: -52px 0 20px 0; padding-bottom: 48px;">

      <button class="copy-btn" onclick="copyQuickFixResult()" style="background: white; color: #0b0646; border: 1px solid #0b0646; padding: 14px 24px; font-size: 16px; font-weight: 700; cursor: pointer; border-radius: 8px; width: 100%; margin-bottom: 8px;">ðŸ˜¬ Nah, I'll Copy It Anyway</button>

      <p class="not-recommended" style="margin: 0; font-size: 13px; color: #6b7280; font-weight: 400;">âš ï¸ Not recommended â€” detectors can still flag this. You can submit it, but your score isn't fully optimized yet.</p>

    </div>` : ''}



    ${!(appState.isProUser || false) ? `

    <div class="cta-button-group">

      ${buttons}

    </div>

    ` : ''}



    <div class="footer-disclaimer">${disclaimer}</div>



    <!-- Back buttons removed from here - they're in the static HTML below with correct order -->

  `;



  // Re-initialize tooltips for dynamically generated buttons

  setTimeout(() => {

    ctaContainer.querySelectorAll('[data-tooltip]').forEach(button => {

      button.addEventListener('mouseenter', showTooltip);

      button.addEventListener('mouseleave', hideTooltip);

      button.addEventListener('mousemove', updateTooltipPosition);

    });

  }, 100);



  // Hide Copy button for Hella Sus (score >= 70)

  const copyButtonContainer = document.getElementById('quickfixCopyButtonContainer');

  if (copyButtonContainer) {

    if (score >= 70) {

      copyButtonContainer.style.display = 'none';

    } else {

      copyButtonContainer.style.display = 'block';

    }

  }

}



// PRO: Dynamic messaging for Step 8 (mirrors QuickFix but uses Pro IDs)



// QuickFix AI Detection Engine - IMPROVED

const AIDetectionEngine = {

  patterns: {

    highRisk: [

      { pattern: "unprecedented levels", explanation: "ChatGPT LOVES this one. Detectors might too ðŸ‘€", fix: "exceptional results", impact: 32 },

      { pattern: "cutting-edge", explanation: "Overused and generic. Screams robot", fix: "innovative", impact: 22 },

      { pattern: "leverage", explanation: "Corporate buzzword that AI detectors flag instantly", fix: "use", impact: 17 },

      { pattern: "utilize", explanation: "Fancy word that AI loves. Sounds robotic", fix: "use", impact: 15 },

      { pattern: "in conclusion", explanation: "Classic essay bot phrase. Too predictable", fix: "to wrap things up", impact: 20 },

      { pattern: "it is important to note", explanation: "AI-generated filler. Get straight to the point", fix: "note that", impact: 18 },

      { pattern: "the data suggests", explanation: "Too formal and AI-sounding", fix: "the evidence shows", impact: 16 }

    ],

    mediumRisk: [

      { pattern: "furthermore", explanation: "Robotic transition word. Try something more natural", fix: "also", impact: 12 },

      { pattern: "thus", explanation: "Too formal for casual writing", fix: "so", impact: 10 },

      { pattern: "however", explanation: "Academic tone that can trigger detectors", fix: "but", impact: 8 },

      { pattern: "demonstrate", explanation: "Academic jargon that AI overuses", fix: "show", impact: 14 },

      { pattern: "significant", explanation: "Common in AI-generated content", fix: "important", impact: 11 }

    ]

  },



  calculateScore(text) {

    console.log('ðŸ” AIDetectionEngine.calculateScore - input length:', text.length);

    let score = 20; // Base score



    let highRiskCount = 0;

    let mediumRiskCount = 0;



    this.patterns.highRisk.forEach(item => {

      const regex = new RegExp(item.pattern, 'gi');

      const matches = text.match(regex);

      if (matches) {

        highRiskCount += matches.length;

        score += matches.length * 8;

      }

    });



    this.patterns.mediumRisk.forEach(item => {

      const regex = new RegExp(item.pattern, 'gi');

      const matches = text.match(regex);

      if (matches) {

        mediumRiskCount += matches.length;

        score += matches.length * 4;

      }

    });



    // Adjust scoring to better detect obviously AI-generated text

    // More flags = higher score, with better mapping to UI thresholds (0-29, 30-69, 70-100)

    const totalFlags = highRiskCount + mediumRiskCount;

    if (totalFlags > 10) {

      // Heavily AI-generated text should score 70+

      score = Math.max(score, 70 + Math.min(20, (totalFlags - 10) * 2));

    } else if (totalFlags > 5) {

      // Moderately AI-generated text should score 30-69

      score = Math.max(score, 30 + Math.min(40, (totalFlags - 5) * 4));

    }



    const finalScore = Math.min(100, score);

    console.log('ðŸ” AIDetectionEngine.calculateScore - high risk:', highRiskCount, 'medium risk:', mediumRiskCount, 'final score:', finalScore);

    return finalScore;

  },



  detectFlags(text) {

    console.log('ðŸ” AIDetectionEngine.detectFlags - input length:', text.length);

    const flags = [];



    this.patterns.highRisk.forEach(item => {

      const regex = new RegExp(item.pattern, 'gi');

      const matches = text.match(regex);

      if (matches) {

        matches.forEach(match => {

          flags.push({

            phrase: match,

            explanation: item.explanation,

            suggestedFix: item.fix,

            severity: 'high',

            impact: item.impact

          });

        });

      }

    });



    this.patterns.mediumRisk.forEach(item => {

      const regex = new RegExp(item.pattern, 'gi');

      const matches = text.match(regex);

      if (matches) {

        matches.forEach(match => {

          flags.push({

            phrase: match,

            explanation: item.explanation,

            suggestedFix: item.fix,

            severity: 'medium',

            impact: item.impact

          });

        });

      }

    });



    console.log('ðŸ” AIDetectionEngine.detectFlags - flags found:', flags.length);

    return flags;

  },



  applyFixes(text, flags) {

    let fixedText = text;



    flags.forEach((flag, index) => {

      if (!flag.phrase || !flag.suggestedFix) return;

      console.log('Applying fix', index, ':', flag.phrase, 'â†’', flag.suggestedFix);

      const regex = new RegExp(flag.phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

      fixedText = fixedText.replace(regex, (match) => {

        const wasCapitalized = match[0] === match[0].toUpperCase();

        let replacement = flag.suggestedFix;

        if (wasCapitalized && replacement.length > 0) {

          replacement = replacement.charAt(0).toUpperCase() + replacement.slice(1);

        }

        return replacement;

      });

    });



    return fixedText;

  },



  // NEW: Complete rewrite function

  completeRewrite(text) {

    // More aggressive rewriting for complete overhaul

    let rewritten = text;



    // Replace common AI patterns with more human alternatives

    const rewriteMap = {

      "unprecedented levels": "remarkable results",

      "cutting-edge": "innovative",

      "leverage": "use",

      "utilize": "use", 

      "in conclusion": "to sum up",

      "it is important to note": "note that",

      "the data suggests": "the evidence shows",

      "furthermore": "additionally",

      "thus": "so",

      "however": "but",

      "demonstrate": "show",

      "significant": "important",

      "moreover": "also",

      "consequently": "as a result",

      "nevertheless": "still",

      "therefore": "so",

      "hence": "so"

    };



    Object.keys(rewriteMap).forEach(pattern => {

      const regex = new RegExp(pattern, 'gi');

      rewritten = rewritten.replace(regex, rewriteMap[pattern]);

    });



    return rewritten;

  }

};



// Update dynamic flag counts across all buttons

function updateDynamicFlagCounts(flagCount) {

  const totalFlagCount1 = document.getElementById('totalFlagCount');

  const totalFlagCount2 = document.getElementById('totalFlagCount2');

  const totalFlagCount3 = document.getElementById('totalFlagCount3');

  const quickfixCount = document.getElementById('quickfixCount');

  const remainingCount = document.getElementById('remainingCount');



  // Update button text

  if (totalFlagCount1) totalFlagCount1.textContent = flagCount;

  if (totalFlagCount2) totalFlagCount2.textContent = flagCount;

  if (totalFlagCount3) totalFlagCount3.textContent = flagCount;



  // Update banner text - QuickFix finds ALL flags

  if (quickfixCount) {

    quickfixCount.textContent = flagCount;

    // Get score from appState to determine color

    const currentScore = appState.quickfixOriginalScore || 0;

    const isCleanNoSus = currentScore < 30;

    // Make count green when it's 0, or light green for Clean No Sus, red for Sus

    if (flagCount === 0) {

      quickfixCount.style.setProperty('color', '#2ecc71', 'important');

    } else if (isCleanNoSus) {

      quickfixCount.style.setProperty('color', '#10b981', 'important'); // Light green for Clean optimizations

    } else {

      quickfixCount.style.setProperty('color', '#dc2626', 'important'); // Red for Sus problems

    }

  }

  if (remainingCount) remainingCount.textContent = 0;



  // Update banner text

  const disclaimer = document.querySelector('.disclaimer');

  if (disclaimer) {

    disclaimer.innerHTML = `ðŸŽ‰ QuickFix found all ${flagCount} AI-trigger words in your essay. Fix them all and drop your score! ðŸš€`;

  }



  // Update button visibility and text based on flag count

  const completeRewriteButtons = document.querySelectorAll('#completeRewrite, [onclick="completeRewrite()"]');

  completeRewriteButtons.forEach(button => {

    if (flagCount <= 3) {

      // If 3 or fewer flags, hide the Pro scan button and show Pro monthly upsell

      button.style.display = 'none';

    } else {

      // If more than 3 flags, show the Pro scan button

      button.style.display = 'block';

      button.innerHTML = `âœ¨ See All ${flagCount} Flags Fixed ðŸ‘‰ (Your Pro Scan!)`;

    }

  });



  // Show Pro monthly upsell button when all flags are found

  if (flagCount <= 3) {

    const upsellSection = document.querySelector('.upsell-section');

    if (upsellSection) {

      upsellSection.style.display = 'block';

    }

  }

}



// FIX 1: Update selected count function - NOW COUNTS WORDS, NOT CHECKBOXES

function updateSelectedCount() {

  // Count how many checkboxes are checked (simplified - just count checked boxes)

  let checkedCount = 0;

  document.querySelectorAll('.fix-option input[type="checkbox"]:checked').forEach(checkbox => {

    checkedCount++;

  });



  const totalCount = document.querySelectorAll('.fix-option input[type="checkbox"]').length;

  const selectedCountElement = document.getElementById('selectedCount');



  if (selectedCountElement) {

    selectedCountElement.textContent = checkedCount;

  }



  // Update "QuickFix Selected Words Only" / "Pro (Selected Words Only)" button text - check if Pro mode

  const isPro = appState.isProUser || false;

  const applySelectedButton = document.getElementById('applySelectedFixes');

  if (applySelectedButton) {

    if (isPro) {

      applySelectedButton.innerHTML = `Pro (Selected Words Only (<span id="selectedCount">${checkedCount}</span>))`;

      // Change button color to Pro blue

      applySelectedButton.style.setProperty('background', '#00a8e8', 'important');

      applySelectedButton.style.setProperty('color', 'white', 'important');

    } else {

      applySelectedButton.innerHTML = `QuickFix Selected Words Only (<span id="selectedCount">${checkedCount}</span>)`;

      // Keep orange for QuickFix

      applySelectedButton.style.setProperty('background', '#ff6b00', 'important');

      applySelectedButton.style.setProperty('color', 'white', 'important');

    }

  }



  // "QuickFix All" button stays the same - no need to update



  // Update Select All checkbox state

  const selectAllCheckbox = document.getElementById('selectAllFixes');

  if (selectAllCheckbox) {

    selectAllCheckbox.checked = checkedCount === totalCount && totalCount > 0;

  }

}

// ===== REAL-TIME SCORE PREVIEW =====

// Cache for container position to avoid recalculating on every mouse move

let bannerPositionCache = {

  containerRight: null,

  containerLeft: null,

  containerTop: null,

  containerHeight: null,

  containerScrollHeight: null,

  containerClientHeight: null,

  bannerX: null,

  lastUpdate: 0

};



// Position banner anchored to the scrollbar position in the container

// ONLY updates position based on scroll - does NOT recalculate container position unless forced

function positionBannerToTarget(previewBox, targetElement, bannerColor, forceRecalculate = false) {

  if (!previewBox) return;



  const banner = document.getElementById('scorePreviewBanner');

  if (!banner) return;



  // Get the scrollable fixSelection container - this is what we anchor to

  const fixSelectionContainer = document.getElementById('fixSelection');

  if (!fixSelectionContainer) {

    // If no container, position at default location

    previewBox.style.left = (window.innerWidth - 320 - 30) + 'px';

    previewBox.style.top = (window.innerHeight / 2 - 55) + 'px';

    return;

  }



  // Check if container is collapsed/hidden - if so, position relative to button group instead

  const isContainerCollapsed = fixSelectionContainer.style.display === 'none' || 

                                fixSelectionContainer.offsetHeight === 0 ||

                                getComputedStyle(fixSelectionContainer).display === 'none';



  // Get container position and scroll info (only if visible)

  let containerRect, containerScrollTop, containerScrollHeight, containerClientHeight;



  // Only recalculate container position if forced or cache is invalid (more than 100ms old or first time)

  const now = Date.now();

  const shouldRecalculate = forceRecalculate || 

                           !bannerPositionCache.containerRight || 

                           (now - bannerPositionCache.lastUpdate) > 100;



  if (isContainerCollapsed) {

    // Container is collapsed - position relative to toggle header or button group

    const toggleHeader = document.querySelector('.toggle-header');

    const buttonGroup = document.getElementById('quickfixButtonGroup');



    if (toggleHeader) {

      containerRect = toggleHeader.getBoundingClientRect();

    } else if (buttonGroup) {

      containerRect = buttonGroup.getBoundingClientRect();

    } else {

      return; // Can't position without a reference

    }



    containerScrollTop = 0;

    containerScrollHeight = containerRect.height;

    containerClientHeight = containerRect.height;

  } else {

    // Only get bounding rect if we need to recalculate

    if (shouldRecalculate) {

      containerRect = fixSelectionContainer.getBoundingClientRect();

      // Cache container position

      bannerPositionCache.containerRight = containerRect.right;

      bannerPositionCache.containerLeft = containerRect.left;

      bannerPositionCache.containerTop = containerRect.top;

      bannerPositionCache.containerHeight = containerRect.height;

      bannerPositionCache.lastUpdate = now;

    } else {

      // Use cached position but update top (in case of window scroll)

      containerRect = {

        right: bannerPositionCache.containerRight,

        left: bannerPositionCache.containerLeft,

        top: fixSelectionContainer.getBoundingClientRect().top, // Only update top for window scroll

        height: bannerPositionCache.containerHeight

      };

    }



    containerScrollTop = fixSelectionContainer.scrollTop;

    containerScrollHeight = fixSelectionContainer.scrollHeight;

    containerClientHeight = fixSelectionContainer.clientHeight;



    // Cache scroll dimensions if recalculating

    if (shouldRecalculate) {

      bannerPositionCache.containerScrollHeight = containerScrollHeight;

      bannerPositionCache.containerClientHeight = containerClientHeight;

    } else {

      // Use cached values

      containerScrollHeight = bannerPositionCache.containerScrollHeight;

      containerClientHeight = bannerPositionCache.containerClientHeight;

    }

  }



  const windowWidth = window.innerWidth;



  // Longer banner dimensions

  const bannerWidth = 320;

  const bannerHeight = 110; // Match actual height from HTML



  // Position banner FIXED on the RIGHT side, anchored to the fixSelection container

  // Position it right next to the container's scrollbar (20px spacing)

  // Only recalculate X if forced or cache is invalid

  let bannerX;

  if (shouldRecalculate || !bannerPositionCache.bannerX) {

    bannerX = containerRect.right + 20;



    // If banner would go off-screen, position it on the left side instead

    if (bannerX + bannerWidth > windowWidth - 10) {

      bannerX = containerRect.left - bannerWidth - 20;

    }



    // Cache X position

    bannerPositionCache.bannerX = bannerX;

  } else {

    // Use cached X position

    bannerX = bannerPositionCache.bannerX;

  }



  // Calculate scrollbar thumb position to align banner vertically with the container

  // THIS is what should update on scroll - Y position only

  const scrollableHeight = containerScrollHeight - containerClientHeight;

  let scrollbarThumbCenter = 0;



  if (scrollableHeight > 0 && !isContainerCollapsed) {

    // Calculate scroll ratio (0 to 1)

    const scrollRatio = containerScrollTop / scrollableHeight;

    // Calculate where the scrollbar thumb center is positioned within the container

    const contentRatio = containerClientHeight / containerScrollHeight;

    const thumbHeight = containerClientHeight * contentRatio;

    const trackHeight = containerClientHeight;

    const availableTrack = trackHeight - thumbHeight;

    // Thumb center position relative to container top

    const thumbCenterRelative = (scrollRatio * availableTrack) + (thumbHeight / 2);

    // Absolute position in viewport

    scrollbarThumbCenter = containerRect.top + thumbCenterRelative;

  } else {

    // No scrolling or container collapsed - position at middle of container

    scrollbarThumbCenter = containerRect.top + (containerRect.height / 2);

  }



  // Position banner vertically centered on the scrollbar thumb (aligned with container)

  let bannerY = scrollbarThumbCenter - (bannerHeight / 2);



  // Ensure banner stays within viewport bounds - but don't force it to bottom

  bannerX = Math.max(10, Math.min(bannerX, windowWidth - bannerWidth - 10));

  // Allow banner to go slightly above/below viewport if needed, but keep it reasonable

  bannerY = Math.max(-50, Math.min(bannerY, window.innerHeight - bannerHeight + 50));



  // If banner would be stuck at bottom, adjust it

  if (bannerY > window.innerHeight - bannerHeight - 20) {

    // Position it relative to container instead

    bannerY = Math.max(containerRect.top + 50, Math.min(bannerY, containerRect.bottom - bannerHeight - 20));

  }



  // Set banner position immediately - no animation, just position it

  previewBox.style.left = bannerX + 'px';

  previewBox.style.top = bannerY + 'px';



  // Pointer removed - no longer needed



  // Update banner background color

  banner.style.background = bannerColor;

}



// Separate function to ONLY update position based on scroll (called on scroll events)

function updateBannerPositionOnly() {

  const previewBox = document.getElementById('scorePreviewBox');

  if (!previewBox || previewBox.style.display === 'none') return;



  const banner = document.getElementById('scorePreviewBanner');

  if (!banner) return;



  // Get current banner color

  const currentColor = banner.style.background || '#2ecc71';



  // Update position WITHOUT recalculating container position (unless cache is stale)

  positionBannerToTarget(previewBox, null, currentColor, false);

}



// Calculate and display estimated score based on current selections

function updateScorePreview() {

  // Only show on Step 2 (fix selection page)

  const quickfixStep2 = document.getElementById('quickfixStep2');

  if (!quickfixStep2 || quickfixStep2.style.display === 'none') {

    const previewBox = document.getElementById('scorePreviewBox');

    if (previewBox) {

      previewBox.style.display = 'none';

      previewBox.style.visibility = 'hidden';

      previewBox.style.opacity = '0';

    }

    return;

  }



  // Check if we have required data

  if (!appState.quickfixOriginalText || !appState.quickfixFlags || !appState.quickfixOriginalScore) {

    return;

  }



  // ALWAYS show chevron when on Step 2 - no need to wait for scroll or selection



  // Get all selected fixes with their original indices

  const selectedFlags = [];

  document.querySelectorAll('.fix-option input[type="checkbox"]:checked').forEach(checkbox => {

    const index = parseInt(checkbox.closest('.fix-option').dataset.index);

    if (index >= 0 && index < appState.quickfixFlags.length && appState.quickfixFlags[index]) {

      const flag = { ...appState.quickfixFlags[index] };

      flag._originalIndex = index; // Store original index for lookup



      // Use button selection if available

      const selectedWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${index}"].selected-word`);

      if (selectedWordBtn) {

        flag.suggestedFix = selectedWordBtn.getAttribute('data-word');

      }



      selectedFlags.push(flag);

    }

  });



  // Determine target element to point to - use the visible/selected fix option

  let targetElement = null;



  // If fixes are selected, point to the last clicked fix option (if it's visible)

  if (selectedFlags.length > 0 && appState.lastClickedFixOption) {

    const fixOption = document.querySelector(`.fix-option[data-index="${appState.lastClickedFixOption}"]`);

    if (fixOption) {

      const rect = fixOption.getBoundingClientRect();

      // Check if element is visible in viewport

      if (rect.top < window.innerHeight && rect.bottom > 0) {

        targetElement = fixOption;

      }

    }

  }



  // If no visible target found, find the first visible checked fix option

  if (!targetElement) {

    document.querySelectorAll('.fix-option input[type="checkbox"]:checked').forEach(checkbox => {

      if (!targetElement) {

        const fixOption = checkbox.closest('.fix-option');

        if (fixOption) {

          const rect = fixOption.getBoundingClientRect();

          // Check if element is visible in viewport

          if (rect.top < window.innerHeight && rect.bottom > 0) {

            targetElement = fixOption;

          }

        }

      }

    });

  }



  // If still no target found, find the first visible fix option

  if (!targetElement) {

    document.querySelectorAll('.fix-option').forEach(fixOption => {

      if (!targetElement) {

        const rect = fixOption.getBoundingClientRect();

        // Check if element is visible in viewport

        if (rect.top < window.innerHeight && rect.bottom > 0) {

          targetElement = fixOption;

        }

      }

    });

  }



  // If no target found, point to CTA button

  if (!targetElement) {

    targetElement = document.getElementById('quickfixButtonGroup');

  }



  // If no fixes selected, show original score in banner (don't hide it!)

  if (selectedFlags.length === 0) {

    // Show original score with no changes

    const previewBox = document.getElementById('scorePreviewBox');

    const previewScore = document.getElementById('previewScore');

    const previewAfterFixesScore = document.getElementById('previewAfterFixesScore');

    const previewAfterFixesAsterisk = document.getElementById('previewAfterFixesAsterisk');

    const previewImprovement = document.getElementById('previewImprovement');



    if (previewBox && previewScore && previewAfterFixesScore && previewAfterFixesAsterisk && previewImprovement && targetElement) {

      const originalScore = appState.quickfixOriginalScore;

      previewScore.textContent = `${originalScore}%`;

      // BLANK until user selects fixes

      previewAfterFixesScore.textContent = '--';

      previewAfterFixesAsterisk.textContent = '';

      previewImprovement.textContent = '';



      // Set color based on original score

      let bannerColor = '#2ecc71';

      if (originalScore <= 30) {

        bannerColor = '#2ecc71';

      } else if (originalScore <= 69) {

        bannerColor = '#f5a623';

      } else {

        bannerColor = '#dc2626';

      }



      // Show banner with original score

      positionBannerToTarget(previewBox, targetElement, bannerColor, true);

      previewBox.style.display = 'block';

      previewBox.style.visibility = 'visible';

      previewBox.style.opacity = '1';

    }

    return;

  }



  // Calculate estimated score based on selected fixes

  let estimatedScore = appState.quickfixOriginalScore;

  let totalReduction = 0;



  selectedFlags.forEach((flag) => {

    const flagIndex = flag._originalIndex;

    if (flagIndex === undefined) return;



    // Check if this flag is using the best word (first alternative)

    const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${flagIndex}"]`);

    const originalBestWord = suggestionsContainer ? suggestionsContainer.getAttribute('data-original-best-word') : null;



    // Check if user is using the best word

    const selectedWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${flagIndex}"].selected-word`);



    let isUsingBestWord = false;

    if (selectedWordBtn) {

      const selectedWord = selectedWordBtn.getAttribute('data-word');

      isUsingBestWord = selectedWord === originalBestWord;

    }



    // More realistic impact calculation - be conservative

    let impact = flag.impact || 12;

    if (isUsingBestWord) {

      impact = 20; // Moderate impact for best words (more realistic)

    } else {

      impact = flag.impact || 10; // Lower impact for non-best words

    }



    totalReduction += impact;

  });



  // Calculate estimated score - be conservative, not overly optimistic

  estimatedScore = Math.max(15, appState.quickfixOriginalScore - totalReduction);



  // Cap the estimate - don't show unrealistically low scores

  // If original is high, estimate should be more conservative

  if (appState.quickfixOriginalScore > 70) {

    // For high scores, don't estimate below 25% (more realistic)

    estimatedScore = Math.max(25, estimatedScore);

  } else if (appState.quickfixOriginalScore > 50) {

    // For medium-high scores, don't estimate below 20%

    estimatedScore = Math.max(20, estimatedScore);

  } else {

    // For lower scores, minimum 15%

    estimatedScore = Math.max(15, estimatedScore);

  }



  // Check if all best words are selected

  const allBestWords = selectedFlags.length >= 2 && selectedFlags.every((flag) => {

    const flagIndex = flag._originalIndex;

    if (flagIndex === undefined) return false;



    const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${flagIndex}"]`);

    const originalBestWord = suggestionsContainer ? suggestionsContainer.getAttribute('data-original-best-word') : null;

    const selectedWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${flagIndex}"].selected-word`);



    if (selectedWordBtn) {

      return selectedWordBtn.getAttribute('data-word') === originalBestWord;

    }

    return false;

  });



  // If all best words selected, apply modest bonus (more realistic)

  if (allBestWords && estimatedScore > 30 && selectedFlags.length >= 2) {

    // More conservative bonus - only reduce by 10-15 points max

    const bonusReduction = Math.min(15, Math.floor((estimatedScore - 25) * 0.5));

    estimatedScore = Math.max(20, estimatedScore - bonusReduction);

  }



  // Check if QuickFix Mode is active and all fixes use best words

  const selectAllCheckbox = document.getElementById('selectAllFixes');

  const isQuickFixMode = selectAllCheckbox && selectAllCheckbox.checked;



  let allUsingBestWords = true;

  selectedFlags.forEach(flag => {

    const flagIndex = flag._originalIndex;

    if (flagIndex === undefined) {

      allUsingBestWords = false;

      return;

    }



    const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${flagIndex}"]`);

    const originalBestWord = suggestionsContainer ? suggestionsContainer.getAttribute('data-original-best-word') : null;

    const selectedWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${flagIndex}"].selected-word`);



    if (selectedWordBtn) {

      // Check if selected word matches the best word

      const selectedWord = selectedWordBtn.getAttribute('data-word');

      if (selectedWord !== originalBestWord) {

        allUsingBestWords = false;

      }

    }

  });



  const isGuaranteed = isQuickFixMode && allUsingBestWords;



  // Update chevron with estimated score

  const previewBox = document.getElementById('scorePreviewBox');

  const previewScore = document.getElementById('previewScore');

  const previewAfterFixesScore = document.getElementById('previewAfterFixesScore');

  const previewAfterFixesAsterisk = document.getElementById('previewAfterFixesAsterisk');

  const previewImprovement = document.getElementById('previewImprovement');



  if (previewBox && previewScore && previewAfterFixesScore && previewAfterFixesAsterisk && previewImprovement && targetElement) {

    // Show original score

    const originalScore = appState.quickfixOriginalScore;

    previewScore.textContent = `${originalScore}%`;



    // Show estimated score immediately

    previewAfterFixesScore.textContent = `${estimatedScore}%`;



    // Show different text based on whether guarantee is active

    if (isGuaranteed) {

      previewAfterFixesAsterisk.textContent = ' âœ“'; // Checkmark for guaranteed

      previewAfterFixesAsterisk.title = 'Guaranteed < 30% (QuickFix Mode active)';

    } else {

      previewAfterFixesAsterisk.textContent = '*'; // Asterisk for estimate

      previewAfterFixesAsterisk.title = 'Estimate (custom words may vary)';

    }



    // Show improvement

    const estimatedImprovement = originalScore - estimatedScore;

    if (estimatedImprovement > 0) {

      previewImprovement.textContent = `â†“ ${estimatedImprovement}% improvement`;

      previewImprovement.style.opacity = '0.9';

    } else {

      previewImprovement.textContent = '';

    }



    // Update color based on ESTIMATED score (not original)

    let bannerColor = '#2ecc71';

    if (estimatedScore <= 30) {

      bannerColor = '#2ecc71'; // Green

    } else if (estimatedScore <= 69) {

      bannerColor = '#f5a623'; // Orange

    } else {

      bannerColor = '#dc2626'; // Red

    }



    // Update the bottom label based on guarantee status

    const estimateLabel = document.getElementById('previewEstimateLabel');

    if (estimateLabel) {

      if (isGuaranteed) {

        estimateLabel.textContent = 'âœ“ Guaranteed';

        estimateLabel.style.color = '#ffffff'; /* White on chevron â€” matches other banner text */

        estimateLabel.title = 'Guaranteed < 30% when using QuickFix Mode best words';

      } else {

        estimateLabel.textContent = '*Estimate';

        estimateLabel.style.color = '#ffffff';

        estimateLabel.title = 'Estimated score - may vary with custom words';

      }

    }



    // Update position and show banner with NEW color

    positionBannerToTarget(previewBox, targetElement, bannerColor, true);

    previewBox.style.display = 'block';

    previewBox.style.visibility = 'visible';

    previewBox.style.opacity = '1';

  }

}



// Check if all selected fixes are using their best words

// Only updates checkbox if user manually changed something - doesn't auto-uncheck on every update

let isUserChangingSelection = false; // Flag to prevent auto-unchecking during programmatic updates



function checkIfAllBestWords() {

  const selectAllCheckbox = document.getElementById('selectAllFixes');

  if (!selectAllCheckbox) return;



  // Don't auto-uncheck if this is a programmatic update (not user action)

  if (!isUserChangingSelection) {

    return; // Skip auto-unchecking during programmatic updates

  }



  // Get all checkboxes (checked and unchecked)

  const allCheckboxes = document.querySelectorAll('.fix-option input[type="checkbox"]');

  const checkedBoxes = document.querySelectorAll('.fix-option input[type="checkbox"]:checked');



  // First check: ALL fixes must be checked

  if (checkedBoxes.length === 0 || checkedBoxes.length !== allCheckboxes.length) {

    // Not all fixes are selected - uncheck "Use Best Words" only if user changed something

    if (isUserChangingSelection) {

      selectAllCheckbox.checked = false;

    }

    isUserChangingSelection = false; // Reset flag

    return;

  }



  // Second check: All checked fixes must be using their best words

  let allUsingBestWords = true;



  checkedBoxes.forEach(checkbox => {

    const index = parseInt(checkbox.closest('.fix-option').dataset.index);

    if (index >= 0 && index < appState.quickfixFlags.length) {

      const flag = appState.quickfixFlags[index];

      const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${index}"]`);



      if (suggestionsContainer) {

        const originalBestWord = suggestionsContainer.getAttribute('data-original-best-word');



        // Check if a word button is selected

        const selectedWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${index}"].selected-word`);

        if (selectedWordBtn) {

          const selectedWord = selectedWordBtn.getAttribute('data-word');

          // If selected word doesn't match original best word, not using best word

          if (selectedWord !== originalBestWord) {

            allUsingBestWords = false;

            return;

          }

        } else {

          // No word selected = not using best word

          allUsingBestWords = false;

          return;

        }

      }

    }

  });



  // Update checkbox based on whether ALL fixes are checked AND all are using best words

  // Only update if user manually changed something

  if (isUserChangingSelection) {

    selectAllCheckbox.checked = allUsingBestWords;

  }



  isUserChangingSelection = false; // Reset flag

}



// Helper function to select the best word for a specific flag

function selectBestWordForFlag(flagIndex, bestWord) {

  // Find the button with this exact word

  const bestWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${flagIndex}"][data-word="${bestWord}"]`);



  if (bestWordBtn) {

    // Update the flag's suggestedFix

    if (appState.quickfixFlags && appState.quickfixFlags[flagIndex]) {

      appState.quickfixFlags[flagIndex].suggestedFix = bestWord;

    }



    // Visual feedback - deselect all buttons for this flag

    const allBtnsForFlag = document.querySelectorAll(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

    allBtnsForFlag.forEach(b => {

      b.style.background = 'white';

      b.style.borderColor = '#d1d5db';

      b.style.color = '#374151';

      b.style.fontWeight = '400';

      b.classList.remove('selected-word');

    });



    // Highlight selected button

    bestWordBtn.style.background = '#10b981';

    bestWordBtn.style.color = 'white';

    bestWordBtn.style.borderColor = '#10b981';

    bestWordBtn.style.fontWeight = '600';

    bestWordBtn.classList.add('selected-word');

  }

}





// Select All functionality

function toggleSelectAll() {

  // Don't mark as user action when toggling - this is programmatic

  // The checkbox state should persist based on actual selections

  const selectAllCheckbox = document.getElementById('selectAllFixes');

  const fixCheckboxes = document.querySelectorAll('.fix-option input[type="checkbox"]');



  if (selectAllCheckbox) {

    const isChecked = selectAllCheckbox.checked;



    if (isChecked) {

      // QuickFix Mode: Ensure the section is expanded first

      const fixSelection = document.getElementById('fixSelection');

      if (fixSelection && fixSelection.style.display === 'none') {

        fixSelection.style.display = 'block';

      }



      // Temporarily disable auto-unchecking during bulk selection

      const wasUserChanging = isUserChangingSelection;

      isUserChangingSelection = false; // Prevent auto-uncheck during programmatic selection



      // Auto-select all checkboxes AND select first word button for each

      fixCheckboxes.forEach((checkbox, index) => {

        checkbox.checked = true;



        // Add green background to the fix-option box

        const fixOption = checkbox.closest('.fix-option');

        if (fixOption) {

          fixOption.style.background = '#f0fdf4';

          fixOption.style.borderColor = '#10b981';

          fixOption.classList.add('selected');

        }



        // Find the ORIGINAL BEST word for this flag

        const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${index}"]`);

        let originalBestWord = null;



        if (suggestionsContainer) {

          // Get the stored original best word

          originalBestWord = suggestionsContainer.getAttribute('data-original-best-word');

        }



        // If we have the original best word, try to find and select it

        if (originalBestWord) {

          // Check if the button with the original best word exists

          const bestWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${index}"][data-word="${originalBestWord}"]`);



          if (bestWordBtn) {

            // Button exists - select it directly

            selectBestWordForFlag(index, originalBestWord);

          } else {

            // Button doesn't exist - just select the first available button

            const firstWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${index}"]`);

            if (firstWordBtn) {

              selectBestWordForFlag(index, firstWordBtn.getAttribute('data-word'));

            }

          }

        } else {

          // Fallback: use first button if no original best word stored

          const firstWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${index}"]`);

          if (firstWordBtn) {

            selectBestWordForFlag(index, firstWordBtn.getAttribute('data-word'));

          }

        }

      });



      // After all selections are done, update and manually keep checkbox checked

      setTimeout(() => {

        updateScorePreview();

        // Manually set checkbox to checked since we selected all best words

        if (selectAllCheckbox) {

          selectAllCheckbox.checked = true;

        }

        // Restore flag state

        isUserChangingSelection = wasUserChanging;

      }, 300);

    } else {

      // DIY Mode: Uncheck all checkboxes and deselect all words

      // Keep the section visible even when unchecking

      const fixSelection = document.getElementById('fixSelection');

      // Force the section to be visible in DIY mode so users can still see options

      if (fixSelection) {

        fixSelection.style.display = 'block';

      }



      fixCheckboxes.forEach((checkbox, index) => {

        checkbox.checked = false;



        // Remove green background from the fix-option box

        const fixOption = checkbox.closest('.fix-option');

        if (fixOption) {

          fixOption.style.background = '#f8f9fa';

          fixOption.style.borderColor = '#e5e7eb';

          fixOption.classList.remove('selected');

        }



        const allBtnsForFlag = document.querySelectorAll(`.alt-word-btn[data-flag-index="${index}"]`);

        allBtnsForFlag.forEach(b => {

          b.style.background = 'white';

          b.style.borderColor = '#d1d5db';

          b.style.color = '#374151';

          b.style.fontWeight = '400';

          b.classList.remove('selected-word');

        });

      });



      // Update score preview after deselecting all

      setTimeout(() => {

        updateScorePreview();

      }, 100);

    }



    updateSelectedCount();

  }

}



// QuickFix Flow Functions - IMPROVED

function switchToQuickFix() {

  // Reset to QuickFix mode

  appState.isProUser = false;

  updateStepLabels(false);



  // Hide all views

  document.getElementById('inputSection').style.display = 'none';

  document.getElementById('resultsContainer').style.display = 'none';

  document.getElementById('resultsContainer').classList.remove('show');

  document.getElementById('quickfixFlow').style.display = 'block';



  document.body.classList.remove('modal-open');

  showQuickFixStep(1);



  // Auto-populate QuickFix screen with text from main essay input

  const mainInput = document.getElementById('essayInput');

  const quickfixInput = document.getElementById('quickfixEssayInput');

  let textWasAutoPopulated = false;

  if (mainInput && mainInput.value.trim() && quickfixInput) {

    quickfixInput.value = mainInput.value.trim();

    textWasAutoPopulated = true;

    const charCountEl = document.getElementById('quickfixFlowCharCount');

    if (charCountEl) {

      var qfWords = quickfixInput.value.trim().split(/\s+/).filter(function(w){return w.length>0}); charCountEl.textContent = qfWords.length.toLocaleString();

    }

  }



  // REMOVED: Quick Reminder modal - replaced with info box above textarea

  // if (textWasAutoPopulated && quickfixInput && quickfixInput.value.length <= 500) {

  //   showQuickFixReminderModal();

  // }



  document.getElementById('quickfixFlow').scrollIntoView({ behavior: 'smooth', block: 'start' });

}



// FIXED: Start Free Scan CTA

function startFreeScanCTA() {

  console.log('ðŸ” startFreeScanCTA() called');



  const essayInput = document.getElementById('essayInput');

  const text = essayInput ? essayInput.value.trim() : '';



  // Check authorship

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (!authorshipCheckbox || !authorshipCheckbox.checked) {

    if (typeof showAuthorshipReminder === 'function') {

      showAuthorshipReminder();

    }

    return;

  }



  // Check length

  if (text.length < 50) {

    showSuccessMessage('Please enter at least 50 characters');

    return;

  }



  // Check character limit

  if (text.length > 500) {

    if (typeof showCharacterLimitModal === 'function') {

      showCharacterLimitModal();

    }

    return;

  }



  // Run scan

  if (typeof scanEssay === 'function') {

    scanEssay();

  }

}



// FIXED: Start QuickFix CTA

function startQuickFixCTA() {

  console.log('âš¡ startQuickFixCTA() called');



  // Check authorship

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (!authorshipCheckbox || !authorshipCheckbox.checked) {

    if (typeof showAuthorshipReminder === 'function') {

      showAuthorshipReminder();

    }

    return;

  }



  appState.isQuickFixUser = true;

  if (typeof showQuickFixFlow === 'function') {

    showQuickFixFlow();

  }

}



// Handle Pro button click from main page

window.startProCTA = function startProCTA() {

  console.log('ðŸ’Ž startProCTA() called');



  // Check authorship

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (!authorshipCheckbox || !authorshipCheckbox.checked) {

    if (typeof showAuthorshipReminder === 'function') {

    showAuthorshipReminder();

    }

    return;

  }



  // Show welcome modal, then payment

  if (typeof showProWelcomeModal === 'function') {

    showProWelcomeModal(true);

  }

};



// Pro Flow Functions - Switch to Pro and preserve text

function switchToPro() {

  // Hide all views

  document.getElementById('inputSection').style.display = 'none';

  document.getElementById('resultsContainer').style.display = 'none';

  document.getElementById('resultsContainer').classList.remove('show');

  document.getElementById('quickfixFlow').style.display = 'none';



  document.body.classList.remove('modal-open');

  showProDashboard();



  // Auto-populate Pro screen with text from main essay input

  const mainInput = document.getElementById('essayInput');

  const proInput = document.getElementById('proScanInput');

  if (mainInput && mainInput.value.trim() && proInput) {

    proInput.value = mainInput.value.trim();

    const charCountEl = document.getElementById('proCharCount');

    if (charCountEl) {

      let proWords = proInput.value.trim().split(/\s+/).filter(w => w.length > 0); if (proWords.length > 1500) { proInput.value = proWords.slice(0, 1500).join(' '); proWords = proWords.slice(0, 1500); } charCountEl.textContent = proWords.length.toLocaleString() + ' / 1,500';

    }

    // Auto-check Pro authorship checkbox if main page checkbox was checked

    const mainAuthorshipCheckbox = document.getElementById('authorshipCheckbox');

    const proAuthorshipCheckbox = document.getElementById('proAuthorshipCheckbox');

    if (mainAuthorshipCheckbox && mainAuthorshipCheckbox.checked && proAuthorshipCheckbox) {

      proAuthorshipCheckbox.checked = true;

    }



    // Trigger input event to update button state

    const inputEvent = new Event('input', { bubbles: true });

    proInput.dispatchEvent(inputEvent);



    // Also manually update button state immediately and after delays to ensure it's updated

    if (typeof updateProScanButtonState === 'function') {

      updateProScanButtonState();

    }

    setTimeout(() => {

      if (typeof updateProScanButtonState === 'function') {

        updateProScanButtonState();

      }

    }, 50);

    setTimeout(() => {

      if (typeof updateProScanButtonState === 'function') {

        updateProScanButtonState();

      }

    }, 300);

  }



  // Scroll to Pro dashboard

  const step6 = document.getElementById('quickfixStep6');

  if (step6) {

    step6.scrollIntoView({ behavior: 'smooth', block: 'start' });

  }

}



function showQuickFixFlow() {

  switchToQuickFix();



  // Reset rewrite counter

  appState.freeRewritesUsed = 0;

  updateRewriteCounter();



  // FIX 2: Auto-populate QuickFix screen with text from main essay input

  const mainInput = document.getElementById('essayInput');

  const quickfixInput = document.getElementById('quickfixEssayInput');

  if (mainInput && mainInput.value.trim()) {

    quickfixInput.value = mainInput.value.trim();

    var qfWords = quickfixInput.value.trim().split(/\s+/).filter(function(w){return w.length>0}); document.getElementById('quickfixFlowCharCount').textContent = qfWords.length;



    // Auto-check QuickFix authorship checkbox if main page checkbox was checked

    const mainAuthorshipCheckbox = document.getElementById('authorshipCheckbox');

    const quickfixAuthorshipCheckbox = document.getElementById('quickfixAuthorshipCheckbox');

    if (mainAuthorshipCheckbox && mainAuthorshipCheckbox.checked && quickfixAuthorshipCheckbox) {

      quickfixAuthorshipCheckbox.checked = true;

    }



    // Update button state based on text length and authorship

    const startButton = document.getElementById('startQuickFix');

    if (startButton) {

      const isAuthorshipConfirmed = quickfixAuthorshipCheckbox && quickfixAuthorshipCheckbox.checked;

      if (quickfixInput.value.length >= 50 && isAuthorshipConfirmed) {

        startButton.disabled = false;

        startButton.style.opacity = '1';

        startButton.style.cursor = 'pointer';

      } else {

        startButton.disabled = true;

        startButton.style.opacity = '0.6';

        startButton.style.cursor = 'not-allowed';

      }

    }

  } else {

    // Show placeholder animation or text

    quickfixInput.placeholder = "Paste your text/essay here to get started.";

  }



  // FIX: Scroll to top of QuickFix form (not top of website)

  document.getElementById('quickfixFlow').scrollIntoView({ behavior: 'smooth', block: 'start' });

}



function switchToResults() {

  // Hide all views

  document.getElementById('inputSection').style.display = 'none';

  document.getElementById('quickfixFlow').style.display = 'none';

  document.getElementById('resultsContainer').style.display = 'block';

  document.getElementById('resultsContainer').classList.add('show');



  // CRITICAL: Remove modal state with delay to ensure it's removed

  setTimeout(() => {

    document.body.classList.remove('modal-open');

    console.log('Removed modal-open from body');

  }, 100);



  // Scroll

  document.getElementById('resultsContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });

}



function switchToInput() {

  // Hide all views

  document.getElementById('quickfixFlow').style.display = 'none';

  document.getElementById('resultsContainer').style.display = 'none';

  document.getElementById('resultsContainer').classList.remove('show');

  document.getElementById('inputSection').style.display = 'block';



  // Uncheck authorship checkbox when returning to form

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (authorshipCheckbox) {

    authorshipCheckbox.checked = false;

  }



  // CRITICAL: Clear essay input when returning to input section

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    essayInput.value = '';

  }



  document.body.classList.remove('modal-open');

  document.getElementById('inputSection').scrollIntoView({ behavior: 'smooth', block: 'start' });



  // Update counter to reflect unchecked state

  updateCounter();



  // CRITICAL: Handle Pro user UI - disable Free/QuickFix CTAs

  handleProUserCTAs();



  // Update test mode toggle

  if (typeof updateTestModeToggle === 'function') {

    updateTestModeToggle();

  }

}



// TEST HELPER: Toggle Pro status for testing

// Usage: toggleProStatus() - toggles between Pro and Free

// Usage: toggleProStatus(true) - force Pro mode

// Usage: toggleProStatus(false) - force Free mode

window.toggleProStatus = function(forcePro = null) {

  if (!window.appState) {

    console.error('âŒ appState not initialized');

    return;

  }



  const currentStatus = window.appState.isProUser || false;

  const newStatus = forcePro !== null ? forcePro : !currentStatus;



  window.appState.isProUser = newStatus;



  console.log(`ðŸ§ª TEST MODE: ${newStatus ? 'PRO' : 'FREE'} user mode ${newStatus ? 'enabled' : 'disabled'}`);



  // Update UI immediately

  handleProUserCTAs();



  // Update test toggle button visual state

  updateTestModeToggle();



  // Show confirmation

  if (typeof showSuccessMessage === 'function') {

    showSuccessMessage(

      `ðŸ§ª Test Mode: ${newStatus ? 'Pro' : 'Free'} user mode active`,

      newStatus ? '#00a8e8' : '#6b7280'

    );

  }



  return newStatus;

};



// Update test mode toggle button appearance

function updateTestModeToggle() {

  const toggle = document.getElementById('testModeToggle');

  const statusText = document.getElementById('testModeStatus');



  if (!toggle || !statusText) return;



  const isPro = window.appState?.isProUser || false;



  // Update text

  statusText.textContent = isPro ? 'Pro' : 'Free';



  // Update styling

  if (isPro) {

    toggle.classList.add('pro-mode');

  } else {

    toggle.classList.remove('pro-mode');

  }

}



// Function to handle Pro user CTA states

function handleProUserCTAs() {

  const isProUser = window.appState?.isProUser || false;



  if (isProUser) {

    console.log('ðŸ’Ž Pro user detected - disabling free/QuickFix CTAs');



    // Disable free scan button

    const scanButton = document.getElementById('scanButton');

    if (scanButton) {

      scanButton.classList.add('cta-disabled-for-pro');

      scanButton.title = "You're a Pro user! Use Pro features instead.";

      scanButton.setAttribute('data-pro-disabled', 'true');

    }



    // Disable QuickFix CTAs (find all QuickFix buttons)

    // Method 1: Find by onclick attribute

    document.querySelectorAll('button[onclick*="handleQuickFixClick"]').forEach(btn => {

      btn.classList.add('cta-disabled-for-pro');

      btn.title = "You're a Pro user! Use the Pro dashboard.";

      btn.setAttribute('data-pro-disabled', 'true');

    });



    // Method 2: Find by text content (QuickFix, $1.99, etc.)

    document.querySelectorAll('button').forEach(btn => {

      const text = (btn.textContent || btn.innerText || '').toLowerCase();

      if ((text.includes('quickfix') || text.includes('quick fix') || text.includes('$1.99')) && 

          !btn.classList.contains('cta-disabled-for-pro')) {

        // Check if it's a QuickFix button (has handleQuickFixClick or is in QuickFix context)

        const hasQuickFixClick = btn.onclick && btn.onclick.toString().includes('handleQuickFixClick');

        const isInQuickFixContext = btn.closest('[id*="quickfix"], [class*="quickfix"], [id*="lockbox"], [id*="unlock"]');

        if (hasQuickFixClick || isInQuickFixContext) {

          btn.classList.add('cta-disabled-for-pro');

          btn.title = "You're a Pro user! Use the Pro dashboard.";

          btn.setAttribute('data-pro-disabled', 'true');

        }

      }

    });



    // Disable emergency button

    const emergencyButton = document.querySelector('.emergency-button');

    if (emergencyButton) {

      emergencyButton.classList.add('cta-disabled-for-pro');

      emergencyButton.title = "You're a Pro user! Use Pro features.";

      emergencyButton.setAttribute('data-pro-disabled', 'true');

    }



    // Show Pro message

    let proMessage = document.getElementById('proUserMessage');

    if (!proMessage) {

      proMessage = createProMessage();

    }

    if (proMessage) {

      proMessage.style.display = 'block';

    }



    // Hide orange QuickFix upsell button in Pro Step 3 ONLY

    const quickFixUpsellBtn = document.getElementById('step3QuickFixUpsellButton');

    if (quickFixUpsellBtn) {

      quickFixUpsellBtn.style.display = 'none';

      quickFixUpsellBtn.style.setProperty('display', 'none', 'important');

      quickFixUpsellBtn.style.visibility = 'hidden';

      quickFixUpsellBtn.style.setProperty('visibility', 'hidden', 'important');

    }



  } else {

    // Enable all buttons for free users

    console.log('ðŸ‘¤ Free user - enabling all CTAs');



    const disabledButtons = document.querySelectorAll('.cta-disabled-for-pro');

    disabledButtons.forEach(btn => {

      btn.classList.remove('cta-disabled-for-pro');

      btn.title = '';

      btn.removeAttribute('data-pro-disabled');

    });



    // Hide Pro message

    const proMessage = document.getElementById('proUserMessage');

    if (proMessage) {

      proMessage.style.display = 'none';

    }

  }

}



// Helper function to create Pro user message

function createProMessage() {

  // Check if it already exists

  let message = document.getElementById('proUserMessage');

  if (message) {

    return message;

  }



  message = document.createElement('div');

  message.id = 'proUserMessage';

  message.innerHTML = `

    <div style="text-align: center; margin: 20px 0; padding: 20px; background: linear-gradient(135deg, #00a8e8, #0087c4); color: white; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 168, 232, 0.3);">

      <div style="font-size: 32px; margin-bottom: 12px;">ðŸ’Ž</div>

      <h3 style="margin: 0 0 8px 0; font-size: 20px; font-weight: 700;">You're a Pro Fixer!</h3>

      <p style="margin: 0 0 16px 0; font-size: 14px; opacity: 0.95; line-height: 1.5;">

        Access 100 scans/mo deeper AI analysis with Claude Haiku, Priority Support all Pro Features.

      </p>

      <button onclick="showProDashboard()" style="background: white; color: #00a8e8; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">

        Go to Pro Dashboard â†’

      </button>

    </div>

  `;



  // Insert after the main input section or scan button area

  const inputSection = document.getElementById('inputSection');

  const scanButton = document.getElementById('scanButton');



  if (inputSection) {

    // Try to insert after the scan button container

    const buttonContainer = scanButton?.parentElement;

    if (buttonContainer && buttonContainer.parentElement) {

      buttonContainer.parentElement.insertBefore(message, buttonContainer.nextSibling);

    } else {

      // Fallback: insert at the end of input section

      inputSection.appendChild(message);

    }

  } else if (scanButton) {

    // Insert after scan button's parent

    const parent = scanButton.parentElement;

    if (parent && parent.parentElement) {

      parent.parentElement.insertBefore(message, parent.nextSibling);

    }

  }



  return message;

}



// Function to go back to QuickFix Step 2 (word selection page)

function goBackToQuickFixStep2() {

  console.log('ðŸ”™ Going back to QuickFix Step 2');



  // Get stored data from appState

  const originalText = appState.quickfixOriginalText || '';

  const originalScore = appState.quickfixOriginalScore || 0;

  const flags = appState.quickfixFlags || [];



  console.log('ðŸ”™ Restoring Step 2 with:', {

    textLength: originalText.length,

    score: originalScore,

    flagsCount: flags.length

  });



  // Use the existing showQuickFixStep function

  if (typeof showQuickFixStep === 'function') {

    showQuickFixStep(2);

  } else {

    // Fallback if function doesn't exist

    const step3 = document.getElementById('quickfixStep3');

    const step2 = document.getElementById('quickfixStep2');

    if (step3) {

      step3.style.display = 'none';

      step3.classList.remove('active');

    }

    if (step2) {

      step2.style.display = 'block';

      step2.classList.add('active');

    }

  }



  // Re-populate Step 2 with the stored flags and text

  // Wait a bit for Step 2 to be visible, then call displayQuickFixAnalysis

  setTimeout(() => {

    if (typeof displayQuickFixAnalysis === 'function' && originalText && flags.length > 0) {

      console.log('ðŸ”™ Re-populating Step 2 with stored data');

      displayQuickFixAnalysis(originalText, originalScore, flags);



      // Update score preview after a short delay

      setTimeout(() => {

        if (typeof updateScorePreview === 'function') {

          updateScorePreview();

        }

      }, 200);

    } else {

      console.warn('âš ï¸ Cannot re-populate Step 2 - missing data or function');

    }

  }, 150);



  // Scroll to top of Step 2

  setTimeout(() => {

    const step2 = document.getElementById('quickfixStep2');

    if (step2) {

      step2.scrollIntoView({ behavior: 'smooth', block: 'start' });

    }

  }, 100);

}



// Function to scroll to editable text area

function scrollToEditableText() {

  console.log('ðŸ“ Scrolling to editable text area');

  // Find the essay display area - scroll to the essay toggle section which contains the editable essay views

  const essayToggle = document.querySelector('.essay-toggle');

  const essayDisplay = document.querySelector('.essay-display');

  const fixedEssay = document.getElementById('fixedEssay');



  // Scroll to the essay toggle/display area so user can see and edit the essay

  if (essayToggle) {

    essayToggle.scrollIntoView({ behavior: 'smooth', block: 'start' });

    // After scrolling, also ensure the fixed essay is visible

    setTimeout(() => {

      if (fixedEssay) {

        fixedEssay.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

      }

    }, 300);

  } else if (essayDisplay) {

    essayDisplay.scrollIntoView({ behavior: 'smooth', block: 'start' });

  } else if (fixedEssay) {

    fixedEssay.scrollIntoView({ behavior: 'smooth', block: 'start' });

  }

}



function hideQuickFixFlow() {

  console.log('ðŸ”„ hideQuickFixFlow() - Cleaning up scan state');



  // CRITICAL: Abort local detection if in progress

  if (window._localDetectionAbortController) {

    try {

      window._localDetectionAbortController.abort();

      console.log('âœ… Aborted local detection in hideQuickFixFlow');

    } catch (e) {

      console.warn('âš ï¸ Error aborting local detection:', e);

    }

    window._localDetectionAbortController = null;

  }



  // CRITICAL: Clear local detection timeout

  if (window._localDetectionTimeout) {

    clearTimeout(window._localDetectionTimeout);

    window._localDetectionTimeout = null;

  }



  // CRITICAL: Reset scan in progress flag

  window._scanInProgress = false;



  // CRITICAL: Clean up background processes

  cleanupBackgroundProcesses();



  // Reset Pro mode if we're leaving Pro flow

  // Only reset if we're actually in QuickFix mode (not Pro)

  const wasInProFlow = appState.isProUser;

  if (wasInProFlow) {

    // If coming from Pro flow, don't reset - let backToProDashboard handle it

    // But if explicitly called from QuickFix, reset Pro mode

    const isQuickFixUser = !appState.proSubscription || !appState.proSubscription.active;

    if (isQuickFixUser) {

      appState.isProUser = false;

      updateStepLabels(false);

    }

  } else {

    // Definitely QuickFix mode, ensure Pro mode is off

    appState.isProUser = false;

    updateStepLabels(false);

  }



  switchToInput();

  // Note: showQuickFixStep may not exist, using direct step manipulation instead

  const step1 = document.getElementById('quickfixStep1');

  if (step1) {

    step1.style.display = 'block';

    step1.classList.add('active');

  }



  // Clear QuickFix essay input completely

  const quickfixInput = document.getElementById('quickfixEssayInput');

  if (quickfixInput) {

    quickfixInput.value = '';

    const quickfixCharCount = document.getElementById('quickfixFlowCharCount');

    if (quickfixCharCount) quickfixCharCount.textContent = '0';

  }



  // Clear main essay input completely

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    essayInput.value = '';

    updateCounter();

  }



  // CRITICAL: Reset appState to prevent stale data from appearing on subsequent scans

  appState.quickfixOriginalText = '';

  appState.quickfixFlags = [];

  appState.quickfixOriginalScore = 0;

  appState.quickfixFixedText = '';

  appState.quickfixNewScore = 0;



  // Reset flag data from regular scans too

  appState.flagData = [];

  appState.currentScore = 0;

  appState.originalText = '';



  // Reset all checkboxes in QuickFix flow

  const selectAllCheckbox = document.getElementById('selectAllFixes');

  if (selectAllCheckbox) {

    selectAllCheckbox.checked = false;

  }



  // Reset all individual fix checkboxes

  document.querySelectorAll('.fix-option input[type="checkbox"]').forEach(checkbox => {

    checkbox.checked = false;

  });



  // Reset all word selection buttons

  document.querySelectorAll('.alt-word-btn').forEach(btn => {

    btn.style.background = 'white';

    btn.style.borderColor = '#d1d5db';

    btn.style.color = '#374151';

    btn.style.fontWeight = '400';

    btn.classList.remove('selected-word');

  });



  // Reset author checkbox

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (authorshipCheckbox) {

    authorshipCheckbox.checked = false;

  }



}



// Lock to prevent reverting to step 2 right after showing step 3

let step3LockUntil = 0;



// Unlock Bonus Rescan = simple go-back button to QuickFix Step 2 (no rebuild - Step 2 stays exactly as it was)

function goBackToQuickFixStep2FromBonusRescan() {

  console.log('ðŸ”“ Get Bonus Rescan clicked - going back to Step 2');

  appState.quickfixBonusRescanUsed = true;

  step3LockUntil = 0;

  appState.quickfixNewScore = null; // so score displays original (quickfixOriginalScore), not post-fix score

  showQuickFixStep(2);

}



function showQuickFixStep(stepNumber) {

  console.log('showQuickFixStep called with:', stepNumber);



  // CRITICAL: Hide all stuck tooltips immediately

  if (typeof clearAllTooltips === 'function') {

    clearAllTooltips();

  } else if (typeof hideTooltip === 'function') {

    hideTooltip();

  }

  // Force hide all tooltip elements

  const allTooltips = document.querySelectorAll('#tooltip, .tooltip, [id*="tooltip"], [class*="tooltip"]');

  allTooltips.forEach(tt => {

    tt.classList.remove('show');

    tt.style.display = 'none';

    tt.style.visibility = 'hidden';

    tt.style.opacity = '0';

  });



  // PREVENT REVERTING TO STEP 2 IF WE JUST SHOWED STEP 3 (within 2 seconds) - unless lock was cleared (e.g. Unlock Bonus Rescan)

  if (stepNumber === 2 && Date.now() < step3LockUntil) {

    console.warn('ðŸš« BLOCKED: Attempted to show Step 2 too soon after Step 3. Ignoring.');

    return;

  }



  // Detect if we're coming FROM Step 3 (so we preserve score + word suggestions when going back)

  const step3El = document.getElementById('quickfixStep3');

  const comingFromStep3 = step3El && (step3El.classList.contains('active') || step3El.style.display === 'block' || getComputedStyle(step3El).display === 'block');

  if (stepNumber === 2) {

    console.log('ðŸ” Checking comingFromStep3:', comingFromStep3, 'step3El:', step3El, 'step3El.display:', step3El ? getComputedStyle(step3El).display : 'N/A');

  }



  // FIRST: Hide ALL steps explicitly with display: none

  document.querySelectorAll('.quickfix-step').forEach(step => {

    step.classList.remove('active');

    step.style.setProperty('display', 'none', 'important');

    step.style.setProperty('opacity', '0', 'important');

    step.style.setProperty('visibility', 'hidden', 'important');

  });



  const stepElement = document.getElementById('quickfixStep' + stepNumber);

  console.log('Step element found:', stepElement);



  // CRITICAL: Hide red CTA box for Pro users when showing Step 3

  if (stepNumber === 3) {

    const isPro = appState.isProUser || appState.proSubscription?.active || false;

    if (isPro) {

      const quickfixHellaSusCTA = document.getElementById('quickfixStep3HellaSusCTA');

      if (quickfixHellaSusCTA) {

        quickfixHellaSusCTA.style.display = 'none';

        quickfixHellaSusCTA.style.setProperty('display', 'none', 'important');

        quickfixHellaSusCTA.style.visibility = 'hidden';

        quickfixHellaSusCTA.style.opacity = '0';

        quickfixHellaSusCTA.style.height = '0';

        quickfixHellaSusCTA.style.margin = '0';

        quickfixHellaSusCTA.style.padding = '0';

        quickfixHellaSusCTA.style.overflow = 'hidden';

        quickfixHellaSusCTA.style.position = 'absolute';

        quickfixHellaSusCTA.style.left = '-9999px';

        quickfixHellaSusCTA.classList.add('pro-hidden');

        quickfixHellaSusCTA.setAttribute('data-pro', 'true');

        console.log('âœ… FORCE HIDDEN red CTA box for Pro user in Step 3');

      }

    }

  }



  // Step 2: only clear fix options when NOT coming back from Step 3 (Unlock Bonus Rescan = back button, keep same score + suggestions)

  if (stepNumber === 2) {

    const fixSelection = document.getElementById('fixSelection');

    if (fixSelection) {

      if (!comingFromStep3) {

        fixSelection.innerHTML = ''; // Clear old fix options only when building Step 2 fresh

        fixSelection.style.display = 'none';

      } else {

        // Keep word suggestions visible when going back from Step 3 - restore proper styling

        fixSelection.style.display = 'block';

        fixSelection.style.padding = '0';

        fixSelection.style.maxHeight = '400px';

        fixSelection.style.overflowY = 'scroll';

        fixSelection.style.overflowX = 'hidden';

        console.log('ðŸ”„ Restored fixSelection styling when returning from Step 3');

      }

    }

    // When returning from Step 3 (e.g. Unlock Bonus Rescan), hide the score preview chevron so it doesn't pop up top-left

    if (comingFromStep3) {

      const previewBox = document.getElementById('scorePreviewBox');

      if (previewBox) {

        previewBox.style.display = 'none';

        previewBox.style.visibility = 'hidden';

        previewBox.style.opacity = '0';

      }

      // Step 2 B only: show inline note (differentiate from original Step 2 A)

      const step2BonusNote = document.getElementById('step2BonusRescanNote');

      if (step2BonusNote) {

        step2BonusNote.style.display = 'block';

        step2BonusNote.style.setProperty('display', 'block', 'important');

      }

      // Step 2 B: show partially fixed score (match Pro â€” current score after their selected fixes, not original)

      console.log('ðŸ”„ Going back to Step 2 from Step 3 - quickfixNewScore:', appState.quickfixNewScore, 'quickfixOriginalScore:', appState.quickfixOriginalScore);

      const displayScore = (appState.quickfixNewScore != null && appState.quickfixNewScore !== '')

        ? Number(appState.quickfixNewScore)

        : (appState.quickfixOriginalScore != null ? Number(appState.quickfixOriginalScore) : 0);

      console.log('ðŸ“Š Step 2 displayScore:', displayScore, '(using quickfixNewScore:', appState.quickfixNewScore != null && appState.quickfixNewScore !== '', ')');



      // Update score number and progress bar

      const scoreEl = document.getElementById('quickfixOriginalScore');

      const scoreLabelEl = document.getElementById('quickfixScoreLabel');

      const fillEl = document.getElementById('quickfixProgressFill');

      if (scoreEl) {

        // Score: ONLY the number (no duplicate label/emoji)

        scoreEl.style.color = typeof getScoreFontColor === 'function' ? getScoreFontColor(displayScore) : (displayScore >= 70 ? '#dc2626' : displayScore >= 30 ? '#f59e0b' : '#2ecc71');

        scoreEl.textContent = Math.round(displayScore) + '%';

        console.log('âœ… Updated quickfixOriginalScore element to:', scoreEl.textContent);

      }

      if (scoreLabelEl) {

        // Label: show label and emoji ONLY here

        let emoji = '';

        let label = '';

        if (displayScore >= 70) {

          emoji = 'ðŸš¨';

          label = 'Major Sus';

        } else if (displayScore >= 30) {

          emoji = 'âš ï¸';

          label = 'Mid Sus';

        } else {

          emoji = 'âœ…';

          label = 'Low Sus';

        }

        scoreLabelEl.textContent = label + ' ' + emoji;

        scoreLabelEl.style.display = 'block';

        scoreLabelEl.style.color = typeof getScoreFontColor === 'function' ? getScoreFontColor(displayScore) : (displayScore >= 70 ? '#dc2626' : displayScore >= 30 ? '#f59e0b' : '#2ecc71');

      }

      if (fillEl) {

        fillEl.style.width = Math.round(displayScore) + '%';

        // Fill shows only colors passed: green 0-30%, yellow 30-70%, red 70-100%

        fillEl.style.background = typeof getProgressFillGradient === 'function' ? getProgressFillGradient(displayScore) : '#10b981';

        console.log('âœ… Updated quickfixProgressFill width to:', fillEl.style.width, 'with gradient for score:', displayScore);

      }



      // Update progress indicator position - CRITICAL: Make sure it's visible and positioned correctly

      const indicatorEl = document.getElementById('quickfixProgressIndicator');

      if (indicatorEl && fillEl) {

        const progressBar = document.getElementById('quickfixProgressBar');

        if (progressBar) {

          // Ensure indicator is visible

          indicatorEl.style.display = 'block';

          indicatorEl.style.visibility = 'visible';

          indicatorEl.style.opacity = '1';

          indicatorEl.style.zIndex = '10';



          const barWidth = progressBar.offsetWidth || progressBar.clientWidth;

          const indicatorPosition = (displayScore / 100) * barWidth;

          indicatorEl.style.left = indicatorPosition + 'px';



          // Update indicator border color based on score

          indicatorEl.classList.remove('high-sus', 'medium-sus', 'low-sus');

          if (displayScore >= 70) {

            indicatorEl.classList.add('high-sus');

            indicatorEl.style.borderColor = '#dc2626';

          } else if (displayScore >= 30) {

            indicatorEl.classList.add('medium-sus');

            indicatorEl.style.borderColor = '#FFF000';

          } else {

            indicatorEl.classList.add('low-sus');

            indicatorEl.style.borderColor = '#2ecc71';

          }

          console.log('âœ… Updated progress indicator position to:', indicatorPosition, 'px for score:', displayScore, 'barWidth:', barWidth);

        }

      }



      // scoreLabelEl is already declared above and hidden, no need to redeclare

      // Still call updateScoreLabelColor for any other elements that might need it

      if (typeof updateScoreLabelColor === 'function') updateScoreLabelColor(displayScore, 'quickfixScoreLabel');



      // CRITICAL: Update UI cards/theme based on NEW score (not original)

      // Hide all cards first

      const quickfixHellaSusCard = document.getElementById('quickfixHellaSusCard');

      const quickfixKindaSusCard = document.getElementById('quickfixKindaSusCard');

      const quickfixYoureGoodCard = document.getElementById('quickfixYoureGoodCard');

      const quickfixCleanNoSusCTA = document.getElementById('quickfixCleanNoSusCTA');

      if (quickfixHellaSusCard) quickfixHellaSusCard.style.display = 'none';

      if (quickfixKindaSusCard) quickfixKindaSusCard.style.display = 'none';

      if (quickfixYoureGoodCard) quickfixYoureGoodCard.style.display = 'none';

      if (quickfixCleanNoSusCTA) quickfixCleanNoSusCTA.style.display = 'none';



      // Show appropriate card based on NEW score

      if (displayScore >= 70) {

        // Hella Sus - Red banner

        if (quickfixHellaSusCard) {

          quickfixHellaSusCard.style.display = 'block';

          console.log('âœ… Showing Hella Sus card for score:', displayScore);

        }

      } else if (displayScore >= 30) {

        // Kinda Sus - Yellow banner

        if (quickfixKindaSusCard) {

          quickfixKindaSusCard.style.display = 'block';

          console.log('âœ… Showing Kinda Sus card for score:', displayScore);

        }

      } else {

        // Low Sus

        if (quickfixYoureGoodCard) quickfixYoureGoodCard.style.display = 'block';

        if (quickfixCleanNoSusCTA) quickfixCleanNoSusCTA.style.display = 'block';

        console.log('âœ… Showing Clean No Sus card for score:', displayScore);

      }

    } else {

      // Step 2 A (original): hide bonus rescan note

      const step2BonusNote = document.getElementById('step2BonusRescanNote');

      if (step2BonusNote) {

        step2BonusNote.style.display = 'none';

        step2BonusNote.style.setProperty('display', 'none', 'important');

      }

    }

    // For QuickFix (non-Pro) Step 2, ensure Back to Main Dashboard is visible for all scores

    const isPro = appState.isProUser || (appState.proSubscription && appState.proSubscription.active);

    if (!isPro) {

      const step2BackToDashboard = document.getElementById('quickfixStep2BackToDashboard');

      if (step2BackToDashboard) {

        step2BackToDashboard.style.display = 'block';

        step2BackToDashboard.style.setProperty('display', 'block', 'important');

      }

    }

    // CRITICAL: For Pro users, ALWAYS show both Step 2 CTAs (green Pro All + blue Pro Selected Words Only + Back to Pro Dashboard) as soon as Step 2 is shown

    if (isPro) {

      const step2BackToDashboard = document.getElementById('quickfixStep2BackToDashboard');

      const step2BackToProDashboard = document.getElementById('step2BackToProDashboard');

      const step2TrustedSection = document.getElementById('step2TrustedSection');

      if (step2BackToDashboard) { step2BackToDashboard.style.display = 'none'; step2BackToDashboard.style.setProperty('display', 'none', 'important'); }

      if (step2BackToProDashboard) { step2BackToProDashboard.style.display = 'block'; step2BackToProDashboard.style.setProperty('display', 'block', 'important'); }

      // Pro Low Sus Step 1: NEVER show Trusted at bottom (it's in place of Copy CTA). Only show for Pro Hella/Kinda Sus.

      const score = appState.quickfixOriginalScore ?? appState.proOriginalScore ?? 0;

      const proStep2BackBtn = document.getElementById('proStep2BackToDashboard');

      if (proStep2BackBtn) {

        if (score < 30) { proStep2BackBtn.style.display = 'none'; proStep2BackBtn.style.setProperty('display', 'none', 'important'); }

        else { proStep2BackBtn.style.display = 'block'; proStep2BackBtn.style.setProperty('display', 'block', 'important'); }

      }

      if (step2TrustedSection) {

        if (score < 30) {

          step2TrustedSection.style.display = 'none';

          step2TrustedSection.style.setProperty('display', 'none', 'important');

        } else {

          step2TrustedSection.style.display = 'block';

        }

      }

      const buttonGroup = document.getElementById('quickfixButtonGroup');

      const applyAllBtn = document.getElementById('applyAllFixes');

      const applySelectedBtn = document.getElementById('applySelectedFixes');

      if (buttonGroup) { buttonGroup.style.display = 'flex'; buttonGroup.style.setProperty('display', 'flex', 'important'); }

      if (applyAllBtn) { applyAllBtn.style.display = 'flex'; applyAllBtn.style.setProperty('display', 'flex', 'important'); applyAllBtn.style.visibility = 'visible'; }

      if (applySelectedBtn) {

        applySelectedBtn.style.display = 'flex';

        applySelectedBtn.style.setProperty('display', 'flex', 'important');

        applySelectedBtn.style.visibility = 'visible';

        applySelectedBtn.style.setProperty('visibility', 'visible', 'important');

        applySelectedBtn.style.opacity = '1';

        applySelectedBtn.style.height = 'auto';

        applySelectedBtn.style.margin = '';

        applySelectedBtn.style.padding = '';

      }

      console.log('âœ… Pro Step 2: both CTAs (Pro All + Pro Selected Words Only + Back to Pro Dashboard) forced visible in showQuickFixStep(2)');

    }

  }



  if (stepElement) {

    // Show ONLY the target step

    stepElement.classList.add('active');

    stepElement.style.setProperty('display', 'block', 'important');

    stepElement.style.setProperty('opacity', '1', 'important');

    stepElement.style.setProperty('visibility', 'visible', 'important');

    console.log('Step element activated and displayed');



    // If showing step 3, set lock to prevent reverting to step 2

    if (stepNumber === 3) {

      step3LockUntil = Date.now() + 2000; // Lock for 2 seconds

      console.log('ðŸ”’ Step 3 lock set until:', new Date(step3LockUntil));



      // CRITICAL: For Pro users, ensure all Pro CTAs are visible. Orange "Get Another QuickFix" CTA: hide for Pro; for non-Pro show only on Kinda/Hella Sus (score >= 30).

      const isPro = appState.isProUser || (appState.proSubscription && appState.proSubscription.active);

      if (isPro) {

        setTimeout(() => {

          updateStepLabels(true);

          // Force show all Pro Step 3 CTAs

          const step3BackToProDashboard = document.getElementById('step3BackToProDashboard');

          const step3ViewPastFixes = document.getElementById('step3ViewPastFixes');

          const step3EditFixes = document.getElementById('step3EditFixes');

          if (step3BackToProDashboard) {

            step3BackToProDashboard.style.display = 'block';

            step3BackToProDashboard.style.setProperty('display', 'block', 'important');

          }

          if (step3ViewPastFixes) {

            step3ViewPastFixes.style.display = 'block';

            step3ViewPastFixes.style.setProperty('display', 'block', 'important');

          }

          // Try Different Words: show for Pro EXCEPT on Clean No Sus Pro Step 3

          const quickfixStep3CleanNoSusCTA = document.getElementById('quickfixStep3CleanNoSusCTA');

          const quickfixStep3YoureGoodCard = document.getElementById('quickfixStep3YoureGoodCard');

          const isCleanNoSusStep3 = (quickfixStep3CleanNoSusCTA && quickfixStep3CleanNoSusCTA.style.display === 'block') ||

            (quickfixStep3YoureGoodCard && quickfixStep3YoureGoodCard.style.display === 'block');

          if (step3EditFixes) {

            if (isCleanNoSusStep3) {

              step3EditFixes.style.display = 'none';

              step3EditFixes.style.setProperty('display', 'none', 'important');

            } else {

              step3EditFixes.style.display = 'block';

              step3EditFixes.style.setProperty('display', 'block', 'important');

            }

          }

          // Hide orange QuickFix upsell button for Pro

          const quickFixUpsellBtn = document.getElementById('step3QuickFixUpsellButton');

          if (quickFixUpsellBtn) {

            quickFixUpsellBtn.style.display = 'none';

            quickFixUpsellBtn.style.setProperty('display', 'none', 'important');

          }

          console.log('âœ… Pro Step 3 CTAs forced visible in showQuickFixStep');

        }, 100);

      } else {

        // Non-Pro (QuickFix/Free): show orange CTA only for Kinda Sus or Hella Sus (score >= 30). Hide for Clean.

        setTimeout(() => {

          const quickFixUpsellBtn = document.getElementById('step3QuickFixUpsellButton');

          if (quickFixUpsellBtn) {

            const score = appState.quickfixNewScore;

            const isKindaOrHellaSus = (typeof score === 'number' && score >= 30);

            if (isKindaOrHellaSus) {

              quickFixUpsellBtn.style.display = 'flex';

              quickFixUpsellBtn.style.setProperty('display', 'flex', 'important');

              quickFixUpsellBtn.style.visibility = 'visible';

            } else {

              quickFixUpsellBtn.style.display = 'none';

              quickFixUpsellBtn.style.setProperty('display', 'none', 'important');

            }

          }

        }, 100);

      }

    }



    // Start rotating messages if we're on step 4

    if (stepNumber === 4) {

      startRotatingMessages();

    }

  } else {

    console.error('Step element not found for step:', stepNumber);

  }

}



// Rotating messages for step 4

const rotatingMessages = [

  "ðŸ’Ž Premium Results - Every Flag Found & Fixed âœ¨",

  "ðŸ’Ž Pro Member Exclusive - All Flags Fixed âœ¨",

  "ðŸ’Ž Premium Detection Complete - Ready to Turn In ðŸš€",

  "ðŸ’Ž You've Earned This - Essay is Fire ðŸ”¥",

  "ðŸ’Ž Pro Member Results - Absolutely Perfect ðŸŒŸ",

  "Mission Accomplished - Your Essay is Perfect âœ¨"

];

let currentMessageIndex = 0;



// Rotating messages for clean result subtitle (score <= 30)

const cleanResultMessages = [

  "Ready To Turn In! âœ…",

  "All clear! ðŸŽ‰",

  "Nothing to fix here! âœ…",

  "You're good to go! âœ¨"

];

let currentCleanMessageIndex = 0;



function startRotatingMessages() {

  const messageElement = document.getElementById('rotatingMessage');

  if (!messageElement) return;



  // For Pro users, set premium message and don't rotate

  if (appState.isProUser || (appState.proSubscription && appState.proSubscription.active)) {

    messageElement.textContent = 'ðŸ’Ž Premium Results - Every Flag Found & Fixed âœ¨';

    return; // Don't start rotation for Pro users

  }



  function rotateMessage() {

    // Only rotate if user is NOT in Pro mode (Pro users see premium static message)

    if (appState.isProUser || (appState.proSubscription && appState.proSubscription.active)) {

      return; // Don't rotate for Pro users - keep premium message

    }

    messageElement.style.opacity = '0';

    setTimeout(() => {

      currentMessageIndex = (currentMessageIndex + 1) % rotatingMessages.length;

      messageElement.textContent = rotatingMessages[currentMessageIndex];

      messageElement.style.opacity = '1';

    }, 500);

  }



  // Start rotation after 2 seconds, then every 5 seconds

  // CRITICAL: Clear any existing interval first to prevent stacking

  if (window.messageRotationInterval) {

    clearInterval(window.messageRotationInterval);

    window.messageRotationInterval = null;

  }



  setTimeout(() => {

    window.messageRotationInterval = setInterval(rotateMessage, 5000);

  }, 2000);

}



// Rotating messages for clean result subtitle

function startRotatingCleanMessages() {

  const scanResultsSubtitle = document.getElementById('quickfixScanResultsSubtitle');

  if (!scanResultsSubtitle) return;

  // Ensure font size is set

  scanResultsSubtitle.style.fontSize = '18px';



  // Don't rotate if score is not clean

  const headerWrapper = document.getElementById('quickfixStep3HeaderWrapper');

  if (!headerWrapper) return;



  function rotateCleanMessage() {

    if (!scanResultsSubtitle) return;

    // Check if we're still on a clean result page

    const currentText = scanResultsSubtitle.textContent;

    if (!cleanResultMessages.includes(currentText) && !currentText.includes("You're all set")) {

      return; // Stop rotating if we're not showing clean messages anymore

    }



    scanResultsSubtitle.style.opacity = '0';

    setTimeout(() => {

      currentCleanMessageIndex = (currentCleanMessageIndex + 1) % cleanResultMessages.length;

      scanResultsSubtitle.textContent = cleanResultMessages[currentCleanMessageIndex];

      scanResultsSubtitle.style.opacity = '1';

    }, 300);

  }



  // Start rotation after 1 second, then every 3 seconds

  // CRITICAL: Clear any existing interval first to prevent stacking

  if (window.cleanMessageRotationInterval) {

    clearInterval(window.cleanMessageRotationInterval);

    window.cleanMessageRotationInterval = null;

  }



  setTimeout(() => {

    window.cleanMessageRotationInterval = setInterval(rotateCleanMessage, 3000);

  }, 1000);

}



// Rotating fun messages for Clean No Sus Step 2 ONLY (not Step 3, not global)

const cleanNoSusStep2Messages = [

  { main: "Clean as a whistle! Ready to turn it in âœ¨", sub: "Your essay just got a glow-up. Flag drop confirmed. âœ¨" },

  { main: "No flags detected! You're clear to submit ðŸŽ¯", sub: "Vibe check passed! Nothing to tweak here âœ…" },

  { main: "Essay status: immaculate. Ready To Turn In! ðŸ’š", sub: "Clean scan complete! All systems go ðŸš€" },

  { main: "Zero flags found. You're golden! ðŸ†", sub: "Essay approved! Safe to turn in ðŸŽ‰" },

  { main: "QuickFix didn't clock anything sus âœ…", sub: "Vibe check passed â€” nothing to tweak ðŸŽ‰" },

  { main: "All clear! Ready to submit âœ¨", sub: "Your essay is looking fresh. Flag drop confirmed ðŸš€" }

];

let currentCleanNoSusStep2MessageIndex = 0;



// Rotating messages for Hella Sus (Free results)

const hellaSusFreeMessages = [

  "ðŸš¨ Real talk: These phrases are getting flagged",

  "âš ï¸ Turnitin's probably gonna catch this one",

  "ðŸš© Your prof's detector will clock these",

  "ðŸ›‘ Don't risk it â€” fix it before you submit",

  "âš ï¸ These triggers are hella sus",

  "ðŸš¨ Major red flags detected â€” time to fix"

];

let currentHellaSusMessageIndex = 0;



// Rotating messages for Kinda Sus (Free results)

const kindaSusFreeMessages = [

  "âš ï¸ Fair chance these could trip detectors",

  "ðŸ’¡ Your essay has some red flags, but you've got time",

  "âœ¨ Consider rewording these phrases",

  "âš ï¸ Some wording might come across as AI-generated",

  "ðŸ’­ A few more fixes and you'll be in the clear",

  "ðŸ”§ Let's make it perfect before you submit"

];

let currentKindaSusMessageIndex = 0;



// Rotate fun messages for Clean No Sus Step 2 ONLY

function startRotatingCleanNoSusStep2Messages() {

  const cleanNoSusCTAText = document.getElementById('quickfixCleanNoSusCTAText');

  const cleanNoSusCTASubtext = document.getElementById('quickfixCleanNoSusCTASubtext');

  const cleanNoSusCTA = document.getElementById('quickfixCleanNoSusCTA');



  // Only run if we're on QuickFix Step 2 and the CTA is visible

  if (!cleanNoSusCTAText || !cleanNoSusCTA) return;

  if (cleanNoSusCTA.style.display === 'none') return;



  // Check if we're on Step 2 (not Step 3)

  const quickfixStep2 = document.getElementById('quickfixStep2');

  if (!quickfixStep2 || quickfixStep2.style.display === 'none') return;



  function rotateCleanNoSusStep2Message() {

    if (!cleanNoSusCTAText || !cleanNoSusCTA) return;

    // Stop rotating if CTA is hidden or we're no longer on Step 2

    if (cleanNoSusCTA.style.display === 'none') return;



    const quickfixStep2 = document.getElementById('quickfixStep2');

    if (!quickfixStep2 || quickfixStep2.style.display === 'none') {

      return; // Stop rotating if we're not on Step 2 anymore

    }



    // Fade out both text elements

    cleanNoSusCTAText.style.opacity = '0';

    if (cleanNoSusCTASubtext) cleanNoSusCTASubtext.style.opacity = '0';



    setTimeout(() => {

      currentCleanNoSusStep2MessageIndex = (currentCleanNoSusStep2MessageIndex + 1) % cleanNoSusStep2Messages.length;

      const message = cleanNoSusStep2Messages[currentCleanNoSusStep2MessageIndex];



      // Update main text

      cleanNoSusCTAText.textContent = message.main;

      cleanNoSusCTAText.style.opacity = '1';



      // Update subtext if element exists

      if (cleanNoSusCTASubtext) {

        cleanNoSusCTASubtext.textContent = message.sub;

        cleanNoSusCTASubtext.style.opacity = '1';

      }

    }, 300);

  }



  // Clear any existing interval first

  if (window.cleanNoSusStep2RotationInterval) {

    clearInterval(window.cleanNoSusStep2RotationInterval);

    window.cleanNoSusStep2RotationInterval = null;

  }



  // Start rotation after 2 seconds, then every 4 seconds

  setTimeout(() => {

    window.cleanNoSusStep2RotationInterval = setInterval(rotateCleanNoSusStep2Message, 4000);

  }, 2000);

}



// Start rotating messages for Hella Sus (Free results)

function startRotatingHellaSusMessages() {

  // Retry finding the element with polling (in case DOM isn't ready)

  let attempts = 0;

  const maxAttempts = 10;



  function tryStartRotation() {

    const rotatingElement = document.getElementById('hellaSusRotatingMessage');

    if (!rotatingElement) {

      attempts++;

      if (attempts < maxAttempts) {

        setTimeout(tryStartRotation, 100);

        return;

      }

      console.log('âŒ hellaSusRotatingMessage element not found after', maxAttempts, 'attempts - check HTML');

      return;

    }



    // Element found - proceed with rotation

    const messages = rotatingElement.querySelectorAll('span');

    if (messages.length === 0) {

      console.log('âŒ No message spans found in rotating element');

      return;

    }



    // Clear any existing interval first

    if (window.hellaSusRotationInterval) {

      clearInterval(window.hellaSusRotationInterval);

      window.hellaSusRotationInterval = null;

    }



    // Remove active class from all messages

    messages.forEach(msg => msg.classList.remove('active'));



    // Set first message active

    let current = 0;

    messages[current].classList.add('active');

    console.log('âœ… Started rotating Hella Sus messages:', messages[current].textContent);



    // Rotate every 3 seconds

    window.hellaSusRotationInterval = setInterval(() => {

      if (!rotatingElement || !document.body.contains(rotatingElement)) {

        if (window.hellaSusRotationInterval) {

          clearInterval(window.hellaSusRotationInterval);

          window.hellaSusRotationInterval = null;

        }

        return;

      }



      messages[current].classList.remove('active');

      current = (current + 1) % messages.length;

      messages[current].classList.add('active');

    }, 3000);

  }



  // Start trying immediately

  tryStartRotation();

}



// Start rotating messages for Kinda Sus (Free results)

function startRotatingKindaSusMessages() {

  // Retry finding the element with polling (in case DOM isn't ready)

  let attempts = 0;

  const maxAttempts = 10;



  function tryStartRotation() {

    const rotatingElement = document.getElementById('kindaSusRotatingMessage');

    if (!rotatingElement) {

      attempts++;

      if (attempts < maxAttempts) {

        setTimeout(tryStartRotation, 100);

        return;

      }

      console.log('âŒ kindaSusRotatingMessage element not found after', maxAttempts, 'attempts - check HTML');

      return;

    }



    // Element found - proceed with rotation

    const messages = rotatingElement.querySelectorAll('span');

    if (messages.length === 0) {

      console.log('âŒ No message spans found in rotating element');

      return;

    }



    // Clear any existing interval first

    if (window.kindaSusRotationInterval) {

      clearInterval(window.kindaSusRotationInterval);

      window.kindaSusRotationInterval = null;

    }



    // Remove active class from all messages

    messages.forEach(msg => msg.classList.remove('active'));



    // Set first message active

    let current = 0;

    messages[current].classList.add('active');

    console.log('âœ… Started rotating Kinda Sus messages:', messages[current].textContent);



    // Rotate every 3 seconds

    window.kindaSusRotationInterval = setInterval(() => {

      if (!rotatingElement || !document.body.contains(rotatingElement)) {

        if (window.kindaSusRotationInterval) {

          clearInterval(window.kindaSusRotationInterval);

          window.kindaSusRotationInterval = null;

        }

        return;

      }



      messages[current].classList.remove('active');

      current = (current + 1) % messages.length;

      messages[current].classList.add('active');

    }, 3000);

  }



  // Start trying immediately

  tryStartRotation();

}



// Setup rotating messages for QuickFix and Free results

// Function to start rotating messages in a container

function startRotatingMessages(container) {

  if (!container) return;



  // Clear any existing interval for this container

  const containerId = container.id || 'default';

  if (window[`rotationInterval_${containerId}`]) {

    clearInterval(window[`rotationInterval_${containerId}`]);

  }



  // Get all messages in this container

  const messages = container.querySelectorAll('.rotating-message');

  if (messages.length === 0) return;



  // Remove active class from all messages

  messages.forEach(msg => msg.classList.remove('active'));



  // Set initial active message (first one)

  let currentIndex = 0;

  messages[currentIndex].classList.add('active');



  // Rotate messages every 5 seconds

  window[`rotationInterval_${containerId}`] = setInterval(() => {

    // Remove active from current

    messages[currentIndex].classList.remove('active');



    // Move to next message

    currentIndex = (currentIndex + 1) % messages.length;



    // Add active to new message

    messages[currentIndex].classList.add('active');

  }, 5000);

}



// Global variable to store rotation intervals

window.rotatingMessageIntervals = window.rotatingMessageIntervals || {};



function startRotatingMessages(container) {

  if (!container) return;



  const containerId = container.id || `container-${Math.random().toString(36).substr(2, 9)}`;



  // Stop any existing rotation for this container

  if (window.rotatingMessageIntervals[containerId]) {

    clearInterval(window.rotatingMessageIntervals[containerId]);

  }



  const messages = container.querySelectorAll('.rotating-message');

  if (messages.length === 0) return;



  // Remove active class from all messages

  messages.forEach(msg => msg.classList.remove('active'));



  // Set first message as active

  let currentIndex = 0;

  messages[0].classList.add('active');



  // Rotate messages every 5 seconds

  window.rotatingMessageIntervals[containerId] = setInterval(() => {

    // Remove active from current

    messages[currentIndex].classList.remove('active');



    // Move to next message

    currentIndex = (currentIndex + 1) % messages.length;



    // Add active to new current

    messages[currentIndex].classList.add('active');

  }, 5000);

}



function setupRotatingMessages(score) {

  console.log('Setting up rotating messages for score:', score);



  // Stop all existing rotations

  Object.keys(window).forEach(key => {

    if (key.startsWith('rotationInterval_')) {

      clearInterval(window[key]);

      delete window[key];

    }

  });



  // Hide all rotating containers and alerts first

  const allContainers = document.querySelectorAll('.rotating-message-container');

  allContainers.forEach(container => {

    container.style.display = 'none';

  });

  const allAlerts = document.querySelectorAll('.major-red-flags-alert, .kinda-sus-alert, .clean-alert');

  allAlerts.forEach(alert => {

    alert.style.display = 'none';

  });



  // Show appropriate container based on score

  // Check both QuickFix cards and Free results cards

  if (score >= 70) {

    // Hella Sus (70-100%)

    // Check QuickFix card first

    const quickfixHellaSusCard = document.getElementById('quickfixHellaSusCard');

    if (quickfixHellaSusCard) {

      const alert = quickfixHellaSusCard.querySelector('.major-red-flags-alert');

      if (alert) {

        console.log('Showing hella sus alert (QuickFix)');

        alert.style.display = 'block';

      }

    }

    // Check Free results card

    const hellaSusCard = document.getElementById('hellaSusCard');

    if (hellaSusCard) {

      const alert = hellaSusCard.querySelector('.major-red-flags-alert');

      if (alert) {

        console.log('Showing hella sus alert (Free)');

        alert.style.display = 'block';

      }

    }

  } else if (score >= 30) {

    // Kinda Sus (30-69%)

    // Check QuickFix card first

    const quickfixKindaSusCard = document.getElementById('quickfixKindaSusCard');

    if (quickfixKindaSusCard) {

      const alert = quickfixKindaSusCard.querySelector('.kinda-sus-alert');

      if (alert) {

        console.log('Showing kinda sus alert (QuickFix)');

        alert.style.display = 'block';

      }

    }

    // Check Free results card

    const kindaSusCard = document.getElementById('kindaSusCard');

    if (kindaSusCard) {

      const alert = kindaSusCard.querySelector('.kinda-sus-alert');

      if (alert) {

        console.log('Showing kinda sus alert (Free)');

        alert.style.display = 'block';

      }

    }

  } else {

    // You're Good (0-29%)

    // Check QuickFix card first

    const quickfixStep2CleanAlert = document.getElementById('quickfixStep2CleanAlert');

    if (quickfixStep2CleanAlert) {

      console.log('Showing clean alert (QuickFix)');

      quickfixStep2CleanAlert.style.display = 'block';

    }

    // Check Free results card

    const youreGoodCard = document.getElementById('youreGoodCard');

    if (youreGoodCard) {

      const alert = youreGoodCard.querySelector('.clean-alert');

      if (alert) {

        console.log('Showing clean alert (Free)');

        alert.style.display = 'block';

      }

    }

  }

}



// NEW: Update rewrite counter display

function updateRewriteCounter() {

  const remaining = appState.maxFreeRewrites - appState.freeRewritesUsed;

  const counter = document.getElementById('rewriteCounter');

  if (counter) {

    if (remaining > 0) {

      counter.textContent = `âœ¨ ${remaining} free rewrite${remaining > 1 ? 's' : ''} remaining`;

      counter.style.color = '#00a8e8';

    } else {

      counter.textContent = 'âŒ No free rewrites left - upgrade to Pro';

      counter.style.color = '#dc2626';

    }

  }



  // Enable/disable complete rewrite button

  const rewriteBtn = document.getElementById('completeRewrite');

  if (rewriteBtn) {

    if (remaining > 0) {

      rewriteBtn.disabled = false;

      rewriteBtn.style.background = '#ea580c';

      rewriteBtn.innerHTML = 'âœ¨ See All <span id="totalFlagCount3">' + (appState.quickfixFlags ? appState.quickfixFlags.length : 0) + '</span> Flags Fixed ðŸ‘‰ (Your Pro Scan!)';

    } else {

      rewriteBtn.disabled = true;

      rewriteBtn.style.background = '#9ca3af';

      rewriteBtn.textContent = 'ðŸ”’ No Free Rewrites Left';

    }

  }

}



function showWarningModal() {

  const modal = document.createElement('div');

  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);display:flex;justify-content:center;align-items:center;z-index:10000;';



  const popup = document.createElement('div');

  popup.style.cssText = 'background:#fff;padding:30px 40px;border-radius:16px;max-width:450px;width:90%;text-align:center;box-shadow:0 20px 60px rgba(0,0,0,0.3);position:relative;';



  popup.innerHTML = `

    <div style="font-size:48px;margin-bottom:15px;">âš¡</div>

    <h3 style="color:#1e3a8a;margin-bottom:10px;font-size:20px;font-weight:700;">Hold Up!</h3>

    <p style="color:#6b7280;margin-bottom:10px;font-size:15px;line-height:1.5;">Paste your essay in the box so I can scan, flag & help you fix it!</p>

    <p style="color:#9ca3af;margin-bottom:20px;font-size:13px;">ðŸ’¡ Remember: You can paste up to 1,500 words here</p>

    <button id="closeWarningBtn" style="background:#ea580c;color:white;border:none;padding:12px 30px;border-radius:8px;font-weight:600;font-size:14px;cursor:pointer;transition:all 0.2s;" onmouseover="this.style.background='#c2410c'" onmouseout="this.style.background='#ea580c'">Got It!</button>

  `;



  modal.appendChild(popup);

  document.body.appendChild(modal);



  // Add click listener to close button

  document.getElementById('closeWarningBtn').addEventListener('click', function() {

    modal.remove();

  });



  // Also close when clicking outside the modal

  modal.addEventListener('click', function(e) {

    if (e.target === modal) {

      modal.remove();

    }

  });

}



async function startQuickFixAnalysis() {

  const text = document.getElementById('quickfixEssayInput').value.trim();



  // FIX: Check if text is empty and show warning

  if (text.length < 50) {

    showWarningModal();

    return;

  }



  appState.quickfixOriginalText = text;



  // Show loading state with animated scanning effect (green, yellow, red)

  const button = document.getElementById('startQuickFix');

  const originalText = button.innerHTML;

  button.disabled = true;



  // Add scanning animation CSS if not already added

  if (!document.getElementById('scanningAnimationStyle')) {

    const style = document.createElement('style');

    style.id = 'scanningAnimationStyle';

    style.textContent = `

      .scanning-button {

        position: relative;

        overflow: hidden;

        background: #2ecc71 !important; /* Solid green */

        color: white !important;

        font-weight: 700;

        border: none !important;

        box-shadow: 0 4px 20px rgba(46, 204, 113, 0.6), 0 0 30px rgba(46, 204, 113, 0.4) !important;

        filter: brightness(1.1) saturate(1.2) !important;

      }

      .scanning-button::before {

        content: '';

        position: absolute;

        top: 0;

        left: -100%;

        width: 100%;

        height: 100%;

        background: linear-gradient(90deg, 

          transparent 0%, 

          rgba(255, 255, 255, 0.5) 25%,

          rgba(255, 255, 255, 0.8) 50%,

          rgba(255, 255, 255, 0.5) 75%,

          transparent 100%);

        animation: scanningSweep 1.2s ease-in-out infinite;

        z-index: 1;

      }

      .scanning-button::after {

        content: '';

        position: absolute;

        top: 0;

        left: 0;

        width: 100%;

        height: 100%;

        background: #2ecc71; /* Solid green */

        opacity: 0.9;

        z-index: 0;

      }

      @keyframes scanningSweep {

        0% { left: -100%; }

        100% { left: 100%; }

      }

      @keyframes scanningColors {

        0%, 100% { background-position: 0% 50%; }

        50% { background-position: 100% 50%; }

      }

      .scanning-button .scanning-text {

        position: relative;

        z-index: 2;

        display: flex;

        align-items: center;

        justify-content: center;

        gap: 8px;

        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);

      }

      @keyframes scanningPulse {

        0%, 100% { 

          transform: scale(1);

          opacity: 1;

        }

        50% { 

          transform: scale(1.3);

          opacity: 0.7;

        }

      }

    `;

    document.head.appendChild(style);

  }



  // Update button with scanning animation - green color

  button.classList.add('scanning-button');

  button.style.background = '#2ecc71'; // Green color

  button.style.color = 'white';

  button.innerHTML = '<span class="scanning-text"><span class="scanning-indicator"></span>ðŸ” Scanning your essay now</span>';



  try {

    // CRITICAL: Make QuickFix API call to get enhanced analysis

    // This ensures users get the enhanced functionality they're paying for

    console.log('ðŸ” QuickFix: Calling API for enhanced analysis...');

    const analysis = await analyzeTextWithAPI(text);



    console.log('ðŸ” QuickFix API Result:', {

      score: analysis.score,

      flagCount: analysis.flagCount,

      issuesCount: analysis.issues?.length || 0,

      issues: analysis.issues,

      fullResponse: analysis

    });



    // Convert API issues to flags format (enhanced analysis from QuickFix API)

    const flags = (analysis.issues || []).map(issue => {

      // Calculate impact based on severity - higher impact for better score reduction

      let impact = 15; // Default

      if (issue.severity === 'high') {

        impact = 25; // High severity = bigger impact when fixed

      } else if (issue.severity === 'medium') {

        impact = 18; // Medium severity = moderate impact

      } else {

        impact = 12; // Low severity = smaller impact

      }



      return {

        phrase: issue.phrase || issue.text || '',

        explanation: issue.explanation || issue.reason || 'AI pattern detected',

        suggestedFix: (issue.alternatives && issue.alternatives[0]) || 'Rephrase in your own words',

        severity: issue.severity || 'medium',

        impact: issue.impact || impact // Use calculated impact if not provided

      };

    });



    // Reference free scan count for UI consistency (if same text was scanned)

    const freeScanText = appState.originalText || '';

    const freeScanFlags = appState.flagData || [];

    const textMatches = freeScanText.trim().length > 0 && 

                       (text.trim() === freeScanText.trim() || 

                        Math.abs(text.trim().length - freeScanText.trim().length) < 50);



    if (textMatches && freeScanFlags.length > 0) {

      console.log('âœ… QuickFix: Enhanced analysis complete. Showing same', freeScanFlags.length, 'flags as free scan for UI consistency');

      console.log('ðŸ“Š QuickFix enhanced flags:', flags.length, 'vs Free scan flags:', freeScanFlags.length);

    }



    // Store both full list and topâ€‘5 list for later use

    appState.quickfixFlagsOriginal = flags;

    appState.quickfixFlags = flags;

    appState.quickfixOriginalScore = analysis.score;

    // STAGE 3: Store original separate scores

    // Since /analyze doesn't return separate scores, use the overall score as baseline for both

    // This will be compared against the new separate scores from QuickFix

    appState.quickfixOriginalTextPhraseScore = analysis.textPhraseScore || analysis.score;

    appState.quickfixOriginalStructuralScore = analysis.structuralScore || analysis.score;



    console.log('ðŸ’¾ Stored original scores:', {

      overall: analysis.score,

      textPhrase: appState.quickfixOriginalTextPhraseScore,

      structural: appState.quickfixOriginalStructuralScore

    });



    console.log('ðŸ” QuickFix: Flags found:', flags.length);

    console.log('ðŸ” QuickFix: Flags data:', flags);

    console.log('ðŸ” QuickFix: Score stored:', appState.quickfixOriginalScore);



    console.log('About to show QuickFix Step 2');

    showQuickFixStep(2);

    // Store reset state for "Try Different Words" - restore to this when user goes back

    appState.quickfixResetOriginalText = text;

    appState.quickfixResetOriginalScore = analysis.score;

    appState.quickfixResetFlagsOriginal = JSON.parse(JSON.stringify(flags));

    console.log('About to call displayQuickFixAnalysis with:', text, analysis.score, flags);

    displayQuickFixAnalysis(text, analysis.score, flags);



    // Show banner immediately when Step 2 loads - don't hide it!

    setTimeout(() => {

      updateScorePreview();

    }, 100);

  } catch (error) {

    console.error('âŒ QuickFix API call failed, using local fallback:', error);

    // Fallback to local detection with warning

    showSuccessMessage('âš ï¸ Using basic detection - results may be less accurate. Check your connection for full analysis.');



    const analysis = analyzeTextLocally(text);

    const detectionResult = analysis.score;

    const flags = AIDetectionEngine.detectFlags(text);



    appState.quickfixFlagsOriginal = flags;

    appState.quickfixFlags = flags;

    appState.quickfixOriginalScore = detectionResult;



    console.log('ðŸ” QuickFix: Using local fallback - flags found:', flags.length);



    showQuickFixStep(2);

    appState.quickfixResetOriginalText = text;

    appState.quickfixResetOriginalScore = detectionResult;

    appState.quickfixResetFlagsOriginal = JSON.parse(JSON.stringify(flags));

    displayQuickFixAnalysis(text, detectionResult, flags);

  } finally {

    // Reset button (remove scanning animation and restore original)

    if (button) {

      button.classList.remove('scanning-button');

      button.style.background = '';

      button.style.color = '';

      button.innerHTML = originalText;

      button.disabled = false;

      // Remove any stuck success messages

      const stuckMessage = document.getElementById('successMessage');

      if (stuckMessage) {

        stuckMessage.remove();

      }

    }

  }

}

function displayQuickFixAnalysis(text, score, flags) {

  // === TOPâ€‘5 HIGHESTâ€‘RISK FILTER FOR QUICKFIX STEP 2 ===

  const allFlags = Array.isArray(flags) ? flags : [];

  const totalFlags = allFlags.length;



  // Store ALL flags for later use (View All link, modal, etc.)

  appState.quickfixFlagsOriginal = allFlags;



  // Sort by severity/risk so we can pick the highestâ€‘risk flags

  const getSeverityRank = (flag) => {

    const raw = flag && (flag.severity || flag.risk || flag.type || '');

    const sev = (typeof raw === 'string' ? raw : String(raw || '')).toLowerCase();

    if (sev === 'high') return 0;

    if (sev === 'medium') return 1;

    if (sev === 'low') return 2;

    return 3; // unknown / other

  };



  // Sort all flags by risk (highest risk first) but show ALL of them

  const sortedByRisk = [...allFlags].sort((a, b) => {

    const aRank = getSeverityRank(a);

    const bRank = getSeverityRank(b);

    if (aRank !== bRank) return aRank - bRank;

    const aScore = typeof a?.riskScore === 'number' ? a.riskScore : 0;

    const bScore = typeof b?.riskScore === 'number' ? b.riskScore : 0;

    if (aScore !== bScore) return bScore - aScore;

    return 0;

  });



  // Use ALL sorted flags (not just top 5) for highlighting / fix options

  flags = sortedByRisk;

  // CRITICAL: Hide green "clean and ready" message FIRST - before any other logic

  // This prevents it from showing on Hella Sus (score >= 70) or Kinda Sus (30-69) pages

  // It should ONLY show for Clean No Sus (score < 30)

  const quickfixCleanNoSusLilSusMessage = document.getElementById('quickfixCleanNoSusLilSusMessage');

  const cleanEssayLilSusMessage = document.getElementById('cleanEssayLilSusMessage');

  if (score >= 30) {

    // Hella Sus or Kinda Sus - FORCE HIDE the green message

    if (quickfixCleanNoSusLilSusMessage) {

      quickfixCleanNoSusLilSusMessage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

      quickfixCleanNoSusLilSusMessage.style.setProperty('display', 'none', 'important');

      quickfixCleanNoSusLilSusMessage.style.setProperty('visibility', 'hidden', 'important');

      quickfixCleanNoSusLilSusMessage.style.setProperty('opacity', '0', 'important');

    }

    if (cleanEssayLilSusMessage) {

      cleanEssayLilSusMessage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

      cleanEssayLilSusMessage.style.setProperty('display', 'none', 'important');

      cleanEssayLilSusMessage.style.setProperty('visibility', 'hidden', 'important');

      cleanEssayLilSusMessage.style.setProperty('opacity', '0', 'important');

    }

  }



  // Hide all QuickFix banner cards first

  const quickfixHellaSusCard = document.getElementById('quickfixHellaSusCard');

  const quickfixKindaSusCard = document.getElementById('quickfixKindaSusCard');

  const quickfixYoureGoodCard = document.getElementById('quickfixYoureGoodCard');

  if (quickfixHellaSusCard) quickfixHellaSusCard.style.display = 'none';

  if (quickfixKindaSusCard) quickfixKindaSusCard.style.display = 'none';

  if (quickfixYoureGoodCard) quickfixYoureGoodCard.style.display = 'none';



  // Get dynamic phrase for this score

  let dynamicPhrase = getDynamicPhrase(score);



  // Format phrase for header (add apostrophe for "Bussin", add exclamation)

  let headerPhrase = dynamicPhrase;

  if (dynamicPhrase === "Bussin") {

    headerPhrase = "Bussin'!";

  } else if (dynamicPhrase.includes(" ")) {

    // For phrases with spaces, just add exclamation

    headerPhrase = dynamicPhrase + "!";

  } else {

    // For single words, add exclamation

    headerPhrase = dynamicPhrase + "!";

  }



  // Show appropriate banner card and update dynamic phrase

  if (score >= 70) {

    // Hella Sus - Red banner

    if (quickfixHellaSusCard) quickfixHellaSusCard.style.display = 'block';

    const quickfixHellaSusPhrase = document.getElementById('quickfixHellaSusPhrase');

    if (quickfixHellaSusPhrase) {

      quickfixHellaSusPhrase.textContent = headerPhrase;

    }

    // Restore min-height for other cases

    const quickfixFlow = document.getElementById('quickfixFlow');

    if (quickfixFlow) {

      quickfixFlow.style.minHeight = '100vh';

    }

    const quickfixStep2 = document.getElementById('quickfixStep2');

    if (quickfixStep2) {

      quickfixStep2.style.paddingBottom = '';

      quickfixStep2.style.marginBottom = '';

    }

  } else if (score >= 30) {

    // Kinda Sus - Yellow banner

    if (quickfixKindaSusCard) quickfixKindaSusCard.style.display = 'block';

    const quickfixKindaSusPhrase = document.getElementById('quickfixKindaSusPhrase');

    if (quickfixKindaSusPhrase) {

      quickfixKindaSusPhrase.textContent = headerPhrase;

    }

    // Restore min-height for other cases

    const quickfixFlow = document.getElementById('quickfixFlow');

    if (quickfixFlow) {

      quickfixFlow.style.minHeight = '100vh';

    }

    const quickfixStep2 = document.getElementById('quickfixStep2');

    if (quickfixStep2) {

      quickfixStep2.style.paddingBottom = '';

      quickfixStep2.style.marginBottom = '';

    }

  } else {

    // You're Good - Green banner

    if (quickfixYoureGoodCard) quickfixYoureGoodCard.style.display = 'block';

    const quickfixYoureGoodPhrase = document.getElementById('quickfixYoureGoodPhrase');

    if (quickfixYoureGoodPhrase) {

      quickfixYoureGoodPhrase.textContent = headerPhrase;

    }

    // Reduce bottom padding for Low Sus page to remove blank space

    const inputSection = document.querySelector('.input-section');

    if (inputSection) {

      inputSection.style.paddingBottom = '0px';

    }

  }



  // Update score display - FIXED POSITION

  const quickfixScoreEl = document.getElementById('quickfixOriginalScore');

  const quickfixFillEl = document.getElementById('quickfixProgressFill');

  const quickfixScoreLabelEl = document.getElementById('quickfixScoreLabel');



  // Hide the separate label element since score now includes emoji and label

  if (quickfixScoreLabelEl) {

    quickfixScoreLabelEl.style.display = 'none';

  }



  // Setup rotating messages based on score

  if (typeof setupRotatingMessages === 'function') {

    setupRotatingMessages(score);

  }



  console.log('ðŸ” displayQuickFixAnalysis - Score:', score, 'Flags:', flags.length);

  console.log('ðŸ” Elements found:', { 

    scoreEl: !!quickfixScoreEl, 

    fillEl: !!quickfixFillEl,

    animateProgressBar: typeof animateProgressBar

  });



  // Animate QuickFix progress bar for ALL cards (hellaSus, kindaSus, youreGood)

  // All three cards share the same progress bar elements

  if (quickfixScoreEl && quickfixFillEl) {

    // Clear any existing width that might interfere

    quickfixFillEl.style.width = '';

    quickfixFillEl.removeAttribute('style');



    // CRITICAL: Clear the animatedBars Set entry so it can re-animate for different cards

    // All three QuickFix cards share the same elements, so we need to allow re-animation

    if (typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

      const key = quickfixScoreEl.id + quickfixFillEl.id;

      animatedBars.delete(key);

    }



    // Wait for card to be fully displayed - use requestAnimationFrame for better timing

    requestAnimationFrame(() => {

      requestAnimationFrame(() => {

        // Force a repaint to ensure card is visible

        void quickfixFillEl.offsetHeight;



        // Check if card is visible (any of the three)

        const isCardVisible = (quickfixHellaSusCard && quickfixHellaSusCard.style.display !== 'none') ||

                              (quickfixKindaSusCard && quickfixKindaSusCard.style.display !== 'none') ||

                              (quickfixYoureGoodCard && quickfixYoureGoodCard.style.display !== 'none');



        if (isCardVisible && quickfixFillEl.offsetParent !== null) {

          console.log('ðŸŽ¬ Animating QuickFix progress bar, score:', Math.round(score), 'card visible:', isCardVisible);

          animateProgressBar(quickfixScoreEl, quickfixFillEl, Math.round(score));

        } else {

          // Retry after a short delay

          setTimeout(() => {

            console.log('ðŸ”„ Retrying QuickFix progress bar animation, score:', Math.round(score));

            if (quickfixFillEl.offsetParent !== null) {

              animateProgressBar(quickfixScoreEl, quickfixFillEl, Math.round(score));

            } else {

              // Fallback: set directly if element still not visible

              console.warn('âš ï¸ Progress bar element not visible, setting directly');

              if (quickfixScoreEl) quickfixScoreEl.textContent = Math.round(score) + '%';

              if (quickfixFillEl) quickfixFillEl.style.width = Math.round(score) + '%';

            }

          }, 200);

        }

      });

    });

  } else {

    // Fallback if elements not found

    console.error('âŒ QuickFix progress bar elements not found!', {

      scoreEl: !!quickfixScoreEl,

      fillEl: !!quickfixFillEl

    });

    // Set score directly as fallback

    if (quickfixScoreEl) {

      quickfixScoreEl.textContent = Math.round(score) + '%';

    }

  }



  // Update score label with dynamic color

  updateScoreLabelColor(score, 'quickfixScoreLabel');



  // Warning message is now in the main title, no need to update separately



  // Update flag count (use TOTAL flags, not just topâ€‘5 slice)

  const flagCount = Array.isArray(appState.quickfixFlagsOriginal)

    ? appState.quickfixFlagsOriginal.length

    : flags.length;

  const isYoureGood = flagCount === 0 && score < 30;

  const isCleanNoSus = score < 30;



  // Add/remove clean-no-sus-mode class to body

  if (isCleanNoSus) {

    document.body.classList.add('clean-no-sus-mode');

  } else {

    document.body.classList.remove('clean-no-sus-mode');

  }



  // Update disclaimer count

  const quickfixCount = document.getElementById('quickfixCount');

  const quickfixCountPlural = document.getElementById('quickfixCountPlural');

  const quickfixCountGreen = document.getElementById('quickfixCountGreen');

  if (quickfixCount) {

    quickfixCount.textContent = flagCount;

    // Make count light green for Clean No Sus, green when it's 0, red for Sus

    if (flagCount === 0) {

      quickfixCount.style.color = '#2ecc71';

    } else if (isCleanNoSus) {

      quickfixCount.style.color = '#86efac';

    } else {

      quickfixCount.style.color = '#dc2626';

    }

  }

  if (quickfixCountGreen) {

    quickfixCountGreen.textContent = flagCount;

  }

  if (quickfixCountPlural) {

    quickfixCountPlural.textContent = flagCount === 1 ? '' : 's';

  }



  // Update "QuickFix found" â†’ "Pro found" heading based on Pro mode

  // Use light green for Clean No Sus (score < 30%) to indicate optional optimizations

  // Use red for Kinda Sus/Hella Sus (score >= 30%) to indicate problems that need fixing

  const isPro = appState.isProUser || false;

  const quickfixCountHeading = document.getElementById('quickfixCountHeading');

  if (quickfixCountHeading && flagCount > 0) {

    // Determine color based on score: light green for Clean, red for Sus

    const bannerColor = isCleanNoSus ? '#86efac' : '#dc2626'; // Light green for Clean, red for Sus

    const countColor = isCleanNoSus ? '#86efac' : '#dc2626'; // Light green for count in Clean mode, red for Sus

    const emoji = isCleanNoSus ? 'ðŸ’¡' : 'ðŸš©'; // Lightbulb for optimizations, flag for problems



    // Use different wording for Clean No Sus vs Sus cases

    const wordText = isCleanNoSus ? 'optional optimization suggestion' : 'AI-trigger word';

    const wordPlural = isCleanNoSus ? 'suggestions' : 'words';

    const instructionTextEl = document.getElementById('quickfixInstructionText');



    console.log('ðŸŽ¨ Setting banner color - Score:', score, 'isCleanNoSus:', isCleanNoSus, 'bannerColor:', bannerColor);



    if (isPro) {

      // For Clean No Sus Pro page: use different wording and navy blue with green number

      if (isCleanNoSus) {

        quickfixCountHeading.innerHTML = `${emoji} Pro flagged <span id="quickfixCount" style="color: #10b981 !important;">${flagCount}</span> word${flagCount === 1 ? '' : 's'} in your essay that can be optimized.`;

        quickfixCountHeading.style.setProperty('color', '#1e3a8a', 'important'); // Dark blue

      } else {

        quickfixCountHeading.innerHTML = `${emoji} <span id="quickfixCount" style="color: ${countColor} !important;">${flagCount}</span> High-Risk AI Trigger Words Found`;

        quickfixCountHeading.style.setProperty('color', bannerColor, 'important');

      }

    } else {

      quickfixCountHeading.innerHTML = `${emoji} <span id="quickfixCount" style="color: ${countColor} !important;">${flagCount}</span> High-Risk AI Trigger Words Found`;

      quickfixCountHeading.style.setProperty('color', bannerColor, 'important');

    }



    // Update instruction text for Clean No Sus

    if (instructionTextEl) {

      if (isCleanNoSus) {

        instructionTextEl.textContent = 'Click any highlighted word to see why it sounds like AI and how to fix it.';

      } else {

        instructionTextEl.textContent = 'Click any highlighted word to see why it sounds like AI and how to fix it.';

      }

    }



    // Update checkbox label for Clean No Sus Pro: "Select Optimizations" instead of "Pro Mode: Use Best Words"

    if (isCleanNoSus && isPro) {

      // Find the label containing the checkbox

      const labelWithCheckbox = document.querySelector('label:has(#selectAllFixes)');

      if (labelWithCheckbox) {

        // Find the span that contains the text (it's the last span, after the emoji span)

        const spans = labelWithCheckbox.querySelectorAll('span');

        if (spans.length >= 2) {

          const textSpan = spans[spans.length - 1]; // Last span contains the text

          if (textSpan && (textSpan.textContent.includes('Pro Mode: Use Best Words') || textSpan.textContent.includes('QuickFix Mode: Use Best Words'))) {

            textSpan.textContent = 'Select Optimizations';

          }

        }

      }

    }



    // Show email signup form for all users (QuickFix & Pro) on Step 2

    const emailSignupForm = document.getElementById('proEmailSignupForm');

    if (emailSignupForm) {

      emailSignupForm.style.display = 'block';

    }



    console.log('âœ… Banner updated - Final color:', window.getComputedStyle(quickfixCountHeading).color);

  }



  // Handle "Low Sus" case (0 flags)

  const instructionText = document.getElementById('quickfixInstructionText');

  const fixesTitle = document.getElementById('quickfixFixesTitle');

  const fixesSubtitle = document.getElementById('quickfixFixesSubtitle');

  const applyButton = document.getElementById('applySelectedFixes');

  const copyButton = document.getElementById('copyTextButton');

  const oldUpsellSection = document.getElementById('quickfixUpsellSection');

  const proUpsellBox = document.getElementById('quickfixProUpsellBox');

  const newProBanner = document.getElementById('quickfixProBanner');

  const proStripeText = document.getElementById('proStripeText');

  const goAheadTurnItIn = document.getElementById('goAheadTurnItIn');

  const fixSelectionContainer = document.querySelector('.modern-toggle-container');



  // ALWAYS hide upsell section for Pro users in Step 2 (PRO RESULTS page)

  if (isPro) {

    if (proUpsellBox) {

      proUpsellBox.style.display = 'none';

      proUpsellBox.style.setProperty('display', 'none', 'important');

    }

    if (newProBanner) {

      newProBanner.style.display = 'none';

      newProBanner.style.setProperty('display', 'none', 'important');

    }

  }



  if (isYoureGood) {

    // For Clean No Sus, set quickfixFixedText to the full original text (no flags = no fixes needed)

    // This ensures the copy function will copy the full essay, not just what's displayed

    if (!appState.quickfixFixedText || appState.quickfixFixedText.trim() === '') {

      appState.quickfixFixedText = appState.quickfixOriginalText || text || '';

      console.log('âœ… Set quickfixFixedText to full original text for Clean No Sus, length:', appState.quickfixFixedText.length);

    }



    // Hide instruction text and count heading above essay

    if (instructionText) instructionText.style.display = 'none';

    const quickfixCountHeading = document.getElementById('quickfixCountHeading');

    if (quickfixCountHeading) quickfixCountHeading.style.display = 'none';



    // Change "Choose Your Fixes" to celebratory message

    if (fixesTitle) {

      fixesTitle.textContent = 'This Essay Is Ready To Turn In';

      fixesTitle.style.color = '#2ecc71';

    }

    if (fixesSubtitle) {

      fixesSubtitle.textContent = 'No AI-trigger words detected. Your essay is good to go!';

      fixesSubtitle.style.color = '#2ecc71';

    }



    // Hide fix selection container

    if (fixSelectionContainer) fixSelectionContainer.style.display = 'none';



    const transCopy = document.getElementById('quickfixTransitionCopy');

    if (transCopy) transCopy.style.display = 'none';



    // Keep apply hidden (no fixes), hide duplicate copy button with hand for clean results

    if (applyButton) applyButton.style.display = 'none';

    if (copyButton) copyButton.style.display = 'none'; // Hide duplicate copy button with hand



    // Hide both green CTAs (QuickFix All + Get Another QuickFix) and button group on QF Low Sus Step 1

    const buttonGroup = document.getElementById('quickfixButtonGroup');

    const applyAllBtn = document.getElementById('applyAllFixes');

    if (buttonGroup) { buttonGroup.style.display = 'none'; buttonGroup.style.setProperty('display', 'none', 'important'); }

    if (applyAllBtn) { applyAllBtn.style.display = 'none'; applyAllBtn.style.setProperty('display', 'none', 'important'); }



    // Show Back block only (no green CTAs, no Stripe text)

    const qfLowSusGreenCta = document.getElementById('qfLowSusGreenCta');

    const qfLowSusBackBlock = document.getElementById('qfLowSusBackBlock');

    const step2BackToDashboard = document.getElementById('quickfixStep2BackToDashboard');

    if (qfLowSusGreenCta) { qfLowSusGreenCta.style.display = 'none'; }

    if (qfLowSusBackBlock) { qfLowSusBackBlock.style.display = 'block'; }

    const qfLowSusFyiBestieBlock = document.getElementById('qfLowSusFyiBestieBlock');

    if (qfLowSusFyiBestieBlock) { qfLowSusFyiBestieBlock.style.display = 'block'; }

    const proLowSusDashboardButtons = document.getElementById('proLowSusDashboardButtons');

    if (proLowSusDashboardButtons) { proLowSusDashboardButtons.style.display = 'block'; }

    setTimeout(function() {

      if (typeof showCanvasConfetti === 'function') {

        const lowSusCard = document.getElementById('quickfixYoureGoodCard');

        showCanvasConfetti(lowSusCard);

      }

    }, 300);

    if (step2BackToDashboard) { step2BackToDashboard.style.display = 'none'; step2BackToDashboard.style.setProperty('display', 'none', 'important'); }

    if (proStripeText) { proStripeText.style.display = 'none'; }

    // Show QF upsell box for QF Low Sus Step 1; show Pro Fun Fact graphic for Pro Low Sus Step 1 ONLY

    const proFunFactGraphicProLowSus = document.getElementById('proFunFactGraphicProLowSus');

    if (isPro) {

      // Pro Low Sus Step 1: HIDE QF upsell, SHOW Pro Fun Fact graphic

      if (oldUpsellSection) {

        oldUpsellSection.style.display = 'none';

        oldUpsellSection.style.visibility = 'hidden';

        oldUpsellSection.style.height = '0';

        oldUpsellSection.style.overflow = 'hidden';

        oldUpsellSection.style.margin = '0';

        oldUpsellSection.style.padding = '0';

      }

      if (proFunFactGraphicProLowSus) {

        proFunFactGraphicProLowSus.style.display = 'block';

        proFunFactGraphicProLowSus.style.setProperty('display', 'block', 'important');

      }

      var proTrustedTestimonialLowSus = document.getElementById('proTrustedTestimonialLowSus');

      if (proTrustedTestimonialLowSus) {

        proTrustedTestimonialLowSus.style.display = 'block';

      }

    } else {

      // QF Low Sus Step 1: SHOW QF upsell, HIDE Pro Fun Fact graphic

      if (oldUpsellSection) {

        oldUpsellSection.style.display = 'block';

        oldUpsellSection.style.visibility = 'visible';

        oldUpsellSection.style.margin = '24px 0 16px 0';

        oldUpsellSection.style.padding = '30px 24px';

        oldUpsellSection.style.height = 'auto';

        oldUpsellSection.style.overflow = 'visible';

      }

      if (proFunFactGraphicProLowSus) {

        proFunFactGraphicProLowSus.style.display = 'none';

      }

      if (proTrustedTestimonialLowSus) {

        proTrustedTestimonialLowSus.style.display = 'none';

      }

    }

    // Show upsell box/banner/stripe for free users on clean results; hide for Pro

    // HIDE quickfixProUpsellBox for Clean No Sus (user requested removal)

    if (proUpsellBox) {

      proUpsellBox.style.display = 'none';

      proUpsellBox.style.setProperty('display', 'none', 'important');

    }

    const step2GoProBanner = document.getElementById('quickfixStep2GoProBanner');

    if (!isPro) {

      if (newProBanner) newProBanner.style.display = 'block';

      if (step2GoProBanner) { step2GoProBanner.style.display = 'block'; step2GoProBanner.style.setProperty('display', 'block', 'important'); }

    } else {

      if (newProBanner) {

        newProBanner.style.display = 'none';

        newProBanner.style.setProperty('display', 'none', 'important');

      }

      if (step2GoProBanner) { step2GoProBanner.style.display = 'none'; step2GoProBanner.style.setProperty('display', 'none', 'important'); }

      if (proStripeText) proStripeText.style.display = 'none';

    }

    // Show Lil Sus message and warning text for Clean No Sus ONLY (after Copy Text CTA, above lockbox)

    // CRITICAL: Only show for Clean No Sus (score < 30), NEVER for Hella Sus or Kinda Sus

    const quickfixCleanNoSusLilSusMessage = document.getElementById('quickfixCleanNoSusLilSusMessage');

    console.log('ðŸ” Looking for quickfixCleanNoSusLilSusMessage, found:', !!quickfixCleanNoSusLilSusMessage, 'isYoureGood:', isYoureGood, 'score:', score);

    if (quickfixCleanNoSusLilSusMessage) {

      // ONLY show if score < 30 (Clean No Sus)

      if (isYoureGood && score < 30) {

      quickfixCleanNoSusLilSusMessage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

      quickfixCleanNoSusLilSusMessage.style.setProperty('display', 'none', 'important');

      quickfixCleanNoSusLilSusMessage.style.setProperty('visibility', 'hidden', 'important');

      quickfixCleanNoSusLilSusMessage.style.setProperty('opacity', '0', 'important');

      } else {

        // HIDE for Hella Sus and Kinda Sus

        quickfixCleanNoSusLilSusMessage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

        quickfixCleanNoSusLilSusMessage.style.setProperty('display', 'none', 'important');

        quickfixCleanNoSusLilSusMessage.style.setProperty('visibility', 'hidden', 'important');

        quickfixCleanNoSusLilSusMessage.style.setProperty('opacity', '0', 'important');

        console.log('âœ… HIDDEN QuickFix Lil Sus message for Hella Sus/Kinda Sus (score:', score, ')');

      }

    } else {

      console.error('âŒ quickfixCleanNoSusLilSusMessage element NOT FOUND!');

    }

    const quickfixCleanNoSusCtaUndertext = document.getElementById('quickfixCleanNoSusCtaUndertext');

    if (quickfixCleanNoSusCtaUndertext) {

      quickfixCleanNoSusCtaUndertext.style.display = 'none';

      quickfixCleanNoSusCtaUndertext.style.setProperty('display', 'none', 'important');

    }

    // Removed goAheadTurnItIn - no longer needed for Low Sus

    // Show Copy & Turn It In CTA for BOTH Pro and QF Low Sus Step 1

    const quickfixCopyTextCTA = document.getElementById('quickfixCopyTextCTA');

    const proLowSusTrustedInPlaceOfCopy = document.getElementById('proLowSusTrustedInPlaceOfCopy');

    if (quickfixCopyTextCTA) quickfixCopyTextCTA.style.display = 'block';

    if (proLowSusTrustedInPlaceOfCopy) proLowSusTrustedInPlaceOfCopy.style.display = 'none';

    // Remove whitespace - reduce padding for Low Sus (both Pro and QF)

    const essayContainer = document.getElementById('quickfixEssayContainer');

    if (essayContainer) {

      essayContainer.style.paddingBottom = '0px';

      essayContainer.style.marginBottom = '0px';

    }

    const inputSection = document.querySelector('.input-section');

    if (inputSection) {

      inputSection.style.paddingBottom = '0px';

    }

    if (quickfixCopyTextCTA || proLowSusTrustedInPlaceOfCopy) {

      // Show rotating fun message above percentage for Clean No Sus Step 2

      const cleanNoSusCTA = document.getElementById('quickfixCleanNoSusCTA');

      const cleanNoSusCTAText = document.getElementById('quickfixCleanNoSusCTAText');

      const cleanNoSusCTASubtext = document.getElementById('quickfixCleanNoSusCTASubtext');

      if (cleanNoSusCTA) {

        cleanNoSusCTA.style.display = 'block';

        // Initialize with first message

        currentCleanNoSusStep2MessageIndex = 0;

        const firstMessage = cleanNoSusStep2Messages[0];

        if (cleanNoSusCTAText) {

          cleanNoSusCTAText.textContent = firstMessage.main;

          cleanNoSusCTAText.style.opacity = '1';

        }

        if (cleanNoSusCTASubtext) {

          cleanNoSusCTASubtext.textContent = firstMessage.sub;

          cleanNoSusCTASubtext.style.opacity = '1';

        }

        // Start rotating fun messages for Step 2 Clean No Sus ONLY

        startRotatingCleanNoSusStep2Messages();

      }

      // Hide yellow CTA box for Clean No Sus

      // REMOVED: First duplicate phrase box - always hide it

      const kindaSusCTA = document.getElementById('quickfixKindaSusCTA');

      if (kindaSusCTA) {

        kindaSusCTA.style.display = 'none';

        kindaSusCTA.style.visibility = 'hidden';

        kindaSusCTA.style.opacity = '0';

        kindaSusCTA.style.height = '0';

        kindaSusCTA.style.margin = '0';

        kindaSusCTA.style.padding = '0';

        kindaSusCTA.style.overflow = 'hidden';

      }

      // REMOVED: First duplicate phrase box for Hella Sus - always hide it

      const hellaSusCTA = document.getElementById('quickfixHellaSusCTA');

      if (hellaSusCTA) {

        hellaSusCTA.style.display = 'none';

        hellaSusCTA.style.visibility = 'hidden';

        hellaSusCTA.style.opacity = '0';

        hellaSusCTA.style.height = '0';

        hellaSusCTA.style.margin = '0';

        hellaSusCTA.style.padding = '0';

        hellaSusCTA.style.overflow = 'hidden';

      }

      // QF upsell box and Go Pro banner are now in HTML below Back To Main Dashboard (QF Low Sus Step 1)

      // Reduce padding on button group to decrease space - REMOVE ALL PADDING

      const buttonGroup = document.getElementById('quickfixButtonGroup');

      if (buttonGroup) {

    buttonGroup.style.padding = '48px 0 42px 0';

        buttonGroup.style.margin = '0px';

    buttonGroup.style.display = 'flex'; // Show CTA button group for Low Sus

    buttonGroup.style.setProperty('display', 'flex', 'important');

      }

      // CRITICAL: For Pro users on Clean card, ALWAYS show both CTAs (green Pro All + blue Back to Pro Dashboard)

      if (isPro) {

        const step2BackToDashboard = document.getElementById('quickfixStep2BackToDashboard');

        const step2BackToProDashboard = document.getElementById('step2BackToProDashboard');

        const step2TrustedSection = document.getElementById('step2TrustedSection');

        const applyAllBtn = document.getElementById('applyAllFixes');

        if (step2BackToDashboard) { step2BackToDashboard.style.display = 'none'; step2BackToDashboard.style.setProperty('display', 'none', 'important'); }

        if (step2BackToProDashboard) { step2BackToProDashboard.style.display = 'block'; step2BackToProDashboard.style.setProperty('display', 'block', 'important'); }

        const proStep2BackBtn = document.getElementById('proStep2BackToDashboard');

        if (proStep2BackBtn) { proStep2BackBtn.style.display = 'none'; proStep2BackBtn.style.setProperty('display', 'none', 'important'); }

        // Pro Low Sus Step 1: HIDE Trusted section at bottom (already shown in place of green CTA above)

        if (step2TrustedSection) { step2TrustedSection.style.display = 'none'; step2TrustedSection.style.setProperty('display', 'none', 'important'); }

        if (applyAllBtn) { applyAllBtn.style.display = 'flex'; applyAllBtn.style.setProperty('display', 'flex', 'important'); applyAllBtn.style.visibility = 'visible'; }

      }

      // Hide the animated hand emoji for Clean No Sus

      const quickfixCTAHand = document.getElementById('quickfixCTAHand');

      if (quickfixCTAHand) {

    quickfixCTAHand.style.display = 'none'; // Hide hand emoji for Clean No Sus

      }

      // Also hide the flag explanations section for Low Sus (no fixes needed)

      const flagExplanationsSection = document.getElementById('flagExplanationsSection');

      if (flagExplanationsSection) {

        flagExplanationsSection.style.display = 'none';

      }

      // Remove margin from essay container (already declared above, just update it)

      if (essayContainer) {

        essayContainer.style.marginBottom = '0px';

      }

    }

  } else {

    // Hide green CTA box and clean alert for Hella Sus/Kinda Sus

    const cleanNoSusCTA = document.getElementById('quickfixCleanNoSusCTA');

    if (cleanNoSusCTA) {

      cleanNoSusCTA.style.display = 'none';

    }

    const quickfixStep2CleanAlert = document.getElementById('quickfixStep2CleanAlert');

    if (quickfixStep2CleanAlert) {

      quickfixStep2CleanAlert.style.display = 'none';

    }



    // CRITICAL: Force hide green "clean and ready" message for Hella Sus and Kinda Sus

    const quickfixCleanNoSusLilSusMessage = document.getElementById('quickfixCleanNoSusLilSusMessage');

    if (quickfixCleanNoSusLilSusMessage) {

      quickfixCleanNoSusLilSusMessage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

      quickfixCleanNoSusLilSusMessage.style.setProperty('display', 'none', 'important');

      quickfixCleanNoSusLilSusMessage.style.setProperty('visibility', 'hidden', 'important');

      quickfixCleanNoSusLilSusMessage.style.setProperty('opacity', '0', 'important');

      console.log('âœ… FORCE HIDDEN green clean message for Hella Sus/Kinda Sus (score:', score, ')');

    }



    // Also hide the free results page clean message

    const cleanEssayLilSusMessage = document.getElementById('cleanEssayLilSusMessage');

    if (cleanEssayLilSusMessage) {

      cleanEssayLilSusMessage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

      cleanEssayLilSusMessage.style.setProperty('display', 'none', 'important');

      cleanEssayLilSusMessage.style.setProperty('visibility', 'hidden', 'important');

      cleanEssayLilSusMessage.style.setProperty('opacity', '0', 'important');

      console.log('âœ… FORCE HIDDEN free clean message for Hella Sus/Kinda Sus (score:', score, ')');

    }

    // Show yellow CTA box for Kinda Sus (30-69%), hide for Hella Sus (70+)

    // REMOVED: First duplicate phrase box - always hide it

    const kindaSusCTA = document.getElementById('quickfixKindaSusCTA');

    if (kindaSusCTA) {

      // Always hide the first duplicate phrase box

      kindaSusCTA.style.display = 'none';

      kindaSusCTA.style.visibility = 'hidden';

      kindaSusCTA.style.opacity = '0';

      kindaSusCTA.style.height = '0';

      kindaSusCTA.style.margin = '0';

      kindaSusCTA.style.padding = '0';

      kindaSusCTA.style.overflow = 'hidden';

      console.log('âœ… Hidden first duplicate phrase box for Kinda Sus');

      // REMOVED: Old code that showed the first duplicate phrase box - always hide it now

    }

    // REMOVED: First duplicate phrase box for Hella Sus - always hide it

    const hellaSusCTA = document.getElementById('quickfixHellaSusCTA');

    if (hellaSusCTA) {

      hellaSusCTA.style.display = 'none';

      hellaSusCTA.style.visibility = 'hidden';

      hellaSusCTA.style.opacity = '0';

      hellaSusCTA.style.height = '0';

      hellaSusCTA.style.margin = '0';

      hellaSusCTA.style.padding = '0';

      hellaSusCTA.style.overflow = 'hidden';

      console.log('âœ… Hidden first duplicate phrase box for Hella Sus');

    }

    // Show the animated hand emoji for Hella Sus/Kinda Sus

    const quickfixCTAHand = document.getElementById('quickfixCTAHand');

    if (quickfixCTAHand) {

      quickfixCTAHand.style.display = 'inline-block';

    }

    // Show normal flow for Hella Sus/Kinda Sus

    if (instructionText) instructionText.style.display = 'block';

    if (fixesTitle) {

      fixesTitle.textContent = 'Pick Your Fixes';

      fixesTitle.style.color = '#dc2626';

    }

    if (fixesSubtitle) {

      fixesSubtitle.textContent = 'You can auto-fix all high-risk words at once, or customize each one below.';

      fixesSubtitle.style.color = '#6b7280';

    }

    if (fixSelectionContainer) fixSelectionContainer.style.display = 'block';

    const transCopy = document.getElementById('quickfixTransitionCopy');

    if (transCopy) transCopy.style.display = 'block';

    // FORCE show button group and apply button for Hella Sus/Kinda Sus

    const buttonGroup = document.getElementById('quickfixButtonGroup');

    if (buttonGroup) {

      buttonGroup.style.display = 'flex';

      buttonGroup.style.setProperty('display', 'flex', 'important');

      buttonGroup.style.padding = '48px 0 42px 0';

      buttonGroup.style.margin = '0';

    }

    if (applyButton) {

      // Show button for Pro Step 2 Hella Sus and Kinda Sus (score >= 30)

      // Only hide for Clean cases (score < 30)

      const step2 = document.getElementById('quickfixStep2');

      const isStep2Active = step2 && (step2.style.display !== 'none' && step2.classList.contains('active'));

      const isPro = appState.isProUser || false;

      const currentScore = appState.quickfixOriginalScore || appState.proOriginalScore || 0;

      const isHellaSusOrKindaSus = currentScore >= 30;



      if (isPro && isStep2Active && !isHellaSusOrKindaSus) {

        // Hide the button only for Clean cases in Pro Step 2

        applyButton.style.display = 'none';

        applyButton.style.setProperty('display', 'none', 'important');

        applyButton.style.visibility = 'hidden';

        applyButton.style.setProperty('visibility', 'hidden', 'important');

        applyButton.style.opacity = '0';

        applyButton.style.setProperty('opacity', '0', 'important');

        applyButton.style.height = '0';

        applyButton.style.setProperty('height', '0', 'important');

        applyButton.style.margin = '0';

        applyButton.style.setProperty('margin', '0', 'important');

        applyButton.style.padding = '0';

        applyButton.style.setProperty('padding', '0', 'important');

      } else {

        // Show button for Hella Sus, Kinda Sus, or non-Pro users

        applyButton.style.display = 'inline-block';

        applyButton.style.setProperty('display', 'inline-block', 'important');

        applyButton.style.visibility = 'visible';

        applyButton.style.setProperty('visibility', 'visible', 'important');

        applyButton.style.opacity = '1';

        applyButton.style.setProperty('opacity', '1', 'important');

        applyButton.style.height = 'auto';

        applyButton.style.margin = '';

        applyButton.style.padding = '';



        // CRITICAL: For Pro users on Step 2, ensure button is BLUE and says "Pro (Selected Words Only (X))"

        if (isPro && isStep2Active && isHellaSusOrKindaSus) {

          applyButton.style.setProperty('background', '#00a8e8', 'important');

          applyButton.style.setProperty('color', 'white', 'important');

          // Update text to "Pro (Selected Words Only (X))"

          const selectedCountEl = applyButton.querySelector('#selectedCount');

          const currentCount = selectedCountEl ? selectedCountEl.textContent : '0';

          applyButton.innerHTML = `Pro (Selected Words Only (<span id="selectedCount">${currentCount}</span>))`;

          console.log('âœ… Blue CTA ensured visible for Pro Step 2 Hella Sus/Kinda Sus in displayQuickFixAnalysis');

        }

      }

    }

    if (copyButton) copyButton.style.display = 'none';

    const copyTextContainer = document.getElementById('copyTextContainer');

    if (copyTextContainer) copyTextContainer.style.display = 'none';

    // Hide QF Low Sus specific blocks for Hella/Kinda Sus

    const qfLowSusGreenCtaHide = document.getElementById('qfLowSusGreenCta');

    const qfLowSusBackBlockHide = document.getElementById('qfLowSusBackBlock');

    const qfLowSusFyiBestieHide = document.getElementById('qfLowSusFyiBestieBlock');

    if (qfLowSusGreenCtaHide) { qfLowSusGreenCtaHide.style.display = 'none'; }

    if (qfLowSusBackBlockHide) { qfLowSusBackBlockHide.style.display = 'none'; }

    if (qfLowSusFyiBestieHide) { qfLowSusFyiBestieHide.style.display = 'none'; }

    // Hide green box and Go Pro banner completely for Hella Sus/Kinda Sus; hide Pro Fun Fact graphic (Pro Low Sus ONLY)

    if (oldUpsellSection) {

      oldUpsellSection.style.display = 'none';

      oldUpsellSection.style.visibility = 'hidden';

      oldUpsellSection.style.margin = '0';

      oldUpsellSection.style.padding = '0';

      oldUpsellSection.style.height = '0';

      oldUpsellSection.style.overflow = 'hidden';

    }

    const proFunFactGraphicProLowSusHide = document.getElementById('proFunFactGraphicProLowSus');

    if (proFunFactGraphicProLowSusHide) {

      proFunFactGraphicProLowSusHide.style.display = 'none';

      proFunFactGraphicProLowSusHide.style.setProperty('display', 'none', 'important');

    }

    const step2GoProBannerHellaKinda = document.getElementById('quickfixStep2GoProBanner');

    if (step2GoProBannerHellaKinda) {

      step2GoProBannerHellaKinda.style.display = 'none';

      step2GoProBannerHellaKinda.style.setProperty('display', 'none', 'important');

    }

    // Only show upsell if NOT Pro user

    if (!isPro) {

      if (proUpsellBox) proUpsellBox.style.display = 'block';

    } else {

      if (proUpsellBox) {

        proUpsellBox.style.display = 'none';

        proUpsellBox.style.setProperty('display', 'none', 'important');

      }

    }

    if (newProBanner) newProBanner.style.display = 'none';

    if (proStripeText) proStripeText.style.display = 'none';

    // Removed goAheadTurnItIn - no longer exists

    const quickfixCopyTextCTA = document.getElementById('quickfixCopyTextCTA');

    const proLowSusTrustedInPlaceOfCopy = document.getElementById('proLowSusTrustedInPlaceOfCopy');

    if (quickfixCopyTextCTA) quickfixCopyTextCTA.style.display = 'none';

    if (proLowSusTrustedInPlaceOfCopy) proLowSusTrustedInPlaceOfCopy.style.display = 'none';

    // Reset bottom padding for other cases

    const inputSection = document.querySelector('.input-section');

    if (inputSection) {

      inputSection.style.paddingBottom = '';

    }

  }



  // Update progress indicator position and color

  updateProgressIndicator(score);



  // Create flagged content with CORRECT NUMBERED highlights (in order of appearance)

  let flaggedContent = text;



  // Use only real flags from detection - no placeholder flags

  // If no flags are detected, that's the real result



  // Sort flags by their position in the text, but distinguish structural vs text-phrase flags

  const lowerText = text.toLowerCase();



  // Keywords that usually indicate structural / meta flags (not literal phrases in the essay)

  const structuralKeywords = [

    'no contractions',

    'no personal voice',

    'overly formal',

    'overall writing',

    'overall patterns',

    'overall text',

    'lacks human',

    'too formal'

  ];



  const textPhraseFlags = [];

  const structuralFlags = [];



  (flags || []).forEach(flag => {

    const rawPhrase = (flag.phrase || flag.text || '').trim();

    if (!rawPhrase) return;



    const phrase = rawPhrase.toLowerCase();

    const isStructural = structuralKeywords.some(kw => phrase.includes(kw));

    const position = lowerText.indexOf(phrase);



    if (!isStructural && position !== -1) {

      textPhraseFlags.push({ ...flag, position });

    } else if (isStructural) {

      structuralFlags.push(flag);

    }

  });



  const sortedFlags = textPhraseFlags.sort((a, b) => a.position - b.position);



  // CRITICAL: Update appState.quickfixFlags to sorted order so indices match

  appState.quickfixFlags = sortedFlags;



  // Apply highlights in correct order

  // For Clean No Sus (score < 30), use light green styling

  // For Sus cases, use red/orange styling

  // CRITICAL: Number ALL occurrences sequentially as they appear in the text (not by flag index)

  // First, find ALL occurrences of ALL flags and sort by position

  const allOccurrences = [];

  sortedFlags.forEach((flag, flagIndex) => {

    const phrase = flag.phrase;

    const regex = new RegExp(phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

    let match;

    const lowerText = flaggedContent.toLowerCase();

    const phraseLower = phrase.toLowerCase();



    // Find all occurrences of this phrase

    let searchStart = 0;

    while ((match = regex.exec(flaggedContent)) !== null) {

      const position = match.index;

      // Check if this position overlaps with an already processed occurrence

      const overlaps = allOccurrences.some(occ => {

        const occEnd = occ.position + occ.phrase.length;

        const thisEnd = position + phrase.length;

        return (position >= occ.position && position < occEnd) ||

               (occ.position >= position && occ.position < thisEnd);

      });



      if (!overlaps) {

        allOccurrences.push({

          flagIndex: flagIndex,

          phrase: phrase,

          match: match[0],

          position: position,

          flag: flag

        });

      }

      // Move search forward to avoid infinite loop

      regex.lastIndex = position + 1;

    }

  });



  // Sort all occurrences by position in text

  allOccurrences.sort((a, b) => a.position - b.position);



  // Track first occurrence of each unique phrase for numbering

  const phraseFirstOccurrence = new Map(); // phraseLower -> first occurrence index

  const phraseNumberMap = new Map(); // phraseLower -> assigned number

  let currentNumber = 1;



  // Assign numbers to first occurrence of each unique phrase

  allOccurrences.forEach((occ, idx) => {

    const phraseLower = occ.phrase.toLowerCase();

    if (!phraseFirstOccurrence.has(phraseLower)) {

      phraseFirstOccurrence.set(phraseLower, idx);

      phraseNumberMap.set(phraseLower, currentNumber);

      currentNumber++;

    }

  });



  // Now apply highlights with sequential numbering

  // Process in reverse order to preserve positions

  for (let i = allOccurrences.length - 1; i >= 0; i--) {

    const occ = allOccurrences[i];

    const flag = occ.flag;

    const flagIndex = occ.flagIndex;

    const phrase = occ.phrase;

    const match = occ.match;

    const phraseLower = phrase.toLowerCase();



    // Check if this is the first occurrence of this phrase

    const isFirstOccurrence = phraseFirstOccurrence.get(phraseLower) === i;

    const flagNumber = isFirstOccurrence ? phraseNumberMap.get(phraseLower) : null;



    // ALL flags get yellow highlight - no distinction by risk level

    const highlightClass = 'flag-highlight-red';

    const tooltipText = isCleanNoSus 

      ? 'Optional optimization - Click to see suggested alternatives'

      : 'AI trigger word - Click to see fix details';



    let tooltipBorderColor;

    if (score < 30) {

      tooltipBorderColor = '#2ecc71';

    } else if (score >= 30 && score < 70) {

      tooltipBorderColor = '#f59e0b';

    } else {

      tooltipBorderColor = '#dc2626';

    }



    const escapedTooltipText = tooltipText.replace(/"/g, '&quot;').replace(/'/g, '&#39;');



    // First occurrence = bright yellow (#FFF000), duplicates = light yellow (#FFFACD)

    const highlightBg = isFirstOccurrence ? '#FFF000' : '#FFFACD';



    // Replace this specific occurrence

    const before = flaggedContent.substring(0, occ.position);

    const after = flaggedContent.substring(occ.position + phrase.length);



    // Only add number badge for first occurrence

    const numberBadge = flagNumber !== null 

      ? `<sup class="flag-number" onclick="scrollToFixOption(${flagIndex})" style="background: #FFFACD; color: #dc2626; border-radius: 50%; width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 700; margin-left: 2px; vertical-align: super; line-height: 1; flex-shrink: 0; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'" title="Click to see in dropdown">${flagNumber}</sup>`

      : '';



    const replacement = `<span class="${highlightClass}" onclick="scrollToFixOption(${flagIndex})" style="background: ${highlightBg}; color: #0b0646; cursor: pointer;" data-tooltip="${escapedTooltipText}" data-tooltip-border="${tooltipBorderColor}" onmouseenter="showFlagTooltip(event, '${escapedTooltipText}', '${tooltipBorderColor}')" onmouseleave="hideFlagTooltip()">${match}${numberBadge}</span>`;



    flaggedContent = before + replacement + after;

  }



  console.log('Flagged content:', flaggedContent);

  console.log('Flags found (shown in essay):', flags.length);

  console.log('Sorted flags:', flags.length > 0 ? sortedFlags : 'No flags');



  // Update dynamic flag counts (use TOTAL, not just topâ€‘5 shown)

  const totalFlagCountForCounts = Array.isArray(appState.quickfixFlagsOriginal)

    ? appState.quickfixFlagsOriginal.length

    : flagCount;

  updateDynamicFlagCounts(totalFlagCountForCounts);



  const flaggedDiv = document.getElementById('flaggedEssayContent');

  console.log('Flagged div found:', flaggedDiv);



  if (flaggedDiv) {

    // CRITICAL: Set border color based on score - BOTH left and right borders

    // Red for Hella Sus (score >= 70), Yellow/Amber for Kinda Sus (30-69), Green for Clean No Sus (score < 30)

    let borderColor;

    if (score < 30) {

      borderColor = '#2ecc71'; // Green for Clean No Sus

    } else if (score >= 30 && score < 70) {

      borderColor = '#f59e0b'; // Amber/Yellow for Kinda Sus

    } else {

      borderColor = '#dc2626'; // Red for Hella Sus

    }



    // Set BOTH left and right borders to match score color

    flaggedDiv.style.borderLeft = `4px solid ${borderColor}`;

    flaggedDiv.style.borderRight = `4px solid ${borderColor}`;



    // Add "YOUR ESSAY PREVIEW:" label and green left border for You're Good case

    if (isYoureGood) {

      // Limit to first 5-7 lines for Clean No Sus preview (use original text, not flaggedContent)

      const originalText = text || '';

      const lines = originalText.split('\n').filter(line => line.trim().length > 0);

      const previewLines = lines.slice(0, 5); // First 5 non-empty lines

      let previewText = previewLines.join('\n');

      // Limit to 500 characters max

      if (previewText.length > 500) {

        previewText = previewText.substring(0, 500) + '...';

      }

      // Escape HTML to prevent XSS

      const escapedPreview = previewText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');



      flaggedDiv.innerHTML = `<div style="font-weight: 700; color: #374151; margin-bottom: 12px; font-size: 14px; text-align: center;">Your Essay Preview:</div><p>${escapedPreview}</p>`;

    } else {

      flaggedDiv.innerHTML = `<p>${flaggedContent}</p>`;

    }

    flaggedDiv.style.display = 'block';

    flaggedDiv.style.visibility = 'visible';

    flaggedDiv.style.opacity = '1';

    console.log('Content set successfully');

  } else {

    console.error('flaggedEssayContent div not found!');

  }



  // Create numbered fix options with checkboxes AND ADD ALTERNATIVES

  let fixOptionsHtml = '';

  sortedFlags.forEach((flag, index) => {

    const flagIndex = index; // Use index for flag references (0, 1, 2...)

    const severityEmoji = flag.severity === 'high' ? 'ðŸ”´' : 'ðŸŸ ';

    const badgeColor = '#fee2e2'; // Light red for all badges (consistent coloring)



    // Helper function to generate alternatives HTML - simplified design

    function generateAlternativesHTML(flagIdx, phrase, suggestions, isOriginal = true) {

      const escapedPhrase = phrase.replace(/'/g, "\\'");

      const originalBestWord = suggestions[0]; // Store the first/best word

      const escapedBestWord = originalBestWord.replace(/'/g, "\\'");

      let buttonsHtml = '';

      suggestions.forEach((suggestion, idx) => {

        const escapedSuggestion = suggestion.replace(/'/g, "\\'");

        buttonsHtml += `<button class="alt-word-btn" data-flag-index="${flagIndex}" data-word="${escapedSuggestion}" style="background:white; border:1px solid #d1d5db; color:#374151; padding:4px 10px; border-radius:6px; font-size:12px; cursor:pointer; margin:2px 4px 2px 0; font-weight:400; transition:all 0.2s;">${suggestion}</button>`;

      });



      // Store suggestions as JSON string (will be properly escaped by HTML)

      const suggestionsJson = JSON.stringify(suggestions);



      return `<div style="margin-top:12px;">

        <div style="margin-bottom:8px;">

          <span style="font-size:13px; color:#6b7280; font-weight:500;">More Word Options:</span>

        </div>

        <div class="suggestions-container" data-flag-index="${flagIndex}" data-original-phrase="${escapedPhrase}" data-original-best-word="${escapedBestWord}" data-original-suggestions='${suggestionsJson}'>

          ${buttonsHtml}

        </div>



        <!-- Show Me More Button -->

        <div style="margin-top:8px; display:flex; align-items:center; gap:6px;">

          <button onclick="searchSynonymsForFlag(${flagIndex}, '${escapedPhrase}')" 

                  class="find-more-synonyms-btn"

                  data-flag-index="${flagIndex}"

                  style="background:#3b82f6; color:white; border:none; padding:4px 12px; border-radius:4px; font-size:11px; cursor:pointer; font-weight:500; transition:all 0.2s; display:flex; align-items:center; gap:4px;"

                  onmouseover="this.style.background='linear-gradient(to bottom, #0087c4, #06082e)'"

                  onmouseout="this.style.background='linear-gradient(to bottom, #00a8e8, #0b0646)'"

                  title="Show more synonyms of '${escapedPhrase}' using Claude">

            ðŸ” Show Me More

          </button>

        </div>



        <!-- Search Results Container -->

        <div class="search-results-container" data-flag-index="${flagIndex}" style="margin-top:8px; display:none;">

          <div class="search-loading" style="font-size:11px; color:#6b7280; display:none;">ðŸ” Searching Claude database...</div>

          <div class="search-results" style="display:flex; flex-wrap:wrap; gap:4px;"></div>

        </div>



        <!-- Optional: Try Your Own Word Section -->

        <div style="margin-top:10px; padding-top:8px; border-top:1px solid #e5e7eb;">

          <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">

            <span style="font-size:12px; color:#6b7280; font-weight:500;">Optional: Try Your Own Word</span>

          </div>

          <div style="display:flex; gap:4px; align-items:center;">

            <input type="text" 

                   class="custom-word-input" 

                   data-flag-index="${flagIndex}"

                   placeholder="Type Your Own Word Here" 

                   style="font-size:11px; padding:4px 8px; border:1px solid #d1d5db; border-radius:4px; flex:1; max-width:200px; color:#374151;"

                   onkeypress="if(event.key==='Enter') { event.preventDefault(); addCustomWord(${flagIndex}); }"

                   title="Type your own word to add as an option">

            <button onclick="addCustomWord(${flagIndex})" 

                    class="add-custom-word-btn"

                    data-flag-index="${flagIndex}"

                    style="background:#2ecc71; color:white; border:none; padding:4px 12px; border-radius:4px; font-size:11px; cursor:pointer; font-weight:500; transition:all 0.2s;"

                    onmouseover="this.style.background='#22c55e'"

                    onmouseout="this.style.background='#2ecc71'"

                    title="Add your custom word as an option">

              âž• Add

            </button>

          </div>

          <div style="font-size:10px; color:#9ca3af; margin-top:4px;">Hover over your custom word and click <strong style="color:#dc2626;">delete</strong> to remove it from the list.</div>

        </div>

      </div>`;

    }



    // Search synonyms using Claude API - searches for MORE synonyms of the original flagged phrase

    async function searchSynonymsForFlag(flagIndex, searchTerm) {

      const resultsContainer = document.querySelector(`.search-results-container[data-flag-index="${flagIndex}"]`);

      const loadingDiv = resultsContainer?.querySelector('.search-loading');

      const resultsDiv = resultsContainer?.querySelector('.search-results');

      const findMoreBtn = document.querySelector(`.find-more-synonyms-btn[data-flag-index="${flagIndex}"]`);



      if (!resultsContainer || !loadingDiv || !resultsDiv) {

        console.warn('Search container not found for flag index:', flagIndex);

        return;

      }



      // Use provided search term, or get the original flagged phrase

      let searchTermTrimmed = '';

      if (searchTerm && searchTerm.trim().length > 0) {

        searchTermTrimmed = searchTerm.trim();

      } else {

        // Get the original flagged phrase

        const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${flagIndex}"]`);

        const originalPhrase = suggestionsContainer?.getAttribute('data-original-phrase') || '';

        if (!originalPhrase) {

          console.warn('No original phrase found for flag index:', flagIndex);

          return;

        }

        searchTermTrimmed = originalPhrase;

      }



      // Show loading state

      resultsContainer.style.display = 'block';

      loadingDiv.style.display = 'block';

      resultsDiv.innerHTML = '';

      if (findMoreBtn) {

        findMoreBtn.disabled = true;

        findMoreBtn.style.opacity = '0.6';

        findMoreBtn.style.cursor = 'not-allowed';

      }



      try {

        // Get the original phrase for context

        const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${flagIndex}"]`);

        const originalPhrase = suggestionsContainer?.getAttribute('data-original-phrase') || searchTermTrimmed;



        console.log(`ðŸ” Searching synonyms for "${searchTermTrimmed}" (original phrase: "${originalPhrase}")`);



        // Call API endpoint

        const response = await fetch('/api/search-synonyms', {

          method: 'POST',

          headers: {

            'Content-Type': 'application/json'

          },

          body: JSON.stringify({

            word: searchTermTrimmed,

            context: `Replacement for "${originalPhrase}" in academic/professional writing`

          })

        });



        if (!response.ok) {

          const errorData = await response.json().catch(() => ({}));

          throw new Error(`API error: ${response.status} - ${errorData.message || 'Unknown error'}`);

        }



        const data = await response.json();

        const synonyms = data.synonyms || [];



        console.log(`âœ… Found ${synonyms.length} synonyms for "${searchTermTrimmed}"`);



        // Hide loading, show results

        loadingDiv.style.display = 'none';



        if (synonyms.length === 0) {

          resultsDiv.innerHTML = '<span style="font-size:11px; color:#9ca3af;">No additional synonyms found. Try a different search term.</span>';

        } else {

          // Add each synonym as a clickable button

          synonyms.forEach(synonym => {

            // Skip if this synonym already exists in the original suggestions

            const existingBtns = document.querySelectorAll(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

            const alreadyExists = Array.from(existingBtns).some(btn => btn.getAttribute('data-word') === synonym);

            if (alreadyExists) return;



            const btn = document.createElement('button');

            btn.className = 'alt-word-btn search-result-btn';

            btn.setAttribute('data-flag-index', flagIndex);

            btn.setAttribute('data-word', synonym);

            btn.textContent = synonym;

            btn.style.cssText = 'background:white; border:1px solid #2ecc71; color:#2ecc71; padding:4px 10px; border-radius:6px; font-size:12px; cursor:pointer; margin:2px 4px 2px 0; font-weight:400; transition:all 0.2s;';

            btn.onmouseover = function() {

              this.style.background = '#f0fdf4';

              this.style.borderColor = '#22c55e';

            };

            btn.onmouseout = function() {

              this.style.background = 'white';

              this.style.borderColor = '#2ecc71';

            };

            btn.onclick = function() {

              // Select this word (same behavior as clicking other alt-word-btn)

              const allBtns = document.querySelectorAll(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

              allBtns.forEach(b => {

                b.style.background = 'white';

                b.style.borderColor = '#d1d5db';

                b.style.color = '#374151';

                b.style.fontWeight = '400';

                b.classList.remove('selected-word');

              });



              // Highlight search result buttons differently

              const searchResultBtns = document.querySelectorAll(`.search-result-btn[data-flag-index="${flagIndex}"]`);

              searchResultBtns.forEach(b => {

                if (b !== this) {

                  b.style.background = 'white';

                  b.style.borderColor = '#2ecc71';

                  b.style.color = '#2ecc71';

                }

              });



              this.style.background = '#2ecc71';

              this.style.borderColor = '#2ecc71';

              this.style.color = 'white';

              this.style.fontWeight = '600';

              this.classList.add('selected-word');



              // Auto-check the checkbox for this fix option

              const checkbox = document.getElementById(`fix-${flagIndex}`);

              if (checkbox && !checkbox.checked) {

                checkbox.checked = true;

                checkbox.dispatchEvent(new Event('change', { bubbles: true }));

              }



              // Update preview

              setTimeout(() => updateScorePreview(), 50);

            };

            resultsDiv.appendChild(btn);

          });

        }

      } catch (error) {

        console.error('Error searching synonyms:', error);

        loadingDiv.style.display = 'none';

        resultsDiv.innerHTML = `<span style="font-size:11px; color:#dc2626;">Search failed: ${error.message}. Please try again.</span>`;

      } finally {

        if (findMoreBtn) {

          findMoreBtn.disabled = false;

          findMoreBtn.style.opacity = '1';

          findMoreBtn.style.cursor = 'pointer';

        }

      }

    }



    // Add custom word that user types themselves

    function addCustomWord(flagIndex) {

      const customInput = document.querySelector(`.custom-word-input[data-flag-index="${flagIndex}"]`);

      if (!customInput) {

        console.warn('Custom word input not found for flag index:', flagIndex);

        return;

      }



      const customWord = customInput.value.trim();

      if (!customWord || customWord.length === 0) {

        return;

      }



      // Check if word already exists

      const existingBtns = document.querySelectorAll(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

      const alreadyExists = Array.from(existingBtns).some(btn => btn.getAttribute('data-word').toLowerCase() === customWord.toLowerCase());



      if (alreadyExists) {

        // Show brief feedback

        customInput.style.borderColor = '#f59e0b';

        setTimeout(() => {

          customInput.style.borderColor = '#d1d5db';

        }, 2000);

        return;

      }



      // Add the custom word as a badge with X to remove

      const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${flagIndex}"]`);

      if (!suggestionsContainer) {

        console.warn('Suggestions container not found for flag index:', flagIndex);

        return;

      }



      const wrapper = document.createElement('span');

      wrapper.className = 'custom-word-badge-wrapper';

      wrapper.style.cssText = 'position:relative; display:inline-flex; flex-direction:column; align-items:flex-start; margin:2px 4px 6px 0; overflow:visible; vertical-align:top;';



      const btn = document.createElement('button');

      btn.className = 'alt-word-btn custom-word-btn';

      btn.setAttribute('data-flag-index', flagIndex);

      btn.setAttribute('data-word', customWord);

      btn.textContent = customWord;

      btn.style.cssText = 'background:white; border:1px solid #1e40af; color:#1e40af; padding:4px 10px; border-radius:6px; font-size:12px; cursor:pointer; font-weight:500; transition:all 0.2s;';

      btn.onmouseover = function() {

        this.style.background = '#eff6ff';

        this.style.borderColor = '#2563eb';

        this.style.color = '#1e40af';

      };

      btn.onmouseout = function() {

        this.style.background = 'white';

        this.style.borderColor = '#1e40af';

        this.style.color = '#1e40af';

      };

      btn.onclick = function(e) {

        e.stopPropagation();

        const allBtns = document.querySelectorAll(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

        allBtns.forEach(b => {

          b.style.background = 'white';

          b.style.borderColor = b.classList.contains('custom-word-btn') ? '#1e40af' : '#d1d5db';

          b.style.color = b.classList.contains('custom-word-btn') ? '#1e40af' : '#374151';

          b.style.fontWeight = b.classList.contains('custom-word-btn') ? '500' : '400';

          b.classList.remove('selected-word');

          const w = b.closest('.custom-word-badge-wrapper');

          if (w) {

            const removeLink = w.querySelector('.custom-word-remove-link');

            if (removeLink) removeLink.style.visibility = 'hidden';

          }

        });

        this.style.background = '#3b82f6';

        this.style.borderColor = '#3b82f6';

        this.style.color = 'white';

        this.style.fontWeight = '600';

        this.classList.add('selected-word');

        const checkbox = document.getElementById(`fix-${flagIndex}`);

        if (checkbox && !checkbox.checked) {

          checkbox.checked = true;

          checkbox.dispatchEvent(new Event('change', { bubbles: true }));

        }

        setTimeout(() => updateScorePreview(), 50);

      };



      function doRemoveCustomWord(e) {

        e.stopPropagation();

        e.preventDefault();

        const wasSelected = btn.classList.contains('selected-word');

        wrapper.remove();

        if (wasSelected && appState.quickfixFlags && appState.quickfixFlags[flagIndex]) {

          const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${flagIndex}"]`);

          const originalBestWord = suggestionsContainer?.getAttribute('data-original-best-word');

          if (originalBestWord) {

            appState.quickfixFlags[flagIndex].suggestedFix = originalBestWord;

          }

          const checkbox = document.getElementById(`fix-${flagIndex}`);

          const firstRemaining = document.querySelector(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

          if (firstRemaining) {

            firstRemaining.click();

          } else {

            if (checkbox && checkbox.checked) {

              checkbox.checked = false;

              checkbox.dispatchEvent(new Event('change', { bubbles: true }));

            }

          }

        }

        if (typeof updateScorePreview === 'function') {

          setTimeout(() => updateScorePreview(), 50);

        }

        if (typeof updateSelectedCount === 'function') {

          updateSelectedCount();

        }

      }



      const removeLink = document.createElement('button');

      removeLink.type = 'button';

      removeLink.className = 'custom-word-remove-link';

      removeLink.setAttribute('aria-label', 'Remove this word');

      removeLink.textContent = 'delete';

      removeLink.style.cssText = 'visibility:hidden; margin-top:2px; padding:0; border:none; background:transparent; color:#dc2626; font-size:11px; cursor:pointer; font-weight:600; text-decoration:underline; line-height:1.2;';

      removeLink.onclick = doRemoveCustomWord;

      removeLink.onmouseover = function() {

        this.style.color = '#b91c1c';

      };

      removeLink.onmouseout = function() {

        this.style.color = '#dc2626';

      };



      wrapper.onmouseenter = function() {

        removeLink.style.visibility = 'visible';

      };

      wrapper.onmouseleave = function() {

        removeLink.style.visibility = 'hidden';

      };



      wrapper.appendChild(btn);

      wrapper.appendChild(removeLink);

      suggestionsContainer.appendChild(wrapper);



      // Clear the input

      customInput.value = '';



      // Brief visual feedback

      customInput.style.borderColor = '#2ecc71';

      setTimeout(() => {

        customInput.style.borderColor = '#d1d5db';

      }, 1000);

    }



    // Make functions globally available

    window.searchSynonymsForFlag = searchSynonymsForFlag;

    window.addCustomWord = addCustomWord;



    // Add alternative suggestions based on the flagged phrase as clickable buttons

    let alternatives = '';

    if (flag.phrase.toLowerCase().includes('unprecedented')) {

      alternatives = generateAlternativesHTML(flagIndex, flag.phrase, ['exceptional results', 'remarkable outcomes', 'significant improvements']);

    } else if (flag.phrase.toLowerCase().includes('cutting-edge') || flag.phrase.toLowerCase().includes('cutting edge') || flag.phrase.toLowerCase() === 'cutting-edge') {

      alternatives = generateAlternativesHTML(flagIndex, flag.phrase, ['innovative', 'modern', 'forward-thinking', 'advanced']);

    } else if (flag.phrase.toLowerCase().includes('leverage')) {

      alternatives = generateAlternativesHTML(flagIndex, flag.phrase, ['use', 'employ', 'utilize', 'make use of']);

    } else if (flag.phrase.toLowerCase().includes('furthermore')) {

      alternatives = generateAlternativesHTML(flagIndex, flag.phrase, ['also', 'plus', 'and']);

    } else if (flag.phrase.toLowerCase().includes('moreover')) {

      alternatives = generateAlternativesHTML(flagIndex, flag.phrase, ['plus', 'also', 'and']);

    } else if (flag.phrase.toLowerCase().includes('additionally')) {

      alternatives = generateAlternativesHTML(flagIndex, flag.phrase, ['also', 'plus', 'and']);

    } else if (flag.phrase.toLowerCase().includes('therefore')) {

      alternatives = generateAlternativesHTML(flagIndex, flag.phrase, ['so', 'that\'s why']);

    } else if (flag.phrase.toLowerCase().includes('consequently')) {

      alternatives = generateAlternativesHTML(flagIndex, flag.phrase, ['so', 'as a result']);

    } else {

      // FALLBACK: For ANY flagged word that doesn't match specific phrases, show AT LEAST 3 alternatives

      // This ensures ALL flagged words get multiple alternative buttons dynamically

      if (flag.suggestedFix && flag.suggestedFix !== flag.phrase) {

        // Generate at least 3 alternatives based on the suggested fix

        const suggestedFix = flag.suggestedFix;

        let alt1 = suggestedFix;

        let alt2 = '';

        let alt3 = '';



        // Generate additional alternatives based on common patterns

        if (suggestedFix === 'use') {

          alt2 = 'employ';

          alt3 = 'utilize';

        } else if (suggestedFix === 'but') {

          alt2 = 'though';

          alt3 = 'yet';

        } else if (suggestedFix === 'also') {

          alt2 = 'plus';

          alt3 = 'and';

        } else if (suggestedFix === 'important') {

          alt2 = 'key';

          alt3 = 'crucial';

        } else if (suggestedFix === 'show') {

          alt2 = 'demonstrate';

          alt3 = 'reveal';

        } else if (suggestedFix === 'so') {

          alt2 = 'therefore';

          alt3 = 'thus';

        } else {

          // Generic alternatives - add variations

          alt2 = suggestedFix + ' more';

          alt3 = 'better ' + suggestedFix;

        }



        alternatives = generateAlternativesHTML(flagIndex, flag.phrase, [alt1, alt2, alt3].filter(a => a));

      }

    }



    const briefReasonRaw = (flag.explanation || flag.reason || '').replace(/`/g, '').trim();

    const briefReason = briefReasonRaw.length > 140 ? briefReasonRaw.slice(0, 137) + 'â€¦' : briefReasonRaw;

    const reasonText = briefReason || 'This phrase often looks AI-generated or overly formal to detectors.';



    fixOptionsHtml += 

      `<div class="fix-option" data-index="${flagIndex}" style="background:white; border:1px solid #e5e7eb; border-radius:12px; padding:16px; margin-bottom:12px; box-shadow:0 1px 3px rgba(0,0,0,0.1); transition:all 0.2s;">

        <div style="display:flex; align-items:flex-start; gap:12px;">

          <div style="margin-top:2px;">

            <input type="checkbox" id="fix-${flagIndex}" class="custom-checkbox" style="width:20px; height:20px; cursor:pointer;">

          </div>

          <div style="flex:1;">

            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">

              <span style="display:inline-flex; align-items:center; justify-content:center; min-width:22px; height:22px; border-radius:999px; background:#fee2e2; color:#dc2626; font-size:12px; font-weight:700;">${index + 1}</span>

              <span style="color:#dc2626; font-size:14px; font-weight:700;">"${flag.phrase}"</span>

              <span style="color:#374151; font-size:14px;">â†’</span>

              <span style="color:#2ecc71; font-size:14px; font-weight:600;">${flag.suggestedFix}</span>

            </div>

            <div style="font-size:12px; color:#6b7280; margin-bottom:8px; line-height:1.4;">

              ${reasonText}

            </div>

            ${alternatives ? `<div class="fix-alternatives">${alternatives}</div>` : ''}

          </div>

        </div>

      </div>`;

  });



  // Build structural advice cards (for structural flags whose phrases don't appear in the text)

  let structuralAdviceHtml = '';

  if (structuralFlags.length > 0) {

    structuralAdviceHtml += `

      <div style="margin-top: 16px; padding-top: 8px; border-top: 1px dashed #e5e7eb;">

        <h4 style="font-size: 14px; font-weight: 700; color: #374151; margin: 0 0 8px 0;">ðŸ’¡ General Writing Improvements</h4>

    `;



    structuralFlags.forEach(flag => {

      const explanation = flag.explanation || flag.reason || 'AI pattern detected in overall writing.';

      const alts = Array.isArray(flag.alternatives) ? flag.alternatives : [];



      structuralAdviceHtml += `

        <div style="background: #fff7ed; border-left: 4px solid #fb923c; padding: 10px 12px; margin: 6px 0; border-radius: 6px;">

          <p style="margin: 0 0 4px 0; font-size: 13px; color: #92400e;"><strong>âš ï¸ ${flag.phrase || 'Writing tip'}</strong></p>

          <p style="margin: 0; font-size: 13px; color: #6b7280; line-height: 1.4;">${explanation}</p>

          ${alts.length > 0 ? `

            <div style="margin-top: 6px; font-size: 12px; color: #6b7280;">

              <strong>Try:</strong>

              <ul style="margin: 4px 0 0 16px; padding: 0;">

                ${alts.map(alt => `<li>${alt}</li>`).join('')}

              </ul>

            </div>

          ` : ''}

        </div>

      `;

    });



    structuralAdviceHtml += `</div>`;

  }



  // Find the container inside fixSelection where options should go

  const fixSelection = document.getElementById('fixSelection');

  if (fixSelection) {

    fixSelection.style.display = 'block'; // Make sure it's visible



    // Hide instruction box for Pro users

    const isPro = appState.isProUser || false;

    const instructionBox = document.getElementById('fixSelectionInstructionBox');

    if (instructionBox) {

      if (isPro) {

        instructionBox.style.display = 'none';

      } else {

        instructionBox.style.display = 'block';

      }

    }



    const optionsContainer = fixSelection.querySelector('div:last-child');

    const combinedHtml = fixOptionsHtml + structuralAdviceHtml;

    if (optionsContainer) {

      optionsContainer.innerHTML = combinedHtml;

    } else {

      fixSelection.innerHTML += combinedHtml;

    }



    // Wait a tick for DOM to update, then limit initially visible fix cards to top 5

    setTimeout(() => {

      // Remove any existing toggle button first

      const existingToggle = document.getElementById('showMoreFixesContainer');

      if (existingToggle) {

        existingToggle.remove();

      }



      // Find cards in the correct container (where they were actually inserted)

      const containerToSearch = optionsContainer || fixSelection;

      const allFixCards = Array.from(containerToSearch.querySelectorAll('.fix-option'));



      console.log('ðŸ” Found', allFixCards.length, 'fix cards');



      if (allFixCards.length > 5) {

        // Hide cards beyond the first 5

        allFixCards.forEach((card, idx) => {

          card.style.display = idx < 5 ? 'block' : 'none';

        });



        // Create toggle button container

        const showMoreContainer = document.createElement('div');

        showMoreContainer.id = 'showMoreFixesContainer';

        showMoreContainer.style.textAlign = 'center';

        showMoreContainer.style.marginTop = '16px';

        showMoreContainer.style.marginBottom = '16px';

        showMoreContainer.style.padding = '8px 0';



        const btn = document.createElement('button');

        btn.id = 'showAllFixesButton';

        btn.textContent = `Show all remaining (${allFixCards.length - 5})`;

        btn.style.background = 'white';

        btn.style.border = '1px solid #d1d5db';

        btn.style.color = '#374151';

        btn.style.padding = '8px 16px';

        btn.style.borderRadius = '999px';

        btn.style.fontSize = '13px';

        btn.style.fontWeight = '500';

        btn.style.cursor = 'pointer';

        btn.style.transition = 'all 0.2s';

        btn.style.display = 'inline-block';



        btn.addEventListener('mouseenter', () => {

          btn.style.borderColor = '#10b981';

          btn.style.color = '#10b981';

        });

        btn.addEventListener('mouseleave', () => {

          btn.style.borderColor = '#d1d5db';

          btn.style.color = '#374151';

        });



        btn.addEventListener('click', () => {

          allFixCards.forEach(card => {

            card.style.display = 'block';

          });

          showMoreContainer.style.display = 'none';

        });



        showMoreContainer.appendChild(btn);



        // Insert toggle button right after the 5th card (last visible card)

        if (allFixCards[4]) {

          // Insert after the 5th card

          allFixCards[4].insertAdjacentElement('afterend', showMoreContainer);

          console.log('âœ… Toggle button inserted after 5th card');

        } else if (allFixCards.length > 0) {

          // Fallback: insert after last card if we have cards but no 5th one

          allFixCards[allFixCards.length - 1].insertAdjacentElement('afterend', showMoreContainer);

          console.log('âœ… Toggle button inserted after last card');

        } else {

          // Last resort: append to container

          containerToSearch.appendChild(showMoreContainer);

          console.log('âœ… Toggle button appended to container');

        }

      } else {

        console.log('â„¹ï¸ Only', allFixCards.length, 'cards - no toggle needed');

      }

    }, 50);

  }



  const flagExplanationsSection = document.getElementById('flagExplanationsSection');

  if (flagExplanationsSection) {

    flagExplanationsSection.style.display = 'block';

  }



  // CRITICAL: Initialize the selected words in QuickFix mode

  setTimeout(() => {

    document.querySelectorAll('.alt-word-btn.selected-word').forEach(btn => {

      const flagIndex = btn.getAttribute('data-flag-index');

      const selectedWord = btn.getAttribute('data-word');



      // Update the flag's suggestedFix

      if (appState.quickfixFlags && appState.quickfixFlags[flagIndex]) {

        console.log('Initializing flag', flagIndex, ':', appState.quickfixFlags[flagIndex].phrase, 'â†’', selectedWord);

        appState.quickfixFlags[flagIndex].suggestedFix = selectedWord;

      }

    });



    // Initialize score preview after DOM is ready - this will show original score if nothing selected

    setTimeout(() => {

      updateScorePreview();



      // CRITICAL: Add scroll listener to the fixSelection container so banner moves with inner scrollbar

      // This ONLY updates position - does NOT recalculate score or container position

      const fixSelectionContainer = document.getElementById('fixSelection');

      if (fixSelectionContainer) {

        // Remove any existing listener first

        fixSelectionContainer.removeEventListener('scroll', updateBannerPositionOnly);

        // Add scroll listener - this ONLY updates position based on scroll

        // Banner position is anchored to scrollbar and ONLY moves when scrollbar moves

        fixSelectionContainer.addEventListener('scroll', updateBannerPositionOnly, { passive: true });

      }



      // Listen to window scroll/resize to update banner position when container moves

      // Use throttled version to avoid too many updates

      let windowScrollTimeout;

      const handleWindowScroll = () => {

        clearTimeout(windowScrollTimeout);

        windowScrollTimeout = setTimeout(() => {

          // Force recalculate container position on window scroll (container might have moved)

          const previewBox = document.getElementById('scorePreviewBox');

          if (previewBox && previewBox.style.display !== 'none') {

            const banner = document.getElementById('scorePreviewBanner');

            if (banner) {

              const currentColor = banner.style.background || '#2ecc71';

              positionBannerToTarget(previewBox, null, currentColor, true);

            }

          }

        }, 10);

      };



      const handleResize = () => {

        // Force recalculate on resize

        const previewBox = document.getElementById('scorePreviewBox');

        if (previewBox && previewBox.style.display !== 'none') {

          const banner = document.getElementById('scorePreviewBanner');

          if (banner) {

            const currentColor = banner.style.background || '#2ecc71';

            positionBannerToTarget(previewBox, null, currentColor, true);

          }

        }

      };



      // Remove old listeners if they exist

      window.removeEventListener('scroll', handleWindowScroll, true);

      window.removeEventListener('resize', handleResize);



      // Add new listeners

      window.addEventListener('scroll', handleWindowScroll, true);

      window.addEventListener('resize', handleResize);

    }, 400);

  }, 100);



  // FIX 1: Reset all checkboxes to unchecked and initialize selected count to 0

  document.querySelectorAll('.fix-option input[type="checkbox"]').forEach(checkbox => {

    checkbox.checked = false;

  });

  // Also uncheck "Use Best Words" checkbox

  const selectAllCheckboxReset = document.getElementById('selectAllFixes');

  if (selectAllCheckboxReset) {

    selectAllCheckboxReset.checked = false;

  }

  // Now update count (should be 0)

  updateSelectedCount();



  // Add event listeners to checkboxes

  document.querySelectorAll('.fix-option input[type="checkbox"]').forEach(checkbox => {

    checkbox.addEventListener('change', function() {

      // Mark as user action so checkbox state can be updated

      isUserChangingSelection = true;



      const fixOption = this.closest('.fix-option');

      const flagIndex = fixOption.getAttribute('data-index');



      // Track this as the last clicked fix option for banner pointer

      appState.lastClickedFixOption = flagIndex;



      // Update preview position immediately

      setTimeout(() => updateScorePreview(), 50);



      if (this.checked) {

        fixOption.classList.add('selected');

        fixOption.style.background = '#f0fdf4';

        fixOption.style.borderColor = '#2ecc71';



        // Auto-select the first/best word button if none selected

        const hasSelectedWord = document.querySelector(`.alt-word-btn[data-flag-index="${flagIndex}"].selected-word`);

        if (!hasSelectedWord) {

          // Auto-select the first word button (usually the suggested fix)

          const firstWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

          if (firstWordBtn) {

            firstWordBtn.click();

          }

        }

      } else {

        fixOption.classList.remove('selected');

        fixOption.style.background = 'white';

        fixOption.style.borderColor = '#e5e7eb';



        // BONUS: If checkbox is unchecked, deselect all word buttons for this flag

        const allBtnsForFlag = document.querySelectorAll(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

        allBtnsForFlag.forEach(b => {

          b.style.background = 'white';

          b.style.borderColor = '#d1d5db';

          b.style.color = '#374151';

          b.style.fontWeight = '400';

          b.classList.remove('selected-word');

        });

      }

      // Update selected count when selection changes

      updateSelectedCount();



      // Check if "Use Best Words" should be unchecked (when checkbox is unchecked, or when selection changes)

      checkIfAllBestWords();



      // Update score preview

      updateScorePreview();

    });

  });



  // Add event listener for Select All checkbox

  const selectAllCheckbox = document.getElementById('selectAllFixes');

  if (selectAllCheckbox) {

    selectAllCheckbox.addEventListener('change', toggleSelectAll);

  }



  // Add event listeners for alternative word buttons

  document.querySelectorAll('.alt-word-btn').forEach(btn => {

    btn.addEventListener('click', function() {

      // Mark as user action so checkbox state can be updated

      isUserChangingSelection = true;



      const flagIndex = this.getAttribute('data-flag-index');

      const selectedWord = this.getAttribute('data-word');



      // Auto-check the checkbox for this fix option when a word is selected

      const checkbox = document.getElementById(`fix-${flagIndex}`);

      if (checkbox && !checkbox.checked) {

        checkbox.checked = true;

        checkbox.dispatchEvent(new Event('change', { bubbles: true }));

      }



      // Track this as the last clicked fix option for banner pointer

      appState.lastClickedFixOption = flagIndex;



      // Update preview position immediately

      setTimeout(() => updateScorePreview(), 50);



      // Update the flag's suggestedFix

      if (appState.quickfixFlags && appState.quickfixFlags[flagIndex]) {

        console.log('User selected word for flag', flagIndex, ':', appState.quickfixFlags[flagIndex].phrase, 'â†’', selectedWord);

        appState.quickfixFlags[flagIndex].suggestedFix = selectedWord;

      }



      // FIX: Properly deselect all buttons for this flag and select clicked one

      const allBtnsForFlag = document.querySelectorAll(`.alt-word-btn[data-flag-index="${flagIndex}"]`);

      allBtnsForFlag.forEach(b => {

        // Reset to default state: custom words = dark blue, search results = green, others = gray

        const isCustom = b.classList.contains('custom-word-btn');

        const isSearchResult = b.classList.contains('search-result-btn');

        b.style.background = 'white';

        b.style.borderColor = isCustom ? '#1e40af' : (isSearchResult ? '#2ecc71' : '#d1d5db');

        b.style.color = isCustom ? '#1e40af' : (isSearchResult ? '#2ecc71' : '#374151');

        b.style.fontWeight = isCustom ? '500' : '400';

        b.classList.remove('selected-word');

      });



      // Highlight selected button properly

      this.style.background = '#10b981';

      this.style.borderColor = '#10b981';

      this.style.color = '#ffffff';

      this.style.fontWeight = '600';

      this.classList.add('selected-word');



      // Update the count to reflect word selection

      updateSelectedCount();



      // Check if "Use Best Words" should be unchecked (if user selected non-best word)

      checkIfAllBestWords();



      // Update score preview

      updateScorePreview();



      console.log('Selected word:', selectedWord, 'for flag:', flagIndex);

    });

  });



  // Add event listeners for CTA buttons

  const applySelectedBtn = document.getElementById('applySelectedFixes');

  if (applySelectedBtn) {

    applySelectedBtn.addEventListener('click', applySelectedFixes);

    console.log('âœ… Apply QuickFixes button listener added');

  }



  const completeRewriteBtn = document.getElementById('completeRewrite');

  if (completeRewriteBtn) {

    completeRewriteBtn.addEventListener('click', completeRewrite);

    console.log('âœ… See All 15 Flags Fixed button listener added');

  }



  // FORCE update button text to "Go Pro" on QuickFix Results page

  setTimeout(() => {

    const proUpsellButton = document.querySelector('#quickfixProUpsellBox button');

    if (proUpsellButton) {

      proUpsellButton.innerHTML = 'ðŸ’Ž Go Pro - $9.99/mo';

      proUpsellButton.textContent = 'ðŸ’Ž Go Pro - $9.99/mo';

    }

  }, 100);



  // CRITICAL: For Pro users on Step 2, ALWAYS show BOTH CTAs (green Pro All + blue Back to Pro Dashboard) for ALL cards (Clean, Kinda Sus, Hella Sus)

  const isProUser = appState.isProUser || false;

  if (isProUser) {

    setTimeout(() => {

      updateStepLabels(true);

      const step2 = document.getElementById('quickfixStep2');

      const isStep2Active = step2 && step2.classList.contains('active');

      if (isStep2Active) {

        const step2BackToDashboard = document.getElementById('quickfixStep2BackToDashboard');

        const step2BackToProDashboard = document.getElementById('step2BackToProDashboard');

        const applyAllBtn = document.getElementById('applyAllFixes');

        const applySelectedButton = document.getElementById('applySelectedFixes');

        const buttonGroup = document.getElementById('quickfixButtonGroup');

        if (step2BackToDashboard) { step2BackToDashboard.style.display = 'none'; step2BackToDashboard.style.setProperty('display', 'none', 'important'); }

        if (step2BackToProDashboard) { step2BackToProDashboard.style.display = 'block'; step2BackToProDashboard.style.setProperty('display', 'block', 'important'); }

        const proStep2BackBtn = document.getElementById('proStep2BackToDashboard');

        const currentScore = appState.quickfixOriginalScore || appState.proOriginalScore || score || 0;

        if (proStep2BackBtn) {

          if (currentScore < 30) { proStep2BackBtn.style.display = 'none'; proStep2BackBtn.style.setProperty('display', 'none', 'important'); }

          else { proStep2BackBtn.style.display = 'block'; proStep2BackBtn.style.setProperty('display', 'block', 'important'); }

        }

        if (buttonGroup) { buttonGroup.style.display = 'flex'; buttonGroup.style.setProperty('display', 'flex', 'important'); }

        if (applyAllBtn) { applyAllBtn.style.display = 'flex'; applyAllBtn.style.setProperty('display', 'flex', 'important'); applyAllBtn.style.visibility = 'visible'; applyAllBtn.style.setProperty('visibility', 'visible', 'important'); }

        const isHellaSusOrKindaSus = currentScore >= 30;

        if (applySelectedButton && isHellaSusOrKindaSus) {

          applySelectedButton.style.display = 'inline-block';

          applySelectedButton.style.setProperty('display', 'inline-block', 'important');

          applySelectedButton.style.setProperty('background', '#00a8e8', 'important');

          applySelectedButton.style.setProperty('color', 'white', 'important');

          const selectedCountEl = applySelectedButton.querySelector('#selectedCount');

          const currentCount = selectedCountEl ? selectedCountEl.textContent : '0';

          applySelectedButton.innerHTML = `Pro (Selected Words Only (<span id="selectedCount">${currentCount}</span>))`;

        }

        console.log('âœ… Pro Step 2: both CTAs (Pro All + Back to Pro Dashboard) forced visible for all cards');

      }

    }, 150);

  }

}



// Scroll to a flagged word in the original essay by index

function scrollToFlagInOriginal(flagIndex) {

  console.log('ðŸ” scrollToFlagInOriginal called with index:', flagIndex);



  // Switch to Original view if not already there

  showVersion('original');



  // Wait for view to switch, then scroll

  setTimeout(() => {

    const originalEssayEl = document.getElementById('originalEssay');

    if (!originalEssayEl) {

      console.error('âŒ originalEssay element not found');

      return;

    }



    // Find the badge with the matching data-flag-index attribute

    const badge = originalEssayEl.querySelector(`sup[data-flag-index="${flagIndex}"]`);

    if (badge) {

      // Scroll the badge into view

      badge.scrollIntoView({ behavior: 'smooth', block: 'center' });



      // Highlight the badge briefly

      const originalBg = badge.style.background;

      const originalTransform = badge.style.transform;

      badge.style.background = '#3b82f6'; // Blue highlight

      badge.style.transform = 'scale(1.4)';

      badge.style.zIndex = '1000';



      setTimeout(() => {

        badge.style.background = originalBg;

        badge.style.transform = originalTransform || 'scale(1)';

        badge.style.zIndex = '';

      }, 1500);



      console.log('âœ… Scrolled to flag', flagIndex);

    } else {

      console.warn(`âš ï¸ Badge with data-flag-index="${flagIndex}" not found`);

      // Fallback: try finding by position in all badges

      const badges = originalEssayEl.querySelectorAll('sup');

      if (badges && badges[flagIndex]) {

        badges[flagIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });

      }

    }

  }, 400);

}



// Scroll to flag item in the summary dropdown (Step 3)

function scrollToFlagInSummaryDropdown(flagIndex) {

  console.log('ðŸ” scrollToFlagInSummaryDropdown called with index:', flagIndex);



  // Find the dropdown details element for "AI TRIGGER WORDS FIXED"

  // The dropdown is inside textRiskCard

  const textRiskCard = document.getElementById('textRiskCard');

  if (!textRiskCard) {

    console.error('âŒ textRiskCard not found');

    return;

  }



  const fixedDropdown = textRiskCard.querySelector('details.summary-dropdown');

  if (!fixedDropdown) {

    console.error('âŒ Fixed dropdown not found');

    return;

  }



  // Open the dropdown if it's closed

  if (!fixedDropdown.open) {

    fixedDropdown.open = true;

    console.log('âœ… Opened fixed dropdown');

  }



  // Wait a bit for dropdown to open, then scroll to the item

  setTimeout(() => {

    const flagItem = document.getElementById(`flag-item-${flagIndex}`);

    if (flagItem) {

      // Scroll the dropdown container into view first

      const dropdownContainer = fixedDropdown.querySelector('div');

      if (dropdownContainer) {

        dropdownContainer.scrollTop = 0; // Reset scroll

      }



      flagItem.scrollIntoView({ behavior: 'smooth', block: 'center' });



      // Scroll the parent dropdown container so the item is visible

      if (dropdownContainer) {

        const itemOffset = flagItem.offsetTop;

        dropdownContainer.scrollTop = itemOffset - 50; // Offset for better visibility

      }



      // Highlight the item briefly

      const originalBg = flagItem.style.backgroundColor;

      flagItem.style.backgroundColor = '#fef3c7';

      flagItem.style.transition = 'all 0.3s';

      setTimeout(() => {

        flagItem.style.backgroundColor = originalBg || '';

      }, 1500);



      console.log('âœ… Scrolled to flag item', flagIndex);

    } else {

      console.warn(`âš ï¸ Flag item #${flagIndex} not found in dropdown`);

    }

  }, 150);

}



// Function to scroll to specific fix option

function scrollToFixOption(index) {

  // First, make sure the fix selection section is open

  const fixSelection = document.getElementById('fixSelection');

  if (fixSelection && (fixSelection.style.display === 'none' || getComputedStyle(fixSelection).display === 'none')) {

    toggleFixSelection();

  }



  const fixOption = document.querySelector(`.fix-option[data-index="${index}"]`);

  if (fixOption) {

    fixOption.scrollIntoView({ 

      behavior: 'smooth', 

      block: 'center' 

    });



    // Add a green highlight effect

    fixOption.style.backgroundColor = '#f0fdf4';

    fixOption.style.borderColor = '#00a8e8';

    fixOption.style.transition = 'all 0.3s ease';



    // Check the checkbox if not already checked

    const checkbox = fixOption.querySelector('input[type="checkbox"]');

    if (checkbox && !checkbox.checked) {

      checkbox.checked = true;

      checkbox.dispatchEvent(new Event('change'));

    }



    // Keep the green highlight (don't remove it after timeout)

  }

}



// Global function to toggle the fix selection section

function toggleFixSelection() {

  const fixSelection = document.getElementById('fixSelection');

  const toggleArrow = document.getElementById('toggleArrow');



  if (!fixSelection || !toggleArrow) return;



  if (fixSelection.style.display === 'none' || getComputedStyle(fixSelection).display === 'none') {

    fixSelection.style.display = 'block';

    toggleArrow.style.transform = 'rotate(180deg)';

  } else {

    fixSelection.style.display = 'none';

    toggleArrow.style.transform = 'rotate(0deg)';

  }



  // Clear position cache when container is toggled (layout changed)

  bannerPositionCache.containerRight = null;

  bannerPositionCache.containerLeft = null;

  bannerPositionCache.containerTop = null;

  bannerPositionCache.bannerX = null;

  bannerPositionCache.lastUpdate = 0;



  // Update banner position when container is toggled

  setTimeout(() => {

    updateScorePreview();

  }, 100);

}



// FIXED: Apply QuickFixes - PROPERLY REDIRECTS TO QUICKFIX RESULTS

function applySelectedFixes() {

  // Check if required data exists

  if (!appState.quickfixOriginalText || !appState.quickfixFlags || appState.quickfixFlags.length === 0) {

    console.error('Missing required data for applySelectedFixes:', {

      originalText: appState.quickfixOriginalText,

      flags: appState.quickfixFlags

    });

    showSuccessMessage('Error: Missing essay data. Please go back and try again.');

    return;

  }



  const selectedFlags = [];

  console.log('=== DEBUG APPLY FIXES ===');

  console.log('appState.quickfixFlags.length:', appState.quickfixFlags.length);

  document.querySelectorAll('.fix-option input[type="checkbox"]:checked').forEach(checkbox => {

    const index = parseInt(checkbox.closest('.fix-option').dataset.index);

    console.log('Found checked checkbox with index:', index);

    if (index >= 0 && index < appState.quickfixFlags.length && appState.quickfixFlags[index]) {

      const flag = { ...appState.quickfixFlags[index] };

      flag._originalIndex = index; // Store original index for lookup



      // Use button selection if available

      const selectedWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${index}"].selected-word`);

      if (selectedWordBtn) {

        flag.suggestedFix = selectedWordBtn.getAttribute('data-word');

      }



      console.log('Adding flag:', flag.phrase, 'with suggested fix:', flag.suggestedFix);

      selectedFlags.push(flag);

    } else {

      console.warn('Skipping invalid checkbox index:', index, 'Available flags:', appState.quickfixFlags.length);

    }

  });

  console.log('Total selectedFlags:', selectedFlags.length);



  if (selectedFlags.length === 0) {

    showStyledAlert('Select at least one fix to apply!');

    return;

  }



  const button = document.getElementById('applySelectedFixes');

  const originalButtonText = button.textContent;

  button.textContent = 'Applying fixes... âœ¨';

  button.disabled = true;



  // Track when modal is shown (before fetch starts)

  window._quickFixModalStartTime = Date.now();



  // Show scanning/processing modal

  console.log('ðŸŽ¬ About to show QuickFix processing modal...');

  showQuickFixProcessingModal();

  console.log('âœ… QuickFix processing modal should be visible now');



  // SAFETY NET: If fetch takes too long, show step 3 with local fixes as fallback (reduced to 20s since we optimized server)

  const safetyTimeout = setTimeout(() => {

    console.warn('âš ï¸ Safety timeout triggered - showing step 3 with local fixes as fallback');

    hideQuickFixProcessingModal();



      // Apply fixes locally and show step 3

      try {

        let fallbackFixedText = appState.quickfixOriginalText || '';

        selectedFlags.forEach(flag => {

          if (flag.phrase && flag.suggestedFix) {

            const regex = new RegExp(flag.phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

            fallbackFixedText = fallbackFixedText.replace(regex, (match) => {

              const wasCapitalized = match[0] === match[0].toUpperCase();

              let replacement = flag.suggestedFix;

              if (wasCapitalized && replacement.length > 0) {

                replacement = replacement.charAt(0).toUpperCase() + replacement.slice(1);

              }

              return replacement;

            });

          }

        });



      const originalScore = appState.quickfixOriginalScore || 75;

      const estimatedNewScore = Math.max(15, originalScore - (selectedFlags.length * 5));

      const improvement = originalScore - estimatedNewScore;



      appState.quickfixFixedText = fallbackFixedText;

      appState.quickfixNewScore = estimatedNewScore;



      // Force show step 3

      document.querySelectorAll('.quickfix-step').forEach(step => {

        step.classList.remove('active');

        step.style.setProperty('display', 'none', 'important');

      });



      const step3 = document.getElementById('quickfixStep3');

      if (step3) {

        step3LockUntil = Date.now() + 10000;

        step3.classList.add('active');

        step3.style.setProperty('display', 'block', 'important');

        step3.style.setProperty('opacity', '1', 'important');

        step3.style.setProperty('visibility', 'visible', 'important');



        displayQuickFixResults(

          appState.quickfixOriginalText, 

          fallbackFixedText, 

          selectedFlags, 

          estimatedNewScore, 

          improvement

        );



        setTimeout(() => {

          window.scrollTo({ top: 0, behavior: 'smooth' });

        }, 100);



        showSuccessMessage('âš ï¸ Server took too long. Showing local fixes (score may not be accurate).');

      }

    } catch (fallbackErr) {

      console.error('âŒ Safety timeout fallback failed:', fallbackErr);

      showSuccessMessage('âŒ Request took too long. Please try again.');

    }



    if (button) {

      button.textContent = originalButtonText;

      button.disabled = false;

    }

      }, 20000); // 20 second safety timeout (server now completes in 10-20s)



  // Apply fixes using new QuickFix endpoint (multi-pass system)

  console.log('ðŸš€ STARTING applySelectedFixes async function');

  (async () => {

    try {

      console.log('ðŸ“ Step 1: Checking QuickFix Mode settings...');

      // Check if "QuickFix Mode: Use Best Words" is enabled

      const selectAllCheckbox = document.getElementById('selectAllFixes');

      const isQuickFixMode = selectAllCheckbox && selectAllCheckbox.checked;

      console.log('   isQuickFixMode:', isQuickFixMode);



      // Check if all selected fixes are using their best words (not custom words)

      let allUsingBestWords = true;

      selectedFlags.forEach(flag => {

        const flagIndex = flag._originalIndex;

        if (flagIndex === undefined) {

          allUsingBestWords = false;

          return;

        }



        const suggestionsContainer = document.querySelector(`.suggestions-container[data-flag-index="${flagIndex}"]`);

        const originalBestWord = suggestionsContainer ? suggestionsContainer.getAttribute('data-original-best-word') : null;

        const selectedWordBtn = document.querySelector(`.alt-word-btn[data-flag-index="${flagIndex}"].selected-word`);



        if (selectedWordBtn) {

          // Check if selected word matches the best word

          const selectedWord = selectedWordBtn.getAttribute('data-word');

          if (selectedWord !== originalBestWord) {

            allUsingBestWords = false;

          }

        }

      });

      console.log('   allUsingBestWords:', allUsingBestWords);



      // Only force if QuickFix Mode is checked AND all fixes use best words

      const shouldForce = isQuickFixMode && allUsingBestWords;

      console.log('   shouldForce:', shouldForce);



      // Determine backend URL (needed in both try and catch blocks)

      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

      const BACKEND_URL = window.BACKEND_URL || 'http://localhost:5000';

      console.log('   BACKEND_URL:', BACKEND_URL);



      // Prepare flags for QuickFix endpoint

      console.log('ðŸ“ Step 2: Preparing flags for API...');

      const flagsForAPI = selectedFlags.map(flag => ({

        phrase: flag.phrase,

        suggestedFix: flag.suggestedFix || (flag.alternatives && flag.alternatives[0]) || 'rephrase',

        alternatives: flag.alternatives || []

      }));

      console.log('   Prepared', flagsForAPI.length, 'flags');



      console.log('ðŸ”§ Sending to QuickFix endpoint:', {

        essayLength: appState.quickfixOriginalText?.length,

        flagsCount: flagsForAPI.length,

        originalScore: appState.quickfixOriginalScore,

        isQuickFixMode: isQuickFixMode,

        allUsingBestWords: allUsingBestWords,

        shouldForce: shouldForce,

        flags: flagsForAPI

      });



      // Call QuickFix endpoint (multi-pass system guaranteed < 30%)

      console.log('ðŸŒ Step 3: Calling QuickFix at:', `${BACKEND_URL}/quickfix`);



      // Use AbortController for proper timeout handling

      // QuickFix makes 2-5 API calls (optimized: reuses analysis when possible)

      // No timeout - let the request complete no matter how long it takes

      console.log('â±ï¸ Step 4: Setting up fetch with NO timeout (will wait for completion)...');



      let quickFixResponse;

      try {

        console.log('ðŸ“¤ Step 5: Sending fetch request...');

        const requestBody = {

          essay: appState.quickfixOriginalText,

          flags: flagsForAPI,

          originalScore: appState.quickfixOriginalScore,

          shouldForce: shouldForce // Tell backend whether to force score < 30%

        };

        console.log('   Request body size:', JSON.stringify(requestBody).length, 'bytes');



        quickFixResponse = await fetch(`${BACKEND_URL}/quickfix`, {

          method: 'POST',

          headers: {

            'Content-Type': 'application/json'

          },

          body: JSON.stringify(requestBody)

          // No signal/abort - let it complete naturally

        });

        console.log('âœ… Fetch request completed, status:', quickFixResponse.status);

      } catch (fetchError) {

        console.error('âŒ QuickFix fetch failed:', fetchError);

        console.error('   Error name:', fetchError.name);

        console.error('   Error message:', fetchError.message);

        console.error('   Error stack:', fetchError.stack);

        // Hide modal (will respect minimum display time)

        hideQuickFixProcessingModal();



        // No timeout errors - just show connection/server errors

          throw new Error(fetchError.message || 'Failed to connect to server. Please check your connection and try again.');

      }



      console.log('ðŸ“¡ Step 6: QuickFix response received, status:', quickFixResponse.status, quickFixResponse.statusText);



      if (!quickFixResponse.ok) {

        let errorData;

        try {

          errorData = await quickFixResponse.json();

        } catch (e) {

          errorData = { error: 'Unknown error', message: quickFixResponse.statusText };

        }

        console.error('âŒ QuickFix endpoint error:', errorData);

        // Hide modal (will respect minimum display time)

        hideQuickFixProcessingModal();

        throw new Error(errorData.message || errorData.error || `Server error: ${quickFixResponse.status}`);

      }



      console.log('ðŸ“ Step 7: Parsing response JSON...');

      let quickFixResult;

      try {

        quickFixResult = await quickFixResponse.json();

        console.log('âœ… Response parsed successfully');

        console.log('   Response keys:', Object.keys(quickFixResult));

      } catch (parseError) {

        console.error('âŒ Failed to parse QuickFix response:', parseError);

        console.error('   Parse error stack:', parseError.stack);

        // Hide modal (will respect minimum display time)

        hideQuickFixProcessingModal();

        throw new Error('Invalid response from server. Please try again.');

      }



      console.log('ðŸ“ Step 8: Validating response data...');

      if (!quickFixResult.cleanedEssay || quickFixResult.newScore === undefined) {

        console.error('âŒ Invalid QuickFix response:', quickFixResult);

        console.error('   Has cleanedEssay:', !!quickFixResult.cleanedEssay);

        console.error('   Has newScore:', quickFixResult.newScore !== undefined);

        // Hide modal (will respect minimum display time)

        hideQuickFixProcessingModal();

        throw new Error('Invalid response from server. Missing required data.');

      }

      console.log('âœ… Response validation passed');



      const fixedText = quickFixResult.cleanedEssay;

      const estimatedNewScore = quickFixResult.newScore; // Guaranteed < 30%

      const improvement = quickFixResult.improvement !== undefined 

        ? quickFixResult.improvement 

        : (appState.quickfixOriginalScore || 0) - estimatedNewScore;



      console.log(`âœ… QuickFix complete: ${appState.quickfixOriginalScore}% â†’ ${estimatedNewScore}% (${quickFixResult.passes} passes, improvement: ${improvement})`);



      appState.quickfixFixedText = fixedText;

      appState.quickfixNewScore = estimatedNewScore;

      appState.quickfixReplacements = quickFixResult.replacements || [];

      // STAGE 3: Store separate scores from backend (these are the NEW scores after fix)

      appState.quickfixTextPhraseScore = quickFixResult.textPhraseScore !== undefined ? quickFixResult.textPhraseScore : estimatedNewScore;

      appState.quickfixStructuralScore = quickFixResult.structuralScore !== undefined ? quickFixResult.structuralScore : estimatedNewScore;

      appState.quickfixOverallScore = quickFixResult.overallScore !== undefined ? quickFixResult.overallScore : estimatedNewScore;

      // Store categorized flags from backend

      appState.quickfixTextPhraseFlags = quickFixResult.textPhraseFlags || [];

      appState.quickfixStructuralFlags = quickFixResult.structuralFlags || [];

      // Store QuickFix response for Step 3

      appState.apiResponse = {

        overview: {

          score: appState.quickfixOriginalScore,

          quickStats: {

            expectedNewScore: `${estimatedNewScore}%`,

            estimatedFixTime: '2 minutes',

            improvement: `${improvement}% reduction`

          }

        },

        categorized: {

          textPhraseFlags: quickFixResult.textPhraseFlags || appState.quickfixTextPhraseFlags || [],

          structuralFlags: quickFixResult.structuralFlags || appState.quickfixStructuralFlags || []

        }

      };



      console.log('ðŸ’¾ Stored NEW scores from QuickFix:', {

        overall: appState.quickfixOverallScore,

        textPhrase: appState.quickfixTextPhraseScore,

        structural: appState.quickfixStructuralScore,

        originalOverall: appState.quickfixOriginalScore

      });



      // Clear safety timeout since we succeeded

      clearTimeout(safetyTimeout);



      // Ensure modal stays visible for at least 5 seconds total

      const modalStartTime = window._quickFixModalStartTime || Date.now();

      const minDisplayTime = 5000; // 5 seconds minimum

      const elapsed = Date.now() - modalStartTime;

      const remainingTime = Math.max(0, minDisplayTime - elapsed);



      console.log('ðŸ“ Step 9: Modal has been visible for', elapsed, 'ms. Waiting', remainingTime, 'ms more before hiding...');



      // Wait remaining time to ensure minimum display time

      setTimeout(() => {

        console.log('ðŸ“ Step 9.5: Hiding processing modal...');

      hideQuickFixProcessingModal();

      console.log('âœ… Modal hidden');



        // Show Step 3 after modal is hidden

        showStep3WithResults();

      }, remainingTime);



      // Helper function to show Step 3

      function showStep3WithResults() {



      // âœ… CRITICAL FIX: FORCE HIDE STEP 2 AND SHOW STEP 3

      console.log('ðŸ”„ Step 10: Transitioning to Step 3 with results:', {

        originalText: appState.quickfixOriginalText?.substring(0, 50),

        fixedText: fixedText?.substring(0, 50),

        newScore: estimatedNewScore,

        improvement: improvement

      });



      // FORCE HIDE ALL STEPS FIRST

      document.querySelectorAll('.quickfix-step').forEach(step => {

        step.classList.remove('active');

        step.style.setProperty('display', 'none', 'important');

        step.style.setProperty('opacity', '0', 'important');

        step.style.setProperty('visibility', 'hidden', 'important');

      });



      // FORCE SHOW STEP 3

      const step3 = document.getElementById('quickfixStep3');

      if (!step3) {

        console.error('âŒ Step 3 element not found!');

        showSuccessMessage('Error: Results page not found. Please refresh.');

        return;

      }



      // Set lock BEFORE showing step 3

      step3LockUntil = Date.now() + 5000; // Lock for 5 seconds to prevent any reverts



      step3.classList.add('active');

      step3.style.setProperty('display', 'block', 'important');

      step3.style.setProperty('opacity', '1', 'important');

      step3.style.setProperty('visibility', 'visible', 'important');

      console.log('âœ… Step 3 FORCED to display (locked for 5 seconds)');



      // Display results immediately (no delay needed since we forced the display)

      try {

        console.log('ðŸ“ Step 13: Displaying QuickFix results...');

        console.log('   Original text length:', appState.quickfixOriginalText?.length);

        console.log('   Fixed text length:', fixedText?.length);

        console.log('   Selected flags count:', selectedFlags.length);

        console.log('   New score:', estimatedNewScore);

        console.log('   Improvement:', improvement);



        // Ensure we have the text before displaying

        const originalTextToDisplay = appState.quickfixOriginalText || '';

        const fixedTextToDisplay = fixedText || appState.quickfixFixedText || originalTextToDisplay;



        console.log('ðŸ“ About to display results:', {

          originalLength: originalTextToDisplay.length,

          fixedLength: fixedTextToDisplay.length,

          flagsCount: selectedFlags.length,

          newScore: estimatedNewScore,

          improvement: improvement

        });



        if (!originalTextToDisplay || originalTextToDisplay.trim() === '') {

          console.error('âŒ CRITICAL: originalText is empty! Cannot display results.');

          showSuccessMessage('Error: Original text is missing. Please go back and try again.');

          return;

        }



        if (!fixedTextToDisplay || fixedTextToDisplay.trim() === '') {

          console.error('âŒ CRITICAL: fixedText is empty! Cannot display results.');

          showSuccessMessage('Error: Fixed text is missing. Please try applying fixes again.');

          return;

        }



        displayQuickFixResults(

          originalTextToDisplay, 

          fixedTextToDisplay, 

          selectedFlags, 

          estimatedNewScore, 

          improvement, 

          quickFixResult.replacements,

          quickFixResult.textPhraseScore,

          quickFixResult.structuralScore,

          quickFixResult.overallScore

        );

        console.log('âœ… Results displayed successfully');



        // MANUAL PROGRESS BAR ANIMATION (backup to ensure it always runs)

        setTimeout(() => {

          console.log('ðŸŽ¯ Manually animating QuickFix Step 3 progress bar...');



          // Get score from multiple sources

          const scoreToUse = appState.apiResponse?.textRisk || 

                            appState.apiResponse?.afterScore || 

                            appState.quickfixOverallScore || 

                            appState.quickfixNewScore || 

                            0;



          console.log('ðŸŽ¯ Score to animate:', scoreToUse, {

            apiTextRisk: appState.apiResponse?.textRisk,

            apiAfterScore: appState.apiResponse?.afterScore,

            quickfixOverallScore: appState.quickfixOverallScore,

            quickfixNewScore: appState.quickfixNewScore

          });



          // Try all possible element IDs

          const fill1 = document.getElementById('quickfixStep3ProgressFill');

          const fill2 = document.getElementById('quickfixProgressFill');

          const fill3 = document.getElementById('quickfixMEMProgressFill');



          const fillElement = fill1 || fill2 || fill3;



          if (fillElement) {

            const clampedScore = Math.max(0, Math.min(100, Math.round(scoreToUse)));



            // Reset to 0% first

            fillElement.style.width = '0%';

            fillElement.style.transition = 'width 1.5s ease';



            // Set background color based on score - CRITICAL: Clean No Sus should be green only

            if (clampedScore <= 29) {

              fillElement.style.background = '#10b981'; // Green only for Clean No Sus

            } else if (clampedScore <= 69) {

              fillElement.style.background = `linear-gradient(to right, #10b981 0%, #10b981 29%, #fbbf24 30%, #fbbf24 ${clampedScore}%)`;

            } else {

              fillElement.style.background = `linear-gradient(to right, #10b981 0%, #10b981 29%, #fbbf24 30%, #fbbf24 69%, #ef4444 70%, #ef4444 ${clampedScore}%)`;

            }



            // Force repaint

            void fillElement.offsetHeight;



            // Animate after a short delay

            setTimeout(() => {

              fillElement.style.width = clampedScore + '%';

              console.log('âœ… Manually animated progress bar to', clampedScore + '%', 'on element:', fillElement.id);

            }, 50);



            // Also update indicator if it exists

            const indicator = document.getElementById('quickfixStep3ProgressIndicator') || 

                             document.getElementById('quickfixProgressIndicator');

            if (indicator) {

              setTimeout(() => {

                const bar = fillElement.closest('.progress-bar');

                if (bar) {

                  const barWidth = bar.offsetWidth;

                  const indicatorPosition = (barWidth * clampedScore / 100);

                  indicator.style.left = indicatorPosition + 'px';

                  indicator.style.transition = 'left 1.5s ease';

                  if (typeof updateProgressIndicator === 'function') {

                    updateProgressIndicator(clampedScore, indicator.id);

                  }

                }

              }, 100);

            }

          } else {

            console.error('âŒ No progress fill element found! Tried: quickfixStep3ProgressFill, quickfixProgressFill, quickfixMEMProgressFill');

          }

        }, 500);



        // VERIFY STEP 3 IS STILL VISIBLE after display

        setTimeout(() => {

          const step3Check = document.getElementById('quickfixStep3');

          if (step3Check) {

            const isStillVisible = step3Check.classList.contains('active') && 

                                 window.getComputedStyle(step3Check).display !== 'none';

            if (!isStillVisible) {

              console.error('âŒ Step 3 disappeared after display! Forcing it back...');

              step3Check.classList.add('active');

              step3Check.style.setProperty('display', 'block', 'important');

              step3Check.style.setProperty('opacity', '1', 'important');

              step3Check.style.setProperty('visibility', 'visible', 'important');

              step3LockUntil = Date.now() + 10000;

            } else {

              console.log('âœ… Step 3 still visible after display');

            }

          }

        }, 500);



        // Update labels if in Pro mode

        if (appState.isProUser) {

          setTimeout(() => {

            updateStepLabels(true);

          }, 100);

        }



        // Scroll to top of the page to show the results

        setTimeout(() => {

          window.scrollTo({ top: 0, behavior: 'smooth' });

        }, 100);

      } catch (displayError) {

        console.error('âŒ Error displaying results:', displayError);

        console.error('   Error name:', displayError.name);

        console.error('   Error message:', displayError.message);

        console.error('   Display error stack:', displayError.stack);

        // If display fails, at least show step 3 with basic info

        const newScoreEl = document.getElementById('quickfixNewScore');

        if (newScoreEl) {

          newScoreEl.textContent = estimatedNewScore + '%';

        }

        // Ensure step 3 is still visible even on error

        const step3Error = document.getElementById('quickfixStep3');

        if (step3Error) {

          step3Error.classList.add('active');

          step3Error.style.setProperty('display', 'block', 'important');

          step3Error.style.setProperty('opacity', '1', 'important');

          step3Error.style.setProperty('visibility', 'visible', 'important');

        }

        showSuccessMessage('Results ready! Score: ' + estimatedNewScore + '%');

        }

      }



    } catch (error) {

      console.error('âŒ ERROR in applySelectedFixes:', error);

      console.error('   Error name:', error.name);

      console.error('   Error message:', error.message);

      console.error('   Error stack:', error.stack);

      console.error('   Error details:', {

        selectedFlagsCount: selectedFlags.length,

        originalTextLength: appState.quickfixOriginalText?.length,

        backendUrl: `${window.BACKEND_URL || 'http://localhost:5000'}/quickfix`

      });

      // Hide modal on error (will respect minimum display time)

      hideQuickFixProcessingModal();

      // Show user-friendly error message

      const errorMsg = error.message || 'Unknown error occurred';

      showSuccessMessage(`âŒ ${errorMsg}`);

    } finally {

      console.log('ðŸ applySelectedFixes finally block executing');

      // Clear safety timeout

      clearTimeout(safetyTimeout);

      // DON'T hide modal here - let the success path handle it with proper timing

      // The modal will be hidden by the setTimeout in the success path

      // Only reset button state

      if (button) {

        button.textContent = originalButtonText;

        button.disabled = false;

        console.log('âœ… Button state reset');

      } else {

        console.warn('âš ï¸ Button element not found for reset');

      }

    }

  })().catch(err => {

    // Catch any unhandled promise rejections

    console.error('ðŸ’¥ UNHANDLED ERROR in applySelectedFixes:', err);

    console.error('   Error details:', {

      name: err.name,

      message: err.message,

      stack: err.stack

    });



    hideQuickFixProcessingModal();



    // Show user-friendly error message

    if (err.message && err.message.includes('fetch')) {

      showSuccessMessage('âŒ Failed to connect to server. Please make sure the server is running on port 5000.');

    } else if (err.message) {

      showSuccessMessage('âŒ ' + err.message);

    } else {

      showSuccessMessage('âŒ An error occurred. Please check the console for details.');

    }



    // CRITICAL: Try fallback even for unhandled errors

    console.log('ðŸ”„ Unhandled error - attempting fallback to show step 3...');

    try {

      // Apply fixes locally

      let fallbackFixedText = appState.quickfixOriginalText || '';

      selectedFlags.forEach(flag => {

        if (flag.phrase && flag.suggestedFix) {

          const regex = new RegExp(flag.phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

          fallbackFixedText = fallbackFixedText.replace(regex, flag.suggestedFix);

        }

      });



      const originalScore = appState.quickfixOriginalScore || 75;

      const estimatedNewScore = Math.max(15, originalScore - (selectedFlags.length * 5));

      const improvement = originalScore - estimatedNewScore;



      appState.quickfixFixedText = fallbackFixedText;

      appState.quickfixNewScore = estimatedNewScore;



      // Force show step 3

      document.querySelectorAll('.quickfix-step').forEach(step => {

        step.classList.remove('active');

        step.style.setProperty('display', 'none', 'important');

      });



      const step3 = document.getElementById('quickfixStep3');

      if (step3) {

        step3LockUntil = Date.now() + 10000;

        step3.classList.add('active');

        step3.style.setProperty('display', 'block', 'important');

        step3.style.setProperty('opacity', '1', 'important');

        step3.style.setProperty('visibility', 'visible', 'important');



        displayQuickFixResults(

          appState.quickfixOriginalText, 

          fallbackFixedText, 

          selectedFlags, 

          estimatedNewScore, 

          improvement

        );



        setTimeout(() => {

          window.scrollTo({ top: 0, behavior: 'smooth' });

        }, 100);



        showSuccessMessage('âš ï¸ Showing local fixes (server error occurred).');

        if (button) {

          button.textContent = originalButtonText;

          button.disabled = false;

        }

        return; // Exit early

      }

    } catch (fallbackErr) {

      console.error('âŒ Fallback failed:', fallbackErr);

    }



    if (button) {

      button.textContent = originalButtonText;

      button.disabled = false;

    }

    showSuccessMessage('âŒ An unexpected error occurred. Please check the console and try again.');

  });

}



// QuickFix flow starter function (kept for backwards compatibility if needed)

// Note: The emergencyButton now uses an event listener that calls showQuickFixConfirmationModal()

function startQuickFixFlow() {

  const essayInput = document.getElementById('essayInput');

  if (!essayInput || !essayInput.value) {

    showSuccessMessage('Please enter your essay first!');

    return;

  }



  const text = essayInput.value.trim();

  if (text.length < 50) {

    showSuccessMessage('Essay must be at least 50 characters long!');

    return;

  }



  // Store original text and analyze

  appState.quickfixOriginalText = text;



  // Show QuickFix Step 1 (payment/confirmation)

  showQuickFixStep(1);



  // Scroll to top

  window.scrollTo({ top: 0, behavior: 'smooth' });

}



// Make function globally accessible

window.startQuickFixFlow = startQuickFixFlow;



// FIXED: Apply All Fixes - PROPERLY REDIRECTS TO QUICKFIX RESULTS  

function applyAllFixes() {

  // Check if required data exists

  if (!appState.quickfixOriginalText || !appState.quickfixFlags || appState.quickfixFlags.length === 0) {

    console.error('Missing required data for applyAllFixes:', {

      originalText: appState.quickfixOriginalText,

      flags: appState.quickfixFlags

    });

    showSuccessMessage('Error: Missing essay data. Please go back and try again.');

    return;

  }



  // Check all checkboxes and apply

  document.querySelectorAll('.fix-option input[type="checkbox"]').forEach(checkbox => {

    checkbox.checked = true;

    checkbox.closest('.fix-option').classList.add('selected');

  });

  updateSelectedCount();



  const button = document.getElementById('applyAllFixes');

  const originalHTML = button.innerHTML;

  button.innerHTML = 'Applying all fixes... âœ¨';

  button.disabled = true;



  // Simulate API call with timeout

  setTimeout(() => {

    try {

      // Apply all fixes locally

      const fixedText = AIDetectionEngine.applyFixes(appState.quickfixOriginalText, appState.quickfixFlags);



      // Calculate new score

      let totalReduction = 0;

      appState.quickfixFlags.forEach(flag => {

        totalReduction += flag.impact;

      });

      const estimatedNewScore = Math.max(15, appState.quickfixOriginalScore - totalReduction);

      const improvement = appState.quickfixOriginalScore - estimatedNewScore;



      appState.quickfixFixedText = fixedText;

      appState.quickfixNewScore = estimatedNewScore;



      // âœ… CRITICAL FIX: Redirect to QuickFix results page (Step 3)

      showQuickFixStep(3);

      displayQuickFixResults(appState.quickfixOriginalText, fixedText, appState.quickfixFlags, estimatedNewScore, improvement);



      // Update labels if in Pro mode

      if (appState.isProUser) {

        setTimeout(() => {

          updateStepLabels(true);

        }, 100);

      }



      // Scroll to top of the page to show the results

      setTimeout(() => {

        window.scrollTo({ top: 0, behavior: 'smooth' });

      }, 100);



    } catch (error) {

      console.error('Error applying fixes:', error);

      showSuccessMessage('Error applying fixes. Please try again.');

    } finally {

      // Reset button

      button.innerHTML = originalHTML;

      button.disabled = false;

    }

  }, 1500);

}



// Scanning modal functions

function showScanningModal() {

  const modal = document.createElement('div');

  modal.id = 'scanningModal';

  modal.style.cssText = `

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background: rgba(0, 0, 0, 0.8);

    display: flex;

    justify-content: center;

    align-items: center;

    z-index: 10000;

    backdrop-filter: blur(5px);

  `;



  // Check if this is a Pro scan

  const isPro = appState.isProUser || appState.proSubscription?.active || false;



  // Use rotating logo for Pro, Lil Sus for QuickFix

  const logoUrl = isPro 

    ? 'https://i.postimg.cc/hPKB2kRp/Final-site-icon-trans.png'

    : 'https://i.postimg.cc/HsCBbtHt/Generated-Image-September-03-2025-5-35PM.jpg';



  const logoStyle = isPro

    ? 'width: 100px; height: auto; margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto; animation: rotateLogo 3s linear infinite;'

    : 'width: 100px; height: auto; margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto;';



  // Initialize countdown timer

  let countdown = 12;



  modal.innerHTML = `

    <div style="

      text-align: center;

      padding: 20px;

    ">

      <img src="${logoUrl}" alt="${isPro ? 'Logo' : 'Lil Sus Character'}" style="${logoStyle}">

      <p style="color: #ffffff; margin-bottom: 15px; font-size: 22px; text-align: center; line-height: 1.4; font-weight: 600;">

        Scanning for AI Trigger Words. Hold Up.

      </p>

      <div id="scanningCountdown" style="color: #ffffff; font-size: 18px; font-weight: 700; margin-top: 10px;">

        ${countdown}s

      </div>

    </div>

  `;



  // Add CSS animations

  const style = document.createElement('style');

  style.textContent = `

    @keyframes rotateLogo {

      from { transform: rotate(0deg); }

      to { transform: rotate(360deg); }

    }

  `;

  document.head.appendChild(style);



  document.body.appendChild(modal);

  document.body.classList.add('modal-open');



  // Start countdown timer

  const countdownElement = document.getElementById('scanningCountdown');

  const countdownInterval = setInterval(() => {

    countdown--;

    if (countdownElement) {

      countdownElement.textContent = countdown + 's';

    }

    if (countdown <= 0) {

      clearInterval(countdownInterval);

      if (countdownElement) {

        countdownElement.textContent = '0s';

      }

    }

  }, 1000);



  // Store interval ID so it can be cleared if modal is closed early

  modal.dataset.countdownInterval = countdownInterval;

}

function hideScanningModal() {

  const modal = document.getElementById('scanningModal');

  if (modal) {

    // Clear countdown interval if it exists

    if (modal.dataset.countdownInterval) {

      clearInterval(parseInt(modal.dataset.countdownInterval));

    }

    modal.remove();

    document.body.classList.remove('modal-open');

  }

}



// Lighter modal for "Get More Fix Suggestions" - not a full scan

function showGettingSuggestionsModal() {

  const modal = document.createElement('div');

  modal.id = 'gettingSuggestionsModal';

  modal.style.cssText = `

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background: rgba(0, 0, 0, 0.6);

    display: flex;

    justify-content: center;

    align-items: center;

    z-index: 10000;

    backdrop-filter: blur(3px);

  `;



  modal.innerHTML = `

    <div style="

      background: white;

      padding: 32px;

      border-radius: 16px;

      text-align: center;

      max-width: 350px;

      width: 90%;

      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.2);

    ">

      <div style="font-size: 40px; margin-bottom: 16px;">

        âœï¸

      </div>

      <h2 style="color: #0b0646; margin-bottom: 12px; font-size: 20px; font-weight: 600;">

        Getting More Suggestions...

      </h2>

      <p style="color: #6b7280; margin-bottom: 20px; font-size: 14px;">

        Loading alternative word options...

      </p>

      <div style="display: flex; justify-content: center; gap: 4px;">

        <div class="scanning-dot" style="width: 6px; height: 6px; background: #f5a623; border-radius: 50%; animation: scanningPulse 1.5s infinite;"></div>

        <div class="scanning-dot" style="width: 6px; height: 6px; background: #f5a623; border-radius: 50%; animation: scanningPulse 1.5s infinite 0.2s;"></div>

        <div class="scanning-dot" style="width: 6px; height: 6px; background: #f5a623; border-radius: 50%; animation: scanningPulse 1.5s infinite 0.4s;"></div>

      </div>

    </div>

  `;



  document.body.appendChild(modal);

}



function hideGettingSuggestionsModal() {

  const modal = document.getElementById('gettingSuggestionsModal');

  if (modal) {

    modal.remove();

  }

}



// QuickFix Processing Modal (shown when applying fixes)

function showQuickFixProcessingModal() {

  console.log('ðŸŽ¬ showQuickFixProcessingModal() called');



  // Remove existing modal if present

  const existingModal = document.getElementById('quickfixProcessingModal');

  if (existingModal) {

    console.log('ðŸ—‘ï¸ Removing existing modal');

    existingModal.remove();

  }



  const modal = document.createElement('div');

  modal.id = 'quickfixProcessingModal';

  // Store timestamp when modal was created

  modal._createdAt = Date.now();

  modal._minimumDisplayTime = 5000; // 5 seconds minimum

  modal._canBeHidden = false; // Flag to prevent premature hiding

  modal._isHiding = false; // Flag to prevent multiple hide calls

  console.log('âœ… Modal element created at:', modal._createdAt);

  modal.style.cssText = `

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background: rgba(0, 0, 0, 0.8);

    display: flex;

    justify-content: center;

    align-items: center;

    z-index: 10000;

    backdrop-filter: blur(5px);

    opacity: 0;

    animation: fadeInModal 0.2s ease forwards;

  `;



  // Add fadeIn animation CSS if not already added

  if (!document.getElementById('modalFadeAnimation')) {

    const style = document.createElement('style');

    style.id = 'modalFadeAnimation';

    style.textContent = `

      @keyframes fadeInModal {

        from { opacity: 0; }

        to { opacity: 1; }

      }

    `;

    document.head.appendChild(style);

  }



  // Start countdown from 5 seconds

  let countdown = 5;



  // Check if this is a Pro scan

  const isPro = appState.isProUser || appState.proSubscription?.active || false;



  // Use rotating logo for Pro, Lil Sus for QuickFix

  const logoUrl = isPro 

    ? 'https://i.postimg.cc/hPKB2kRp/Final-site-icon-trans.png'

    : 'https://i.postimg.cc/hPKB2kRp/Final-site-icon-trans.png'; // Use same logo for consistency



  const logoStyle = isPro

    ? 'width: 100px; height: auto; margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto; animation: rotateLogo 3s linear infinite;'

    : 'width: 100px; height: auto; margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto; animation: rotateLogo 3s linear infinite;';



  modal.innerHTML = `

    <div style="

      text-align: center;

      padding: 20px;

    ">

      <img src="${logoUrl}" alt="Logo" style="${logoStyle}">

      <p style="color: #ffffff; margin-bottom: 15px; font-size: 22px; text-align: center; line-height: 1.4; font-weight: 600;">

        Rescanning to lower your score. Hold Up.

      </p>

      <div id="quickfixCountdown" style="color: #ffffff; font-size: 18px; font-weight: 700; margin-top: 10px;">

        ${countdown}s

      </div>

    </div>

  `;



  // Add rotateLogo animation if not already added

  if (!document.getElementById('rotateLogoAnimation')) {

    const rotateStyle = document.createElement('style');

    rotateStyle.id = 'rotateLogoAnimation';

    rotateStyle.textContent = `

      @keyframes rotateLogo {

        from { transform: rotate(0deg); }

        to { transform: rotate(360deg); }

      }

    `;

    document.head.appendChild(rotateStyle);

  }



  document.body.appendChild(modal);

  document.body.classList.add('modal-open');

  console.log('âœ… Modal appended to body, modal-open class added');



  // Force display with a small delay to ensure DOM is ready

  setTimeout(() => {

    const checkModal = document.getElementById('quickfixProcessingModal');

    if (checkModal) {

      checkModal.style.setProperty('display', 'flex', 'important');

      checkModal.style.setProperty('visibility', 'visible', 'important');

      checkModal.style.setProperty('opacity', '1', 'important');

      console.log('âœ… Modal display forced to visible');

    }

  }, 10);



  // Start countdown timer

  const countdownEl = document.getElementById('quickfixCountdown');

  console.log('âœ… Countdown element found:', !!countdownEl);

  const countdownInterval = setInterval(() => {

    countdown--;

    if (countdownEl) {

      if (countdown > 0) {

        countdownEl.textContent = countdown + 's';

      } else {

        countdownEl.textContent = '0s';

        clearInterval(countdownInterval);

      }

    } else {

      clearInterval(countdownInterval);

    }

  }, 1000);



  // Store interval ID on modal for cleanup

  modal._countdownInterval = countdownInterval;



  // Allow hiding after minimum display time

  setTimeout(() => {

    modal._canBeHidden = true;

    console.log('âœ… Modal can now be hidden (minimum display time passed)');

  }, modal._minimumDisplayTime);

}



function hideQuickFixProcessingModal() {

  const modal = document.getElementById('quickfixProcessingModal');

  if (!modal) {

    console.log('âš ï¸ hideQuickFixProcessingModal: Modal not found');

    return;

  }



  // Clear countdown interval if it exists

  if (modal._countdownInterval) {

    clearInterval(modal._countdownInterval);

  }



  // Prevent multiple hide calls

  if (modal._isHiding) {

    console.log('âš ï¸ hideQuickFixProcessingModal: Already hiding, ignoring duplicate call');

    return;

  }



  // Check if minimum display time has passed

  const displayTime = Date.now() - (modal._createdAt || Date.now());

  const minTime = modal._minimumDisplayTime || 5000;



  if (!modal._canBeHidden && displayTime < minTime) {

    const remaining = minTime - displayTime;

    console.log('âš ï¸ hideQuickFixProcessingModal: Cannot hide yet. Remaining:', remaining, 'ms');



    // Schedule hide after minimum time

    setTimeout(() => {

      hideQuickFixProcessingModal();

    }, remaining);

    return;

  }



  // Mark as hiding to prevent duplicate calls

  modal._isHiding = true;

  console.log('âœ… hideQuickFixProcessingModal: Hiding modal after', displayTime, 'ms');



    // Clear countdown interval if it exists

    if (modal._countdownInterval) {

      clearInterval(modal._countdownInterval);

    }



  // Fade out animation

  modal.style.animation = 'fadeInModal 0.2s ease reverse forwards';



  // Remove after animation completes

  setTimeout(() => {

    modal.remove();

    document.body.classList.remove('modal-open');

    console.log('âœ… Modal removed from DOM');

  }, 250);

}



// NEW: Complete Rewrite function - SENDS TO STEP 4

function completeRewrite() {

  if (appState.freeRewritesUsed >= appState.maxFreeRewrites) {

    showSuccessMessage('âŒ No free Pro scans left', '#dc2626');

    return;

  }



  const textToRewrite = appState.quickfixOriginalText || '';



  if (!textToRewrite) {

    showSuccessMessage('âŒ Missing essay text', '#dc2626');

    return;

  }



  // Show scanning modal

  if (typeof showScanningModal === 'function') {

  showScanningModal();

  }



  setTimeout(() => {

    try {

      // Run complete rewrite

      const rewrittenText = AIDetectionEngine.completeRewrite(textToRewrite);

      const newScore = AIDetectionEngine.calculateScore(rewrittenText);



      appState.quickfixFixedText = rewrittenText;

      appState.quickfixNewScore = newScore;

      appState.freeRewritesUsed++;



      // Hide scanning modal

      if (typeof hideScanningModal === 'function') {

      hideScanningModal();

      }



      // Go to Step 4

      if (typeof showFullDeFlagPage === 'function') {

      showFullDeFlagPage();

      }



    } catch (error) {

      console.error('Rewrite error:', error);

      if (typeof hideScanningModal === 'function') {

      hideScanningModal();

    }

      showSuccessMessage('âŒ Error during rewrite', '#dc2626');

    }

  }, 2000);

}



// Global escapeHtml function

window.escapeHtml = function(text) {

  if (!text) return '';

  const div = document.createElement('div');

  div.textContent = text;

  return div.innerHTML;

};



// Function to show QuickFix highlight popup

function showQuickFixPopup(spanElement, event) {

  // Remove any existing popup

  hideQuickFixPopup();



  const originalWord = spanElement.getAttribute('data-original');

  const replacementWord = spanElement.getAttribute('data-replacement');

  const quickfixIndex = spanElement.getAttribute('data-quickfix-index');



  // Create popup element

  const popup = document.createElement('div');

  popup.id = 'quickfixHighlightPopup';

  popup.style.cssText = `

    position: absolute;

    background: white;

    border: 2px solid #10b981;

    border-radius: 8px;

    padding: 12px;

    box-shadow: 0 4px 12px rgba(0,0,0,0.2);

    z-index: 10000;

    display: flex;

    flex-direction: column;

    gap: 8px;

    min-width: 200px;

  `;



  // Popup content

  popup.innerHTML = `

    <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">

      QuickFix: "${originalWord}" â†’ "${replacementWord}"

    </div>

    <div style="display: flex; gap: 6px;">

      <button class="quickfix-popup-btn" data-action="keep" style="flex: 1; padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">âœ… Keep</button>

      <button class="quickfix-popup-btn" data-action="revert" style="flex: 1; padding: 6px 12px; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">âŒ Revert</button>

      <button class="quickfix-popup-btn" data-action="edit" style="flex: 1; padding: 6px 12px; background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">âœï¸ Edit</button>

    </div>

  `;



  // Position popup near the clicked element (with bounds checking to prevent cutoff)

  const rect = spanElement.getBoundingClientRect();

  const containerRect = spanElement.closest('#quickfixFixedTextArea').getBoundingClientRect();

  const viewportWidth = window.innerWidth;

  const viewportHeight = window.innerHeight;

  const popupWidth = 220;

  const popupHeight = 100;



  let topPos = rect.bottom - containerRect.top + 5;

  let leftPos = rect.left - containerRect.left;



  // Check if popup would go off right edge

  if (leftPos + popupWidth > viewportWidth - 20) {

    leftPos = Math.max(20, viewportWidth - popupWidth - 20);

  }



  // Check if popup would go off bottom edge - show above instead

  if (topPos + popupHeight > viewportHeight - 20) {

    topPos = Math.max(20, rect.top - containerRect.top - popupHeight - 5);

  }



  // Check if popup would go off left edge

  if (leftPos < 20) {

    leftPos = 20;

  }



  // Check if popup would go off top edge

  if (topPos < 20) {

    topPos = rect.bottom - containerRect.top + 5;

  }



  popup.style.top = topPos + 'px';

  popup.style.left = leftPos + 'px';



  // Add popup to container

  const container = spanElement.closest('#quickfixFixedTextArea');

  container.style.position = 'relative';

  container.appendChild(popup);



  // Store reference for actions

  window.currentQuickFixPopup = {

    span: spanElement,

    originalWord: originalWord,

    replacementWord: replacementWord,

    index: quickfixIndex

  };



  // Add button handlers

  popup.querySelectorAll('.quickfix-popup-btn').forEach(btn => {

    btn.addEventListener('click', function(e) {

      e.stopPropagation();

      const action = this.getAttribute('data-action');

      handleQuickFixAction(action, spanElement, originalWord, replacementWord);

      hideQuickFixPopup();

    });

  });



  // Close on outside click

  setTimeout(() => {

    document.addEventListener('click', hideQuickFixPopup, { once: true });

  }, 0);

}



// Function to hide QuickFix popup

function hideQuickFixPopup() {

  const popup = document.getElementById('quickfixHighlightPopup');

  if (popup) {

    popup.remove();

  }

  window.currentQuickFixPopup = null;

}



// Function to show user edit popup (for yellow highlights)

function showUserEditPopup(spanElement, event) {

  // Remove any existing popups

  hideQuickFixPopup();

  hideUserEditPopup();



  const changedFrom = spanElement.getAttribute('data-changed-from') || spanElement.textContent;

  const currentWord = spanElement.textContent;



  // Create popup element

  const popup = document.createElement('div');

  popup.id = 'userEditHighlightPopup';

  popup.style.cssText = `

    position: absolute;

    background: white;

    border: 2px solid #f59e0b;

    border-radius: 8px;

    padding: 12px;

    box-shadow: 0 4px 12px rgba(0,0,0,0.2);

    z-index: 10000;

    display: flex;

    flex-direction: column;

    gap: 8px;

    min-width: 200px;

  `;



  // Popup content

  popup.innerHTML = `

    <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">

      Your edit: "${changedFrom}" â†’ "${currentWord}"

    </div>

    <div style="display: flex; gap: 6px;">

      <button class="user-edit-popup-btn" data-action="keep" style="flex: 1; padding: 6px 12px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">âœ… Keep</button>

      <button class="user-edit-popup-btn" data-action="edit" style="flex: 1; padding: 6px 12px; background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">âœï¸ Edit</button>

      <button class="user-edit-popup-btn" data-action="revert" style="flex: 1; padding: 6px 12px; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">âŒ Revert</button>

    </div>

  `;



  // Position popup near the clicked element (with bounds checking to prevent cutoff)

  const rect = spanElement.getBoundingClientRect();

  const containerRect = spanElement.closest('#quickfixFixedTextArea').getBoundingClientRect();

  const viewportWidth = window.innerWidth;

  const viewportHeight = window.innerHeight;

  const popupWidth = 220;

  const popupHeight = 100;



  let topPos = rect.bottom - containerRect.top + 5;

  let leftPos = rect.left - containerRect.left;



  // Check if popup would go off right edge

  if (leftPos + popupWidth > viewportWidth - 20) {

    leftPos = Math.max(20, viewportWidth - popupWidth - 20);

  }



  // Check if popup would go off bottom edge - show above instead

  if (topPos + popupHeight > viewportHeight - 20) {

    topPos = Math.max(20, rect.top - containerRect.top - popupHeight - 5);

  }



  // Check if popup would go off left edge

  if (leftPos < 20) {

    leftPos = 20;

  }



  // Check if popup would go off top edge

  if (topPos < 20) {

    topPos = rect.bottom - containerRect.top + 5;

  }



  popup.style.top = topPos + 'px';

  popup.style.left = leftPos + 'px';



  // Add popup to container

  const container = spanElement.closest('#quickfixFixedTextArea');

  container.style.position = 'relative';

  container.appendChild(popup);



  // Store reference for actions

  window.currentUserEditPopup = {

    span: spanElement,

    changedFrom: changedFrom,

    currentWord: currentWord

  };



  // Add button handlers

  popup.querySelectorAll('.user-edit-popup-btn').forEach(btn => {

    btn.addEventListener('click', function(e) {

      e.stopPropagation();

      const action = this.getAttribute('data-action');

      handleUserEditAction(action, spanElement, changedFrom, currentWord);

      hideUserEditPopup();

    });

  });



  // Close on outside click

  setTimeout(() => {

    document.addEventListener('click', hideUserEditPopup, { once: true });

  }, 0);

}



// Function to hide user edit popup

function hideUserEditPopup() {

  const popup = document.getElementById('userEditHighlightPopup');

  if (popup) {

    popup.remove();

  }

  window.currentUserEditPopup = null;

}



// Function to handle user edit actions (Keep/Edit/Revert)

function handleUserEditAction(action, spanElement, changedFrom, currentWord) {

  const editableDiv = document.getElementById('quickfixFixedTextArea');

  if (!editableDiv) return;



  switch(action) {

    case 'keep':

      // Remove yellow highlight but keep the word

      const keepText = spanElement.textContent;

      spanElement.outerHTML = keepText;

      // Update baseline

      window.quickfixBaselineText = editableDiv.innerText || editableDiv.textContent || '';

      break;



    case 'revert':

      // Replace with the word it was changed from BUT KEEP YELLOW HIGHLIGHT

      spanElement.outerHTML = `<span class="user-edit-highlight" data-user-edit="true" data-changed-from="${escapeHtml(changedFrom)}" style="background-color: #fef3c7; border-bottom: 2px solid #f59e0b; padding: 2px 0; font-weight: 600; cursor: pointer; position: relative;" title="You changed from '${escapeHtml(changedFrom)}' to '${escapeHtml(changedFrom)}' - Click to interact">${escapeHtml(changedFrom)}</span>`;

      // Update baseline

      window.quickfixBaselineText = editableDiv.innerText || editableDiv.textContent || '';

      break;



    case 'edit':

      // Create input box for editing (same as QuickFix edit)

      window.quickfixEditingActive = true;

      const editInput = document.createElement('input');

      editInput.type = 'text';

      editInput.value = currentWord;

      editInput.style.cssText = `

        display: inline-block;

        padding: 4px 8px;

        border: 2px solid #00a8e8;

        border-radius: 4px;

        font-size: 16px;

        font-family: inherit;

        min-width: 100px;

        max-width: 200px;

        margin-left: 4px;

        vertical-align: baseline;

        z-index: 10001;

        position: relative;

      `;

      editInput.className = 'quickfix-edit-input';



      // Insert input after the span

      spanElement.parentNode.insertBefore(editInput, spanElement.nextSibling);



      // Focus the input

      setTimeout(() => {

        editInput.focus();

        editInput.select();

      }, 10);



      // Handle Enter key

      editInput.addEventListener('keydown', function(e) {

        if (e.key === 'Enter') {

          e.preventDefault();

          e.stopPropagation();

          window.quickfixEditingActive = false;

          applyUserEdit(editInput, spanElement, changedFrom);

        } else if (e.key === 'Escape') {

          e.preventDefault();

          e.stopPropagation();

          window.quickfixEditingActive = false;

          cancelEdit(editInput);

        }

      });



      // Handle blur

      editInput.addEventListener('blur', function() {

        setTimeout(() => {

          if (editInput.parentNode && document.activeElement !== editInput) {

            window.quickfixEditingActive = false;

            applyUserEdit(editInput, spanElement, changedFrom);

          }

        }, 150);

      });

      break;

  }



  // Trigger input event to update highlights

  editableDiv.dispatchEvent(new Event('input', { bubbles: true }));

}



// Function to apply user edit from input box

function applyUserEdit(editInput, spanElement, changedFrom) {

  const newWord = editInput.value.trim();

  const editableDiv = document.getElementById('quickfixFixedTextArea');

  if (!editableDiv) return;



  // Remove input box first

  if (editInput.parentNode) {

    editInput.remove();

  }



  if (newWord) {

    if (newWord === changedFrom) {

      // Reverted to original - remove highlight

      spanElement.outerHTML = newWord;

    } else {

      // New edit - keep yellow highlight

      spanElement.outerHTML = `<span class="user-edit-highlight" data-user-edit="true" data-changed-from="${escapeHtml(changedFrom)}" style="background-color: #fef3c7; border-bottom: 2px solid #f59e0b; padding: 2px 0; font-weight: 600; cursor: pointer; position: relative;" title="You changed from '${escapeHtml(changedFrom)}' to '${escapeHtml(newWord)}' - Click to interact">${escapeHtml(newWord)}</span>`;

    }



    // Update baseline

    window.quickfixBaselineText = editableDiv.innerText || editableDiv.textContent || '';



    // Trigger input event

    setTimeout(() => {

      const event = new Event('input', { bubbles: true });

      editableDiv.dispatchEvent(event);

    }, 50);

  }

}



// Function to handle QuickFix actions (Keep/Revert/Edit)

function handleQuickFixAction(action, spanElement, originalWord, replacementWord) {

  const editableDiv = document.getElementById('quickfixFixedTextArea');

  if (!editableDiv) return;



  const currentText = editableDiv.innerText || editableDiv.textContent || '';



  switch(action) {

    case 'keep':

      // Remove green highlight but keep the word

      const keepText = spanElement.textContent;

      spanElement.outerHTML = keepText;

      // Update baseline to reflect this is now "kept"

      window.quickfixBaselineText = editableDiv.innerText || editableDiv.textContent || '';

      break;



    case 'revert':

      // Replace with original word BUT KEEP THE GREEN QUICKFIX HIGHLIGHT

      const revertText = originalWord;

      // Preserve capitalization if replacement was capitalized

      const wasCapitalized = spanElement.textContent && spanElement.textContent[0] === spanElement.textContent[0].toUpperCase();

      const finalRevertText = wasCapitalized && revertText.length > 0 

        ? revertText.charAt(0).toUpperCase() + revertText.slice(1)

        : revertText;



      // Re-apply QuickFix highlight (green) with original word

      const quickfixIndex = spanElement.getAttribute('data-quickfix-index') || '0';

      spanElement.outerHTML = `<span class="quickfix-highlight" data-quickfix-index="${quickfixIndex}" data-original="${escapeHtml(originalWord)}" data-replacement="${escapeHtml(finalRevertText)}" style="background-color: #d1fae5; border-bottom: 2px solid #10b981; padding: 2px 0; font-weight: 600; cursor: pointer; position: relative;" title="QuickFix changed from '${escapeHtml(originalWord)}' to '${escapeHtml(finalRevertText)}' - Click to interact">${escapeHtml(finalRevertText)}</span>`;

      // Update baseline

      window.quickfixBaselineText = editableDiv.innerText || editableDiv.textContent || '';

      break;



    case 'edit':

      // Set editing flag to prevent input handler from interfering

      window.quickfixEditingActive = true;



      // Create a small input box next to the word for editing

      const currentWord = spanElement.textContent;



      // Create input element

      const editInput = document.createElement('input');

      editInput.type = 'text';

      editInput.value = currentWord;

      editInput.style.cssText = `

        display: inline-block;

        padding: 4px 8px;

        border: 2px solid #00a8e8;

        border-radius: 4px;

        font-size: 16px;

        font-family: inherit;

        min-width: 100px;

        max-width: 200px;

        margin-left: 4px;

        vertical-align: baseline;

        z-index: 10001;

        position: relative;

      `;

      editInput.className = 'quickfix-edit-input';



      // Store reference to span for replacement

      editInput.dataset.spanId = spanElement.getAttribute('data-quickfix-index');

      editInput.dataset.originalWord = originalWord;



      // Insert input after the span

      spanElement.parentNode.insertBefore(editInput, spanElement.nextSibling);



      // Focus the input

      setTimeout(() => {

        editInput.focus();

        editInput.select();

      }, 10);



      // Handle Enter key to apply edit

      editInput.addEventListener('keydown', function(e) {

        if (e.key === 'Enter') {

          e.preventDefault();

          e.stopPropagation();

          window.quickfixEditingActive = false;

          applyEdit(editInput, spanElement, originalWord);

        } else if (e.key === 'Escape') {

          e.preventDefault();

          e.stopPropagation();

          window.quickfixEditingActive = false;

          cancelEdit(editInput);

        }

      });



      // Handle blur to apply edit (with delay to allow Enter key to work first)

      editInput.addEventListener('blur', function() {

        setTimeout(() => {

          if (editInput.parentNode && document.activeElement !== editInput) {

            window.quickfixEditingActive = false;

            applyEdit(editInput, spanElement, originalWord);

          }

        }, 150);

      });



      break;

  }



  // Trigger input event to update highlights

  editableDiv.dispatchEvent(new Event('input', { bubbles: true }));

}



// Function to apply edit from input box

function applyEdit(editInput, spanElement, originalWord) {

  const newWord = editInput.value.trim();

  const editableDiv = document.getElementById('quickfixFixedTextArea');

  if (!editableDiv) return;



  // Remove input box first to prevent interference

  if (editInput.parentNode) {

    editInput.remove();

  }



  if (newWord) {

    // Check if this was a QuickFix highlight or user edit highlight

    const isQuickFix = spanElement.classList.contains('quickfix-highlight');

    const isUserEdit = spanElement.classList.contains('user-edit-highlight');



    if (newWord === originalWord) {

      // Reverted to original - remove highlight completely

      spanElement.outerHTML = newWord;

    } else {

      // New edit - highlight as user edit (YELLOW) with Keep/Edit/Revert options

      // Store what it was changed from

      const changedFrom = spanElement.textContent || spanElement.innerText || '';



      // Create yellow user edit highlight with interaction

      spanElement.outerHTML = `<span class="user-edit-highlight" data-user-edit="true" data-changed-from="${escapeHtml(changedFrom)}" style="background-color: #fef3c7; border-bottom: 2px solid #f59e0b; padding: 2px 0; font-weight: 600; cursor: pointer; position: relative;" title="You changed from '${escapeHtml(changedFrom)}' to '${escapeHtml(newWord)}' - Click to interact">${escapeHtml(newWord)}</span>`;

    }



    // Update baseline

    window.quickfixBaselineText = editableDiv.innerText || editableDiv.textContent || '';



    // Small delay before triggering input event to ensure DOM is updated

    setTimeout(() => {

      // Trigger input event to update highlights

      const event = new Event('input', { bubbles: true });

      editableDiv.dispatchEvent(event);

    }, 50);

  }

}



// Function to cancel edit

function cancelEdit(editInput) {

  // Just remove the input box without applying changes

  if (editInput.parentNode) {

    editInput.remove();

  }

  window.quickfixEditingActive = false;

}



// Function to populate the "What We Changed" sections (Text Phrases + Structural)

// Populate the two-section fix display (Text Phrases + Structural Patterns)

function populateFixSections(textPhraseFlags, structuralFlags) {

  // SECTION A: Text Phrases

  const textPhrasesContent = document.getElementById('textPhrasesContent');

  if (textPhrasesContent) {

    if (!textPhraseFlags || textPhraseFlags.length === 0) {

      textPhrasesContent.innerHTML = '<p style="font-size: 12px; color: #047857; margin: 0;">No text phrase flags found - great job!</p>';

    } else {

      let html = '';

      // Removed Smart Sort buttons - they were confusing. Just show the fixes.

      textPhraseFlags.forEach((flag, idx) => {

        const replacement = flag.bestFix || flag.alternatives?.[0] || 'fixed';

        html += `

          <div class="fix-item" style="border: 1px solid #d1e5da; padding: 12px; border-radius: 6px; margin-bottom: 12px; background: #f0fdf4;">

            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">

              <div>

                <div style="font-size: 12px; font-weight: 700; color: #047857; margin-bottom: 4px;">

                  ${flag.fixPriority || 'ðŸŸ¦ MEDIUM'}

                </div>

                <div style="font-size: 14px; font-weight: 700; color: #047857; margin-bottom: 4px;">

                  "${flag.phrase}" â†’ "${replacement}"

                </div>

              </div>

              <div style="font-size: 11px; background: #10b981; color: white; padding: 4px 8px; border-radius: 4px;">

                ${flag.timeEstimate || '30 seconds'}

              </div>

            </div>

            <div style="font-size: 12px; color: #374151; margin-bottom: 8px;">

              ${flag.explanation || 'AI trigger word removed'}

            </div>

            <div style="font-size: 11px; color: #6b7280; margin-top: 8px; font-style: italic;">

              âœ… Already fixed in your essay above

            </div>

          </div>

        `;

      });

      textPhrasesContent.innerHTML = html;

    }

  }



  // SECTION B: Structural Patterns

  // Only show actual structural patterns (not individual words)

  const structuralContent = document.getElementById('structuralContent');

  if (structuralContent) {

    // Filter out individual words - only show actual pattern names

    const actualPatterns = (structuralFlags || []).filter(flag => {

      if (!flag || !flag.phrase) return false;

      const phrase = flag.phrase.toLowerCase();

      // Only show patterns that are actual writing style issues, not individual words

      const patternKeywords = [

        'no contractions', 'contraction', 'sentence length', 'uniform sentence',

        'personal voice', 'overly formal', 'transition words', 'overall writing',

        'writing style', 'grammar', 'tone', 'repetitive', 'pattern'

      ];

      // If it's a single word or short phrase (likely a word flag), skip it

      if (phrase.split(' ').length <= 2 && !patternKeywords.some(kw => phrase.includes(kw))) {

        return false;

      }

      return patternKeywords.some(kw => phrase.includes(kw));

    });



    if (actualPatterns.length === 0) {

      structuralContent.innerHTML = '<p style="font-size: 12px; color: #92400e; margin: 0;">âœ… No writing style issues found - your essay structure looks good!</p>';

    } else {

      let html = '';

      actualPatterns.forEach((flag, idx) => {

        html += `

          <div class="fix-item" style="border: 2px solid #f59e0b; padding: 16px; border-radius: 8px; margin-bottom: 16px; background: #fffbf0;">

            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">

              <span style="font-size: 24px;">ðŸ“</span>

              <div style="font-size: 16px; font-weight: 700; color: #92400e;">

                ${flag.phrase}

              </div>

            </div>

            <div style="font-size: 13px; color: #374151; margin-bottom: 12px; line-height: 1.6; background: white; padding: 12px; border-radius: 6px;">

              ${flag.explanation || 'This is a writing style suggestion, not an error.'}

            </div>

            ${flag.examples && flag.examples.length > 0 ? `

              <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; border-left: 4px solid #f59e0b;">

                <strong style="color: #0b0646; display: block; margin-bottom: 8px;">ðŸ’¡ Example:</strong>

                ${flag.examples.slice(0, 2).map(ex => `

                  <div style="margin-top: 8px; padding: 8px; background: #fef3c7; border-radius: 4px;">

                    <div style="color: #dc2626; margin-bottom: 4px;">âŒ <strong>Before:</strong> ${ex.before}</div>

                    <div style="color: #10b981;">âœ… <strong>After:</strong> ${ex.after}</div>

                  </div>

                `).join('')}

              </div>

            ` : ''}

            ${flag.actionable ? `

              <div style="background: #e0f2fe; padding: 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; border-left: 4px solid #00a8e8;">

                <strong style="color: #01579b; display: block; margin-bottom: 6px;">ðŸ“‹ How to improve:</strong>

                <span style="color: #01579b; line-height: 1.6;">${flag.actionable}</span>

              </div>

            ` : ''}

          </div>

        `;

      });

      structuralContent.innerHTML = html;

    }

  }

}



// Smart Sort function

function sortFixesBy(sortType) {

  const flags = appState.quickfixTextPhraseFlags;

  if (!flags || flags.length === 0) return;



  let sorted;



  if (sortType === 'impact') {

    sorted = [...flags].sort((a, b) => {

      const severityOrder = { high: 0, medium: 1, low: 2 };

      return (severityOrder[a.severity] || 99) - (severityOrder[b.severity] || 99);

    });

  } else if (sortType === 'speed') {

    sorted = [...flags].sort((a, b) => {

      const timeOrder = { '10 seconds': 0, '20 seconds': 1, '30 seconds': 2, 'Fix immediately': 3 };

      return (timeOrder[a.timeEstimate] || 99) - (timeOrder[b.timeEstimate] || 99);

    });

  } else if (sortType === 'ease') {

    sorted = [...flags].sort((a, b) => {

      const aWords = (a.phrase || '').split(' ').length;

      const bWords = (b.phrase || '').split(' ').length;

      return aWords - bWords;

    });

  } else {

    return; // Invalid sort type

  }



  appState.quickfixTextPhraseFlags = sorted;

  populateFixSections(sorted, appState.quickfixStructuralFlags);

  showSuccessMessage(`âœ… Sorted by ${sortType}`);

}



// Highlight a pattern in the editable text box (safe version)

function highlightPatternInText(phrase) {

  const editableDiv = document.getElementById('quickfixFixedTextArea');

  if (!editableDiv) return;



  const text = editableDiv.innerText;

  const escapedPhrase = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  const regex = new RegExp(`\\b${escapedPhrase}\\b`, 'gi');



  if (!regex.test(text)) {

    showSuccessMessage(`"${phrase}" not found in current text`);

    return;

  }



  editableDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });



  const plainText = editableDiv.innerText;

  const highlighted = plainText.replace(regex, (match) => {

    return `__HIGHLIGHT_START__${match}__HIGHLIGHT_END__`;

  });



  editableDiv.innerText = highlighted;



  let html = editableDiv.innerHTML;

  html = html.replace(/__HIGHLIGHT_START__/g, '<span class="pattern-highlight" style="background: #fef3c7; padding: 2px 4px; border-radius: 3px; border: 2px solid #f59e0b;">');

  html = html.replace(/__HIGHLIGHT_END__/g, '</span>');



  editableDiv.innerHTML = html;



  setTimeout(() => {

    let current = editableDiv.innerHTML;

    current = current.replace(/<span class="pattern-highlight"[^>]*>/g, '');

    current = current.replace(/<\/span>/g, '');

    editableDiv.innerHTML = current;

  }, 3000);



  showSuccessMessage(`Found and highlighted "${phrase}" - now edit it in the essay above âœ¨`);

}



// Keep a fix (just acknowledge)

function keepFix(index, type) {

  showSuccessMessage(`âœ… Keeping "${type}" fix #${index + 1}`);

}



// Edit a fix (simple version)

function editFix(index, type) {

  const flags = type === 'text' ? appState.quickfixTextPhraseFlags : appState.quickfixStructuralFlags;

  const flag = flags?.[index];

  if (!flag) return;

  showSuccessMessage(`ðŸ’¡ Edit "${flag.phrase}" directly in the essay box above and it will be updated when you re-scan.`);

}



// Revert a fix (simple version)

function revertFix(index, type) {

  const flags = type === 'text' ? appState.quickfixTextPhraseFlags : appState.quickfixStructuralFlags;

  const flag = flags?.[index];

  if (!flag) return;

  showSuccessMessage(`â†¶ To revert "${flag.phrase}", edit it directly in the essay box above and re-scan.`);

}



function highlightPatternInText(phrase) {

  const editableDiv = document.getElementById('quickfixFixedTextArea');

  if (!editableDiv) {

    showSuccessMessage(`"${phrase}" - Edit this pattern directly in the essay box above`);

    return;

  }



  const text = editableDiv.textContent || editableDiv.innerText || '';

  const escapedPhrase = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  const regex = new RegExp(`\\b${escapedPhrase}\\b`, 'gi');



  if (!regex.test(text)) {

    showSuccessMessage(`"${phrase}" not found in current text`);

    return;

  }



  // Scroll to the element

  editableDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });



  // Highlight the pattern temporarily

  const plainText = editableDiv.textContent || editableDiv.innerText || '';

  const highlighted = plainText.replace(regex, (match) => {

    return `__HIGHLIGHT_START__${match}__HIGHLIGHT_END__`;

  });



  editableDiv.textContent = highlighted;



  // Now wrap the markers with span

  let html = editableDiv.innerHTML;

  html = html.replace(/__HIGHLIGHT_START__/g, '<span class="pattern-highlight" style="background: #fef3c7; padding: 2px 4px; border-radius: 3px; border: 2px solid #f59e0b;">');

  html = html.replace(/__HIGHLIGHT_END__/g, '</span>');

  editableDiv.innerHTML = html;



  // Remove highlights after 3 seconds

  setTimeout(() => {

    const current = editableDiv.innerHTML;

    const cleaned = current.replace(/<span class="pattern-highlight"[^>]*>/g, '');

    const finalCleaned = cleaned.replace(/<\/span>/g, '');

    editableDiv.textContent = plainText; // Restore original text

  }, 3000);



  showSuccessMessage(`Found and highlighted "${phrase}" - now edit it in the essay above âœ¨`);

}



// Populate Original Essay with Clean Flag Numbering (Simple Inline Badges)

// Now shows ONLY the top 5 highestâ€‘risk flags when there are more than 5 total

function populateOriginalWithCleanFlags(essay, flags) {

  const originalEssayEl = document.getElementById('originalEssay');



  if (!originalEssayEl || !essay || !flags || flags.length === 0) {

    console.log('âŒ Missing data for original essay');

    if (originalEssayEl && essay) {

      originalEssayEl.textContent = essay;

    }

    return;

  }



  const totalFlags = flags.length;

  console.log('ðŸ” Building clean flag view for original essay');

  console.log('Flags to process (total):', totalFlags);

  console.log('Essay length:', essay.length);



  // IMPORTANT: When there are more than 5 flags, ONLY process the top 5 highestâ€‘risk flags

  let flagsForHighlight = flags;

  if (totalFlags > 5) {

    try {

      const withSeverity = [...flags].map(flag => {

        const rawSeverity = flag && (flag.severity || flag.risk || flag.type || '');

        const sev = (typeof rawSeverity === 'string' ? rawSeverity : String(rawSeverity || '')).toLowerCase();

        let rank = 3;

        if (sev === 'high') rank = 0;

        else if (sev === 'medium') rank = 1;

        else if (sev === 'low') rank = 2;

        const riskScore = typeof flag?.riskScore === 'number' ? flag.riskScore : 0;

        return { flag, rank, riskScore };

      });



      withSeverity.sort((a, b) => {

        if (a.rank !== b.rank) return a.rank - b.rank;

        return b.riskScore - a.riskScore;

      });



      flagsForHighlight = withSeverity.slice(0, 5).map(item => item.flag);

      console.log('ðŸ” Limiting original essay highlights to top 5 highestâ€‘risk flags. Total:', totalFlags, 'Shown:', flagsForHighlight.length);

    } catch (e) {

      console.warn('âš ï¸ Error while sorting flags by risk for original essay, falling back to all flags:', e);

      flagsForHighlight = flags;

    }

  }



  const essayLower = essay.toLowerCase();

  const flagPositions = [];



  // First, find ALL occurrences of each flag phrase (not just first one)

  flagsForHighlight.forEach((flag, index) => {

    const phrase = (flag.phrase || flag.original || '').trim();

    if (!phrase) return;



    const phraseLower = phrase.toLowerCase();

    let searchStart = 0;



    // Find ALL non-overlapping occurrences of this phrase

    while (searchStart < essay.length) {

      const position = essayLower.indexOf(phraseLower, searchStart);

      if (position === -1) break;



      // Check if this position overlaps with any existing flag

      const overlaps = flagPositions.some(fp => {

        const fpEnd = fp.position + fp.phrase.length;

        const thisEnd = position + phrase.length;

        return (position >= fp.position && position < fpEnd) ||

               (fp.position >= position && fp.position < thisEnd);

      });



      if (!overlaps) {

        flagPositions.push({

          flag: flag,

          phrase: phrase,

          phraseLower: phraseLower,

          position: position,

          originalIndex: index

        });

      }



      searchStart = position + 1;

    }

  });



  // Sort by position (order of appearance in text)

  flagPositions.sort((a, b) => a.position - b.position);



  // Track first occurrence of each unique phrase for numbering

  const firstOccurrenceMap = new Map(); // phraseLower -> first position index

  const phraseNumberMap = new Map(); // phraseLower -> assigned number

  let currentNumber = 1;



  // Assign numbers to first occurrence of each unique phrase

  flagPositions.forEach((fp, idx) => {

    if (!firstOccurrenceMap.has(fp.phraseLower)) {

      firstOccurrenceMap.set(fp.phraseLower, idx);

      phraseNumberMap.set(fp.phraseLower, currentNumber);

      currentNumber++;

    }

  });



  console.log('Flag positions found (highlighted):', flagPositions.length);

  console.log('Unique phrases (highlighted):', firstOccurrenceMap.size);



  // Build HTML with inline text and small colored badges

  let html = '';

  let lastPosition = 0;



  flagPositions.forEach((fp, idx) => {

    // Add text before this flag

    html += escapeHtml(essay.substring(lastPosition, fp.position));



    // Check if this is the first occurrence of this phrase

    const isFirstOccurrence = firstOccurrenceMap.get(fp.phraseLower) === idx;

    const flagNumber = isFirstOccurrence ? phraseNumberMap.get(fp.phraseLower) : null;



    // All flags get yellow highlight (#FFF000), duplicates get light yellow (#FFFACD)

    const highlightBg = isFirstOccurrence ? '#FFF000' : '#FFFACD';

    const circleBg = '#FFFACD'; // Light yellow for all circles



    // Build the HTML: yellow highlight + number (only for first occurrence)

    if (flagNumber !== null) {

      // First occurrence: yellow highlight + numbered circle

      html += `<span class="flag-highlight-red" style="background: ${highlightBg}; color: #0b0646;">${escapeHtml(fp.phrase)}<sup data-flag-index="${fp.originalIndex}" onclick="scrollToFlagInSummaryDropdown(${fp.originalIndex})" class="flag-number" style="background: ${circleBg}; color: #dc2626; border-radius: 50%; width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 700; margin-left: 2px; vertical-align: super; line-height: 1; flex-shrink: 0; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'" title="Click to see in dropdown">${flagNumber}</sup></span>`;

    } else {

      // Duplicate occurrence: yellow highlight only, no number

      html += `<span class="flag-highlight-red" style="background: ${highlightBg}; color: #0b0646;">${escapeHtml(fp.phrase)}</span>`;

    }



    lastPosition = fp.position + fp.phrase.length;

  });



  // Add remaining text after last flag

  html += escapeHtml(essay.substring(lastPosition));



  // Set the HTML

  originalEssayEl.innerHTML = html;

  originalEssayEl.style.lineHeight = '1.8';

  originalEssayEl.style.fontSize = '16px';



  // Add / update summary text above the original essay when there are more than 5 flags

  let summaryEl = document.getElementById('originalEssayTop5Summary');

  if (!summaryEl && originalEssayEl.parentNode) {

    summaryEl = document.createElement('p');

    summaryEl.id = 'originalEssayTop5Summary';

    summaryEl.style.margin = '0 0 8px 0';

    summaryEl.style.fontSize = '13px';

    summaryEl.style.color = '#4b5563';

    summaryEl.style.fontWeight = '500';

    summaryEl.style.textAlign = 'left';

    originalEssayEl.parentNode.insertBefore(summaryEl, originalEssayEl);

  }



  if (summaryEl) {

    if (totalFlags > 5) {

      summaryEl.textContent = `We found ${totalFlags} AI trigger words. Here are the top 5 highest risk:`;

      summaryEl.style.display = 'block';

    } else {

      summaryEl.style.display = 'none';

    }

  }



  console.log(`âœ… Original essay populated with ${flagPositions.length} flags (${firstOccurrenceMap.size} unique phrases, total flags: ${totalFlags})`);

}



// Helper function to escape HTML

function escapeHtml(text) {

  const div = document.createElement('div');

  div.textContent = text;

  return div.innerHTML;

}



function displayQuickFixResults(originalText, fixedText, flags, newScore, improvement, replacements = null, textPhraseScore = null, structuralScore = null, overallScore = null) {

  console.log('ðŸ“ displayQuickFixResults called with:', {

    originalTextLength: originalText?.length || 0,

    fixedTextLength: fixedText?.length || 0,

    flagsCount: flags?.length || 0,

      newScore, 

    improvement,

    replacementsCount: replacements?.length || 0,

    textPhraseScore,

    structuralScore,

    overallScore

  });



  // â˜…â˜…â˜… STORE ENHANCED FLAGS IN APPSTATE â˜…â˜…â˜…

  appState.quickfixTextPhraseFlags = appState.apiResponse?.categorized?.textPhraseFlags || appState.quickfixTextPhraseFlags || [];

  appState.quickfixStructuralFlags = appState.apiResponse?.categorized?.structuralFlags || appState.quickfixStructuralFlags || [];



  // Show Step 3

  showQuickFixStep(3);



  // Show email signup form for all users (QuickFix & Pro) on Step 3

  setTimeout(() => {

    const step3EmailForm = document.getElementById('quickfixStep3EmailSignupForm');

    if (step3EmailForm) {

      step3EmailForm.style.display = 'block';

    }

    // Go Pro & Chill upsell: show just above newsletter for free users only

    const isPro = appState.isProUser || (appState.proSubscription && appState.proSubscription.active);

    const step3ProBanner = document.getElementById('quickfixStep3ProBanner');

    if (step3ProBanner) {

      step3ProBanner.style.display = isPro ? 'none' : 'block';

    }

    // Orange "Get Another QuickFix" CTA: show ONLY on Hella Sus or Kinda Sus (score >= 30). Hide for Pro, Free, and QuickFix Clean (score < 30).

    const step3QuickFixUpsellBtn = document.getElementById('step3QuickFixUpsellButton');

    if (step3QuickFixUpsellBtn) {

      const isKindaOrHellaSus = (typeof newScore === 'number' && newScore >= 30);

      if (isPro || !isKindaOrHellaSus) {

        step3QuickFixUpsellBtn.style.display = 'none';

        step3QuickFixUpsellBtn.style.setProperty('display', 'none', 'important');

      } else {

        step3QuickFixUpsellBtn.style.display = 'flex';

        step3QuickFixUpsellBtn.style.setProperty('display', 'flex', 'important');

        step3QuickFixUpsellBtn.style.visibility = 'visible';

      }

    }

  }, 100);



  // Get replacements from appState if not provided

  if (!replacements && appState.quickfixReplacements) {

    replacements = appState.quickfixReplacements;

  }



  // STAGE 3: Get separate scores from appState if not provided

  if (textPhraseScore === null || textPhraseScore === undefined) {

    textPhraseScore = appState.quickfixTextPhraseScore || newScore;

  }

  if (structuralScore === null || structuralScore === undefined) {

    structuralScore = appState.quickfixStructuralScore || newScore;

  }

  if (overallScore === null || overallScore === undefined) {

    overallScore = appState.quickfixOverallScore || newScore;

  }



  // Use overallScore as the main score for display

  const displayScore = overallScore || newScore;



  // â˜…â˜…â˜… CRITICAL: Store the partially fixed new score for when user goes back to Step 2 â˜…â˜…â˜…

  // This ensures the score shown in Step 2 matches what's shown in the modal

  appState.quickfixNewScore = newScore;

  console.log('âœ… Stored quickfixNewScore in appState:', appState.quickfixNewScore, '(from newScore parameter:', newScore, ')');



  // â˜…â˜…â˜… POPULATE OVERVIEW STATS â˜…â˜…â˜…

  const overview = appState.apiResponse?.overview;

  if (overview) {

    const statsHeader = document.getElementById('quickfixStatsHeader');

    if (statsHeader) {

      statsHeader.innerHTML = `

        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; text-align: center;">

          <div style="padding: 12px; background: #f3f4f6; border-radius: 8px;">

            <div style="font-size: 24px; font-weight: 700; color: #374151;">${overview.score}%</div>

            <div style="font-size: 12px; color: #6b7280;">Current AI Score</div>

          </div>

          <div style="padding: 12px; background: #d1fae5; border-radius: 8px;">

            <div style="font-size: 24px; font-weight: 700; color: #047857;">${overview.quickStats?.expectedNewScore || `${newScore}%`}</div>

            <div style="font-size: 12px; color: #047857;">Possible Score</div>

          </div>

          <div style="padding: 12px; background: #fef3c7; border-radius: 8px;">

            <div style="font-size: 24px; font-weight: 700; color: #92400e;">${overview.quickStats?.estimatedFixTime || '2 minutes'}</div>

            <div style="font-size: 12px; color: #92400e;">Time to Fix</div>

          </div>

        </div>

      `;

    }

  }



  // â˜…â˜…â˜… POPULATE EDITABLE TEXT BOX â˜…â˜…â˜…

  const newEditableBox = document.getElementById('quickfixFixedTextArea');

  if (newEditableBox && fixedText) {

    newEditableBox.innerHTML = '';

    newEditableBox.textContent = fixedText;

    console.log('âœ… Populated editable box with fixed text');

  }



  // CRITICAL: Also populate the essay display divs (fixedEssay, originalEssay, diffEssay)

  const fixedEssayEl = document.getElementById('fixedEssay');

  const originalEssayEl = document.getElementById('originalEssay');

  const diffEssayEl = document.getElementById('diffEssay');

  const textareaValue = document.getElementById('quickfixFixedTextArea')?.value || fixedText || '';



  if (fixedEssayEl && textareaValue) {

    fixedEssayEl.textContent = textareaValue;

    fixedEssayEl.style.setProperty('display', 'block', 'important');

    fixedEssayEl.style.setProperty('visibility', 'visible', 'important');

    fixedEssayEl.style.setProperty('opacity', '1', 'important');

    console.log('âœ… fixedEssay populated, length:', fixedEssayEl.textContent.length);

  } else {

    console.warn('âš ï¸ fixedEssay element not found or no text to populate');

  }



  if (originalEssayEl) {

    // Use clean flag numbering for the original essay

    populateOriginalWithCleanFlags(originalText || '', flags || []);

    originalEssayEl.style.setProperty('display', 'none', 'important'); // Hidden by default

  } else {

    console.warn('âš ï¸ originalEssay element not found');

  }



  // Build diff view if we have flags

  if (diffEssayEl && textareaValue && flags && flags.length > 0) {

    console.log('ðŸ” Building diff view with:', {

      textareaValueLength: textareaValue.length,

      flagsCount: flags.length,

      firstFlag: flags[0]

    });

    buildDiffView({

      fixedEssay: textareaValue,

      flags: flags

    });

    diffEssayEl.style.setProperty('display', 'none', 'important'); // Hidden by default

    console.log('âœ… diffEssay populated with highlighting');

  } else {

    console.warn('âš ï¸ Cannot build diff view:', {

      hasDiffEl: !!diffEssayEl,

      hasTextareaValue: !!textareaValue,

      textareaValueLength: textareaValue ? textareaValue.length : 0,

      hasFlags: !!flags,

      flagsCount: flags ? flags.length : 0

    });

  }



  // Build changes summary

  console.log('ðŸ” Building changes summary with flags:', flags.length);

  buildChangesSummary({

    flags: flags,

    stillFlagged: []

  });



  // â˜…â˜…â˜… POPULATE TWO-SECTION FIX DISPLAY â˜…â˜…â˜…

  // Only show text phrases - hide structural section to avoid confusion

  populateFixSections(appState.quickfixTextPhraseFlags, []);



  // Hide structural section entirely - it's confusing users

  const structuralSection = document.getElementById('structuralSection');

  if (structuralSection) {

    structuralSection.style.display = 'none';

  }



  // â˜…â˜…â˜… SHOW QUICK ACTION BUTTONS â˜…â˜…â˜…

  const quickActions = appState.apiResponse?.quickActions || [];

  if (quickActions.length > 0) {

    console.log('âœ… Quick actions available:', quickActions);

  }



  // Add error handling for missing data (improvement can be 0, so check !== undefined)

  // Don't return early - try to use fallbacks instead

  if (!originalText || originalText.trim() === '') {

    console.error('âŒ originalText is missing or empty!');

    originalText = appState.quickfixOriginalText || 'No original text available';

  }



  if (!fixedText || fixedText.trim() === '') {

    console.error('âŒ fixedText is missing or empty!');

    fixedText = appState.quickfixFixedText || originalText || 'No fixed text available';

  }



  if (!flags || flags.length === 0) {

    console.warn('âš ï¸ flags is missing or empty, using empty array');

    flags = appState.quickfixFlags || [];

  }



    // Calculate improvement if missing

    if (improvement === undefined && newScore !== undefined && appState.quickfixOriginalScore !== undefined) {

      improvement = appState.quickfixOriginalScore - newScore;

      console.log('Calculated improvement:', improvement);

  } else if (improvement === undefined) {

    improvement = 0;

    console.warn('âš ï¸ improvement is undefined, defaulting to 0');

  }



  if (newScore === undefined) {

    console.error('âŒ newScore is undefined!');

    newScore = appState.quickfixNewScore || 0;

  }



  // Get original scores for display (needed for score boxes)

  const originalScore = appState.quickfixOriginalScore || (displayScore + improvement);



  // CRITICAL FIX: The original separate scores should be the original overall score

  // (since /analyze doesn't return separate scores, we use the overall as baseline)

  // The NEW separate scores come from the QuickFix response

  let originalTextPhraseScore = appState.quickfixOriginalTextPhraseScore;

  let originalStructuralScore = appState.quickfixOriginalStructuralScore;



  // If original separate scores weren't stored (they should be from initial scan),

  // use the original overall score as the baseline

  if (originalTextPhraseScore === undefined || originalTextPhraseScore === null || originalTextPhraseScore === 0) {

    originalTextPhraseScore = originalScore;

    console.log('âš ï¸ Original text phrase score not found, using original overall score:', originalScore);

  }



  if (originalStructuralScore === undefined || originalStructuralScore === null || originalStructuralScore === 0) {

    originalStructuralScore = originalScore;

    console.log('âš ï¸ Original structural score not found, using original overall score:', originalScore);

  }



  // Ensure new scores are valid (should be from QuickFix response)

  if (!textPhraseScore || textPhraseScore === undefined || textPhraseScore === null) {

    textPhraseScore = overallScore || displayScore;

    console.log('âš ï¸ New text phrase score not found, using overall score:', textPhraseScore);

  }



  if (!structuralScore || structuralScore === undefined || structuralScore === null) {

    structuralScore = overallScore || displayScore;

    console.log('âš ï¸ New structural score not found, using overall score:', structuralScore);

  }



  console.log('ðŸ“Š Score display:', {

    originalScore,

    originalTextPhraseScore,

    originalStructuralScore,

    textPhraseScore,

    structuralScore,

    overallScore,

    displayScore,

    improvement

  });



  // Move score boxes to the new container above "Before QuickFix"

  const scoreBoxesContainer = document.getElementById('quickfixScoreBoxes');

  if (scoreBoxesContainer) {

      scoreBoxesContainer.innerHTML = `

      <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">

        <div id="textPhrasesCard" 

             style="background: #f8f9fa; border-radius: 8px; padding: 12px; border-left: 4px solid #00a8e8; cursor: pointer; transition: all 0.2s;" 

             onmouseover="this.style.background='#e0f2fe'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.1)'; showTooltip(event, 'Text Phrases', 'AI-trigger words and phrases found in your essay text. Lower is better - under 30% is safe.')" 

             onmouseout="this.style.background='#f8f9fa'; this.style.transform='translateY(0)'; this.style.boxShadow='none'; hideTooltip()">

          <div style="font-size: 12px; font-weight: 600; color: #6b7280; margin-bottom: 6px;">Text Phrases</div>

          <div style="font-size: 24px; font-weight: 700; color: #00a8e8;">

            ${originalTextPhraseScore}% â†’ ${textPhraseScore}%

            ${textPhraseScore <= 30 ? '<span style="font-size: 16px; color: #2ecc71;">âœ…</span>' : '<span style="font-size: 16px; color: #f59e0b;">âš ï¸</span>'}

          </div>

          <div style="font-size: 11px; color: #9ca3af; margin-top: 4px;">${textPhraseScore <= 30 ? 'Fixed!' : 'Needs attention'}</div>

        </div>



        <div id="structureCard" 

             style="background: #f8f9fa; border-radius: 8px; padding: 12px; border-left: 4px solid #f59e0b; cursor: pointer; transition: all 0.2s;" 

             onmouseover="this.style.background='#fef3c7'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.1)'; showTooltip(event, 'Writing Patterns', 'How your essay is structured (sentence length, contractions, repetition). AI detectors look for patterns that seem too perfect or formulaic. Lower is better.')" 

             onmouseout="this.style.background='#f8f9fa'; this.style.transform='translateY(0)'; this.style.boxShadow='none'; hideTooltip()">

          <div style="font-size: 12px; font-weight: 600; color: #6b7280; margin-bottom: 6px;">Writing Patterns</div>

          <div style="font-size: 24px; font-weight: 700; color: #f59e0b;">

            ${originalStructuralScore}% â†’ ${structuralScore}%

            ${structuralScore <= 30 ? '<span style="font-size: 16px; color: #2ecc71;">âœ…</span>' : '<span style="font-size: 16px; color: #f59e0b;">âš ï¸</span>'}

          </div>

          <div style="font-size: 11px; color: #9ca3af; margin-top: 4px;">${structuralScore <= 30 ? 'Fixed!' : 'Needs attention'}</div>

        </div>



        <div id="overallRiskCard" 

             style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border-radius: 8px; padding: 12px; border: 2px solid #00a8e8; cursor: pointer; transition: all 0.2s;" 

             onmouseover="this.style.background='linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.1)'; showTooltip(event, 'Overall Risk', 'Combined score from both text phrases and structure. This is your final AI detection risk score. Under 30% is safe to turn in.')" 

             onmouseout="this.style.background='linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%)'; this.style.transform='translateY(0)'; this.style.boxShadow='none'; hideTooltip()">

          <div style="font-size: 12px; font-weight: 600; color: #6b7280; margin-bottom: 6px;">Overall Risk</div>

          <div style="font-size: 28px; font-weight: 700; color: #0c4a6e;">

            ${overallScore}%

          </div>

          <div style="font-size: 11px; color: #6b7280; margin-top: 4px;">Combined score</div>

        </div>

      </div>

    `;



    // Add tooltip element to score boxes container (positioned relative)

    scoreBoxesContainer.style.position = 'relative';

    if (!document.getElementById('scoreTooltip')) {

      const tooltip = document.createElement('div');

      tooltip.id = 'scoreTooltip';

      tooltip.style.cssText = 'position: absolute; background: #1f2937; color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; line-height: 1.5; max-width: 280px; z-index: 10000; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none;';

      tooltip.innerHTML = '<div style="font-weight: 700; margin-bottom: 4px;"></div><div style="opacity: 0.9;"></div>';

      scoreBoxesContainer.appendChild(tooltip);

    }

  }



  // STAGE 3: Hide Copy button for Hella Sus (score >= 70)

  const copyButton = document.getElementById('quickfixCopyButton');

  if (copyButton) {

    if (overallScore >= 70) {

      copyButton.style.display = 'none';

    } else {

      copyButton.style.display = 'block';

    }

  }



  // Update before/after score labels

  const beforeScoreEl = document.getElementById('beforeQuickFixScore');

  const afterScoreEl = document.getElementById('afterQuickFixScore');

  const isPro = appState.isProUser || false;



  if (beforeScoreEl) {

    if (isPro) {

      beforeScoreEl.textContent = `Before Pro Fix - ${originalScore}%`;

    } else {

      beforeScoreEl.textContent = `Before QuickFix - ${originalScore}%`;

    }

  }

  if (afterScoreEl) {

    if (isPro) {

      afterScoreEl.textContent = `After Pro Fix - ${newScore}%`;

    } else {

      afterScoreEl.textContent = `After QuickFix - ${newScore}%`;

    }

  }



  // Update score display

  const newScoreEl = document.getElementById('quickfixNewScore');

  if (newScoreEl) {

    newScoreEl.textContent = newScore + '%';

  }



  // Animate progress bar using the same system as other progress bars

  // NOTE: Progress bar removed - elements may not exist

  const progressFill = document.getElementById('quickfixNewProgressFill');

  const progressBar = document.getElementById('quickfixNewProgressBar');

  const newIndicator = document.getElementById('quickfixNewProgressIndicator');



  // Skip if progress bar was removed

  if (!progressFill || !progressBar) {

    console.log('âš ï¸ Progress bar elements not found (may have been removed)');

  }



  // Animate the top progress bar immediately (don't wait for displayStep3Results)

  // This ensures it always animates even if displayStep3Results is skipped

  // Get score from API response first, then fallback to appState, then function params

  const scoreToAnimate = appState.apiResponse?.textRisk || 

                         appState.apiResponse?.afterScore || 

                         appState.quickfixOverallScore || 

                         appState.quickfixNewScore || 

                         overallScore || 

                         newScore || 

                         0;

  console.log('ðŸŽ¯ Animating top progress bar from displayQuickFixResults with score:', scoreToAnimate, {

    apiTextRisk: appState.apiResponse?.textRisk,

    apiAfterScore: appState.apiResponse?.afterScore,

    quickfixOverallScore: appState.quickfixOverallScore,

    quickfixNewScore: appState.quickfixNewScore,

    overallScore: overallScore,

    newScore: newScore

  });

  setTimeout(() => {

    animateTopProgressBar(scoreToAnimate);

  }, 100);



  // DON'T update progress indicator here - it will be updated in displayStep3Results after animation

  // updateProgressIndicator(newScore, 'quickfixNewProgressIndicator');



  // Update new score label with dynamic color

  updateScoreLabelColor(newScore, 'quickfixNewScoreLabel');



  // ============================================

  // UPDATE STEP 3 BANNER CARDS (Hella Sus, Kinda Sus, Clean)

  // ============================================

  // Use overallScore or newScore as the afterScore for card display

  const afterScore = overallScore || newScore || scoreToAnimate;



  // Update score display above progress bar

  const step3ScoreDisplay = document.getElementById('quickfixStep3ScoreDisplay');

  const step3ScorePhrase = document.getElementById('quickfixStep3ScorePhrase');

  if (step3ScoreDisplay) {

    step3ScoreDisplay.textContent = `${afterScore}%`;

    if (afterScore <= 30) {

      step3ScoreDisplay.style.color = '#10b981';

    } else if (afterScore <= 70) {

      step3ScoreDisplay.style.color = '#f59e0b';

    } else {

      step3ScoreDisplay.style.color = '#ef4444';

    }

  }

  if (step3ScorePhrase) {

    if (afterScore >= 70) {

      step3ScorePhrase.textContent = 'Major Sus';

    } else if (afterScore >= 30) {

      step3ScorePhrase.textContent = 'Mid Sus';

    } else {

      step3ScorePhrase.textContent = 'Low Sus';

    }

  }



  console.log('ðŸ” ABOUT TO UPDATE CARDS IN displayQuickFixResults - afterScore:', afterScore);



  // Get Step 3 card elements

  const quickfixHellaSusCard = document.getElementById('quickfixStep3HellaSusCard');

  const quickfixKindaSusCard = document.getElementById('quickfixStep3KindaSusCard');

  const quickfixYoureGoodCard = document.getElementById('quickfixStep3YoureGoodCard');

  const quickfixHellaSusCTA = document.getElementById('quickfixStep3HellaSusCTA');

  const quickfixKindaSusCTA = document.getElementById('quickfixStep3KindaSusCTA');

  const quickfixCleanNoSusCTA = document.getElementById('quickfixStep3CleanNoSusCTA');



  console.log('ðŸ” Step 3 Card Elements Check:', {

    hellaSusCard: !!quickfixHellaSusCard,

    kindaSusCard: !!quickfixKindaSusCard,

    youreGoodCard: !!quickfixYoureGoodCard,

    hellaSusCTA: !!quickfixHellaSusCTA,

    kindaSusCTA: !!quickfixKindaSusCTA,

    cleanNoSusCTA: !!quickfixCleanNoSusCTA

  });



  // Hide all cards and CTAs first

  if (quickfixHellaSusCard) quickfixHellaSusCard.style.display = 'none';

  if (quickfixKindaSusCard) quickfixKindaSusCard.style.display = 'none';

  if (quickfixYoureGoodCard) quickfixYoureGoodCard.style.display = 'none';

  if (quickfixHellaSusCTA) quickfixHellaSusCTA.style.display = 'none';

  if (quickfixKindaSusCTA) quickfixKindaSusCTA.style.display = 'none';

  if (quickfixCleanNoSusCTA) quickfixCleanNoSusCTA.style.display = 'none';

  // Hide all Step 3 rotating phrase containers and alerts

  const step3CleanRotating = document.getElementById('quickfixStep3CleanNoSusRotatingPhrases');

  const step3HellaRotating = document.getElementById('quickfixStep3HellaSusRotatingPhrases');

  const step3KindaRotating = document.getElementById('quickfixStep3KindaSusRotatingPhrases');

  if (step3CleanRotating) step3CleanRotating.style.display = 'none';

  if (step3HellaRotating) step3HellaRotating.style.display = 'none';

  if (step3KindaRotating) step3KindaRotating.style.display = 'none';



  // Stop Kinda Sus message rotation when hiding (both Step 2 and Step 3)

  if (window.kindaSusStep2RotationInterval) {

    clearInterval(window.kindaSusStep2RotationInterval);

    window.kindaSusStep2RotationInterval = null;

  }

  if (window.kindaSusStep3RotationInterval) {

    clearInterval(window.kindaSusStep3RotationInterval);

    window.kindaSusStep3RotationInterval = null;

  }



  // Show appropriate card and CTA based on afterScore

  if (afterScore >= 70) {

    // Hella Sus (70-100%)

    console.log('ðŸš¨ Setting Step 3 to HELLA SUS mode - Score:', afterScore);

    if (quickfixHellaSusCard) {

      quickfixHellaSusCard.style.display = 'block';

      quickfixHellaSusCard.style.visibility = 'visible';

      quickfixHellaSusCard.style.opacity = '1';

      console.log('âœ… Showing Hella Sus card');

    }

    // CRITICAL: Only show Hella Sus CTA for non-Pro users

    const isPro = appState.isProUser || false;

    if (quickfixHellaSusCTA) {

      if (isPro) {

        // Hide for Pro users

        quickfixHellaSusCTA.style.display = 'none';

        quickfixHellaSusCTA.style.setProperty('display', 'none', 'important');

        quickfixHellaSusCTA.style.visibility = 'hidden';

        quickfixHellaSusCTA.style.opacity = '0';

        console.log('âœ… Hidden Hella Sus CTA for Pro user');

      } else {

        // Show for QuickFix users only

        quickfixHellaSusCTA.style.display = 'block';

        quickfixHellaSusCTA.style.visibility = 'visible';

        quickfixHellaSusCTA.style.opacity = '1';

        console.log('âœ… Showing Hella Sus CTA for QuickFix user');

      }

    }

    if (step3HellaRotating) {

      step3HellaRotating.style.display = 'block';

    }

  } else if (afterScore >= 30) {

    // Kinda Sus (30-69%)

    console.log('âš ï¸ Setting Step 3 to KINDA SUS mode - Score:', afterScore);

    if (quickfixKindaSusCard) {

      quickfixKindaSusCard.style.display = 'block';

      quickfixKindaSusCard.style.visibility = 'visible';

      quickfixKindaSusCard.style.opacity = '1';

      console.log('âœ… Showing Kinda Sus card');

    }

    // REMOVED: First duplicate phrase box - always hide it

    if (quickfixKindaSusCTA) {

      quickfixKindaSusCTA.style.display = 'none';

      quickfixKindaSusCTA.style.visibility = 'hidden';

      quickfixKindaSusCTA.style.opacity = '0';

      console.log('âœ… Hidden first duplicate phrase box for Kinda Sus');

    }

    if (step3KindaRotating) {

      step3KindaRotating.style.display = 'block';

    }

  } else {

    // Low Sus (0-29%)

    console.log('âœ… Setting Step 3 to CLEAN mode - Score:', afterScore);

    if (quickfixYoureGoodCard) {

      quickfixYoureGoodCard.style.display = 'block';

      quickfixYoureGoodCard.style.visibility = 'visible';

      quickfixYoureGoodCard.style.opacity = '1';

      console.log('âœ… Showing Clean card');

    }

    if (quickfixCleanNoSusCTA) {

      quickfixCleanNoSusCTA.style.display = 'block';

      quickfixCleanNoSusCTA.style.visibility = 'visible';

      quickfixCleanNoSusCTA.style.opacity = '1';

      console.log('âœ… Showing Clean CTA');

    }

    if (step3CleanRotating) {

      step3CleanRotating.style.display = 'block';

    }

    setTimeout(function() { showCanvasConfetti(); }, 300);

    // Hide "We found X AI trigger words. Here are the top 5 highest risk:" for Clean

    const top5SummaryEl = document.getElementById('originalEssayTop5Summary');

    if (top5SummaryEl) top5SummaryEl.style.display = 'none';

  }



  // Update copy button risk percentage and text

  const copyRiskPercentEl = document.getElementById('copyRiskPercent');

  const copyButtonEl = document.getElementById('copyFixedEssayBtn');

  if (copyButtonEl) {

    // For Clean No Sus (score < 30), change button text to "Copy Fixed Essay"

    if (afterScore < 30) {

      copyButtonEl.innerHTML = `âœ… Copy Fixed Essay`;

      console.log('âœ… Updated copy button to "Copy Fixed Essay" for Clean No Sus');

    } else {

      // For Kinda Sus and Hella Sus, show "Copy Anyway" with risk percentage

  if (copyRiskPercentEl) {

    copyRiskPercentEl.textContent = Math.round(afterScore);

    console.log('âœ… Updated copy button risk percentage to:', afterScore);

  }

      if (copyRiskPercentEl) {

    copyButtonEl.innerHTML = `âš ï¸ Copy Anyway (<span id="copyRiskPercent">${Math.round(afterScore)}</span>% risk)`;

      }

    }

  }



  // Show/hide blue info box for Kinda Sus and Hella Sus only (scores >= 30). Warning box (Score still X%) removed per user request.

  const infoBox = document.getElementById('quickfixInfoBox');



  // Note: isPro is already declared earlier in this function (line 14740)



  if (afterScore >= 70) {

    // Show blue info box for Hella Sus - ONLY for QuickFix, NOT for Pro

    if (infoBox && !isPro) {

      console.log('ðŸŽ¯ Showing Hella Sus info box');

      infoBox.style.display = 'block';

      // Set dynamic content for Major Sus

      const titleEl = document.getElementById('quickfixTitleText');

      if (titleEl) titleEl.textContent = 'Score still high?';

      // Trigger confetti animation

      setTimeout(function() { triggerConfetti(); }, 300);

    } else if (infoBox && isPro) {

      console.log('ðŸš« Hiding Hella Sus info box for Pro user');

      infoBox.style.display = 'none'; // Hide for Pro users

    }

    console.log('âœ… Showing info box for Hella Sus score:', afterScore, 'isPro:', isPro);

  } else if (afterScore >= 30) {

    // Show blue info box for Kinda Sus - ONLY for QuickFix, NOT for Pro

    if (infoBox && !isPro) {

      console.log('ðŸŽ¯ Showing Kinda Sus info box');

      infoBox.style.display = 'block';

      // Set dynamic content for Mid Sus

      const titleEl = document.getElementById('quickfixTitleText');

      if (titleEl) titleEl.textContent = 'Score still mid?';

      // Trigger confetti animation

      setTimeout(function() { triggerConfetti(); }, 300);

    } else if (infoBox && isPro) {

      console.log('ðŸš« Hiding Kinda Sus info box for Pro user');

      infoBox.style.display = 'none'; // Hide for Pro users

    }

    console.log('âœ… Showing info box for Kinda Sus score:', afterScore, 'isPro:', isPro);

  } else {

    // Hide blue info box for Clean/No Sus

    if (infoBox) {

      console.log('ðŸš« Hiding info box for clean score:', afterScore);

      infoBox.style.display = 'none';

    }

    console.log('âœ… Hiding info box for clean score:', afterScore);

  }



  // Score Drop Guaranteed (scoreDropCTA): PRO ONLY â€” NEVER show on QuickFix (only when isPro)

  const scoreDropCTAEl = document.getElementById('scoreDropCTA');

  if (scoreDropCTAEl) {

    const showScoreDrop = afterScore >= 30 && isPro;

    scoreDropCTAEl.style.display = showScoreDrop ? 'block' : 'none';

  }

  // Bonus Rescan card (bonusRescanCTA): QuickFix Step 3 Hella Sus / Kinda Sus ONLY, first time; hide on return after use

  const bonusRescanCTAEl = document.getElementById('bonusRescanCTA');

  if (bonusRescanCTAEl) {

    if (afterScore >= 30 && !isPro && !appState.quickfixBonusRescanUsed) {

      bonusRescanCTAEl.style.display = 'block';

    } else {

      bonusRescanCTAEl.style.display = 'none';

    }

  }



  // Also update score boxes colors (call displayScores if it exists)

  // Use overallScore or newScore for textRisk

  const textRiskForDisplay = overallScore || newScore || afterScore;

  const falseFlowRisk = appState.apiResponse?.falseFlowRisk || 'Low';



  // Call displayScores to update the top score boxes

  if (typeof displayScores === 'function') {

    displayScores({

      textRisk: textRiskForDisplay,

      flagFlowScore: falseFlowRisk,

      flags: flags || [],

      originalEssay: originalText || '',

      fixedEssay: fixedText || ''

    });

  }



  // Update progress score display (above blue box)

  const progressScoreEl = document.getElementById('quickfixProgressScore');

  const progressLabelEl = document.getElementById('quickfixProgressText');

  const progressEmojiEl = document.getElementById('quickfixProgressEmoji');



  if (progressScoreEl) {

    progressScoreEl.textContent = `${newScore}%`;

    // Update color based on score

    if (newScore <= 30) {

      progressScoreEl.style.color = '#2ecc71'; // Green

    } else if (newScore <= 70) {

      progressScoreEl.style.color = '#f59e0b'; // Yellow

    } else {

      progressScoreEl.style.color = '#dc2626'; // Red

    }

  }



  if (progressLabelEl && progressEmojiEl) {

    if (newScore <= 30) {

      progressLabelEl.textContent = 'Low Sus';

      progressEmojiEl.textContent = 'âœ…';

      progressLabelEl.style.color = '#2ecc71';

    } else if (newScore <= 70) {

      progressLabelEl.textContent = 'Mid Sus';

      progressEmojiEl.textContent = 'âš ï¸';

      progressLabelEl.style.color = '#f59e0b';

    } else {

      progressLabelEl.textContent = 'Major Sus';

      progressEmojiEl.textContent = 'ðŸš¨';

      progressLabelEl.style.color = '#dc2626';

    }

  }



  // Update dynamic message based on score

  const dynamicMessage = document.getElementById('dynamicMessage');

  const dynamicMessageBanner = document.getElementById('dynamicMessageBanner');

  if (dynamicMessage) {

    if (newScore <= 30) {

      dynamicMessage.textContent = 'No cap, this one\'s clean. Go send it.';

      if (dynamicMessageBanner) {

        dynamicMessageBanner.style.background = '#2ecc71';

        dynamicMessageBanner.style.borderLeftColor = '#059669';

        dynamicMessage.style.color = '#ffffff';

      }

    } else if (newScore <= 70) {

      dynamicMessage.textContent = `ðŸ¤” ${newScore}% Mid Sus â€” might work, might not`;

      if (dynamicMessageBanner) {

        dynamicMessageBanner.style.background = '#fbbf24';

        dynamicMessageBanner.style.borderLeftColor = '#f59e0b';

        dynamicMessage.style.color = '#ffffff';

      }

    } else {

      dynamicMessage.textContent = `Fam, this is way too sus for your prof.`;

      if (dynamicMessageBanner) {

        dynamicMessageBanner.style.background = '#dc2626';

        dynamicMessageBanner.style.borderLeftColor = '#991b1b';

        dynamicMessage.style.color = '#ffffff';

      }

    }

  }



  // CTA rendering is handled by updateResultsMessaging â†’ updateQuickFixBottomCTA.

  // Avoid overriding that richer layout here to keep the Pro upsell and clean CTAs visible.



  const improvementPercentEl = document.getElementById('improvementPercent');

  if (improvementPercentEl) {

    improvementPercentEl.textContent = improvement + '%';

  }



  // Update resultsMessage text if it exists - different message for Clean vs others

  const resultsMessageEl = document.getElementById('resultsMessage');

  if (resultsMessageEl && improvementPercentEl) {

    if (newScore <= 30) {

      // Success message for Clean pages

      resultsMessageEl.innerHTML = `That's a solid <strong>${improvement}%</strong> glow-up! âœ¨<br>Your essay is looking clean and ready to turn in.`;

    } else {

      // Warning message for Kinda Sus/Hella Sus pages

      resultsMessageEl.innerHTML = `Detectors would still roast this ðŸ˜¬ â€” only a <strong>${improvement}%</strong> glow-up so far.<br>Keep fixing to drop your score even lower.`;

    }

  }



  // Update dynamic messaging

  updateResultsMessaging(displayScore, improvement, overallScore);



  // Update "Your Scan Results" subtitle - dynamic for Pro users

  const scanResultsSubtitle = document.getElementById('quickfixScanResultsSubtitle');

  // isPro already declared above at line 7682

  if (scanResultsSubtitle) {

    // Increase font size for subtitle

    scanResultsSubtitle.style.fontSize = '18px';

    // For clean scores (<= 30), show rotating celebratory messages

    if (newScore <= 30) {

      // Reset index and start with first message

      currentCleanMessageIndex = 0;

      scanResultsSubtitle.textContent = cleanResultMessages[0];

      scanResultsSubtitle.style.transition = 'opacity 0.3s ease';

      scanResultsSubtitle.style.opacity = '1';

      // Start rotating messages

      startRotatingCleanMessages();

    } else if (isPro && flags && flags.length > 0) {

      scanResultsSubtitle.textContent = `ðŸš© Pro found ${flags.length} AI-trigger word${flags.length === 1 ? '' : 's'} in your essay`;

    } else {

      scanResultsSubtitle.textContent = "Here's your new score after fixing those flags";

    }

  }



  // Save Pro scan to history (localStorage) - only if function exists

  if (isPro && typeof saveProScanToHistory === 'function') {

    console.log('ðŸ’¾ Attempting to save Pro scan to history...', {

      isPro: isPro,

      originalTextLength: originalText ? originalText.length : 0,

      fixedTextLength: fixedText ? fixedText.length : 0,

      flagsCount: flags ? flags.length : 0

    });

    try {

      const originalScore = appState.proOriginalScore || appState.quickfixOriginalScore || newScore;

      saveProScanToHistory(originalText, originalScore, flags, fixedText, newScore);

      console.log('âœ… Pro scan save attempt completed');

    } catch (err) {

      console.error('âŒ Could not save Pro scan to history:', err);

    }

  } else {

    console.log('âš ï¸ Not saving Pro scan - isPro:', isPro, 'function exists:', typeof saveProScanToHistory === 'function');

  }



  // Update header wrapper border colors based on score (QuickFix summary page)

  const headerWrapper = document.getElementById('quickfixStep3HeaderWrapper');

  if (headerWrapper) {

    if (newScore <= 30) {

      headerWrapper.style.borderLeftColor = '#2ecc71';

      headerWrapper.style.borderRightColor = '#2ecc71';

    } else if (newScore <= 70) {

      headerWrapper.style.borderLeftColor = '#f5a623';

      headerWrapper.style.borderRightColor = '#f5a623';

    } else {

      headerWrapper.style.borderLeftColor = '#dc2626';

      headerWrapper.style.borderRightColor = '#dc2626';

    }

  }



  // Update resultsMessage color based on score (QuickFix summary page only) - set after updateResultsMessaging

  const resultsMessageAfter = document.getElementById('resultsMessage');

  if (resultsMessageAfter) {

    if (newScore <= 30) {

      resultsMessageAfter.style.color = '#2ecc71'; // Green

    } else if (newScore <= 70) {

      resultsMessageAfter.style.color = '#fbbf24'; // Yellow

    } else {

      resultsMessageAfter.style.color = '#dc2626'; // Red

    }

  }



  // Check if score is too high and show upsell popup

  // BUT: Don't show misleading message if user selected ALL available fixes

  const totalFlags = appState.quickfixFlags ? appState.quickfixFlags.length : 0;

  const selectedFlagsCount = flags ? flags.length : 0;

  const selectedAllFixes = totalFlags > 0 && selectedFlagsCount === totalFlags;



  if (newScore > 30) {

    setTimeout(() => {

      // If user selected all fixes but score is still high, show different message

      // Use appState.quickfixNewScore to ensure consistency with Step 2 display

      const scoreToShow = (appState.quickfixNewScore != null && appState.quickfixNewScore !== '') 

        ? appState.quickfixNewScore 

        : newScore;

      console.log('ðŸ“Š Showing modal with score:', scoreToShow, '(appState.quickfixNewScore:', appState.quickfixNewScore, 'newScore param:', newScore, ')');

      showScoreUpsellPopup(scoreToShow, selectedAllFixes);

    }, 1500); // Show after 1.5 seconds

  }



  // STAGE 2: Remove badge generation - show clean text only

  // Original text can keep highlights for comparison, but fixed text will be clean

  let originalWithHighlights = originalText;



  // Add numbered flags to original text only (for comparison)

  if (flags.length > 0) {

    // Sort flags by position for consistent numbering

    const sortedFlags = flags.map(flag => {

      const position = originalText.toLowerCase().indexOf(flag.phrase.toLowerCase());

      return { ...flag, position };

    }).filter(flag => flag.position !== -1).sort((a, b) => a.position - b.position);



    sortedFlags.forEach((flag, index) => {

      // Highlight original flags (red numbers) - keep for comparison

      // Add ID for scroll-to functionality

      const flagId = `flag-${index + 1}`;

      const originalRegex = new RegExp(flag.phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

      // Use same highlight style for all flags (no severity distinction)

      const highlightClass = 'flag-highlight-red';

      const flagNum = index + 1;

      // Check if this flag was replaced (will be mapped later)

      originalWithHighlights = originalWithHighlights.replace(originalRegex, 

        `<span id="${flagId}" class="${highlightClass}" style="scroll-margin-top: 100px; cursor: pointer;" onclick="scrollToChangedItemFromFlag(${flagNum})" title="${flag.phrase} - Click to see what this was changed to">${flag.phrase}<span class="flag-number">${flagNum}</span></span>`

      );

    });

  }



  // Fixed text stays CLEAN - no badges, no highlights

  const fixedTextClean = fixedText;



  // Function to highlight changed words in fixed text

  function highlightChangedWords(text, originalText, replacements) {

    const escapeHtml = (text) => {

      const div = document.createElement('div');

      div.textContent = text;

      return div.innerHTML;

    };



    if (!replacements || replacements.length === 0) {

      return escapeHtml(text);

    }



    let highlightedText = escapeHtml(text);



    // Sort replacements by position (longest first to avoid partial matches)

    const sortedReplacements = [...replacements].sort((a, b) => {

      const aLen = a.to ? a.to.length : 0;

      const bLen = b.to ? b.to.length : 0;

      return bLen - aLen;

    });



    // Highlight each replacement in the fixed text (GREEN for QuickFix changes)

    sortedReplacements.forEach((rep, index) => {

      if (rep.to && rep.from) {

        // Escape special regex characters

        const escapedTo = rep.to.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        // Use word boundaries for better matching

        const regex = new RegExp(`\\b${escapedTo}\\b`, 'gi');

        highlightedText = highlightedText.replace(regex, (match) => {

          // Check if already wrapped (avoid double-wrapping)

          if (match.includes('<span')) return match;

          // Add data attributes for interaction and use GREEN for QuickFix

          return `<span class="quickfix-highlight" data-quickfix-index="${index}" data-original="${escapeHtml(rep.from)}" data-replacement="${escapeHtml(rep.to)}" style="background-color: #d1fae5; border-bottom: 2px solid #10b981; padding: 2px 0; font-weight: 600; cursor: pointer; position: relative;" title="QuickFix changed from '${escapeHtml(rep.from)}' to '${escapeHtml(rep.to)}' - Click to interact">${match}</span>`;

        });

      }

    });



    return highlightedText;

  }



  // CRITICAL: Set before/after text comparison - ensure elements exist

  const comparisonOriginalEl = document.getElementById('comparisonOriginal');

  const comparisonFixedEl = document.getElementById('comparisonFixed');



  // Check if elements exist (old Step 3 structure - these don't exist anymore)

  if (!comparisonOriginalEl || !comparisonFixedEl) {

    // Elements don't exist in new Step 3 structure - skip silently

    return;

  }



  // Ensure we have text to display (fallback to original if highlighting failed)

  if (!originalWithHighlights || originalWithHighlights.trim() === '') {

    console.warn('âš ï¸ originalWithHighlights is empty, using originalText');

    originalWithHighlights = originalText || 'No original text available';

  }



  if (!fixedTextClean || fixedTextClean.trim() === '') {

    console.warn('âš ï¸ fixedTextClean is empty, using fixedText');

    fixedTextClean = fixedText || originalText || 'No fixed text available';

  }



  // Escape HTML to prevent XSS, but allow our highlight spans

  const escapeHtml = (text) => {

    const div = document.createElement('div');

    div.textContent = text;

    return div.innerHTML;

  };



  // Set original text

  if (comparisonOriginalEl) {

    // Use innerHTML to preserve highlight spans, but ensure text is visible

    comparisonOriginalEl.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; padding: 10px; min-height: 50px; color: #333; font-size: 16px; line-height: 1.6;">${originalWithHighlights}</div>`;

    console.log('âœ… Set original text in comparison box, length:', originalWithHighlights.length);

    console.log('âœ… Original text preview:', originalWithHighlights.substring(0, 100));

    console.log('   Element innerHTML length:', comparisonOriginalEl.innerHTML.length);

    // Force visibility with !important

    comparisonOriginalEl.style.setProperty('display', 'block', 'important');

    comparisonOriginalEl.style.setProperty('visibility', 'visible', 'important');

    comparisonOriginalEl.style.setProperty('opacity', '1', 'important');

    comparisonOriginalEl.style.setProperty('min-height', '50px', 'important');

    // Also ensure parent is visible

    const parentBox = comparisonOriginalEl.closest('.comparison-box');

    if (parentBox) {

      parentBox.style.setProperty('display', 'block', 'important');

      parentBox.style.setProperty('visibility', 'visible', 'important');

    }

  } else {

    console.error('âŒ comparisonOriginal element not found! Searching for alternatives...');

    // Try alternative selectors

    const alt = document.querySelector('#comparisonOriginal, .comparison-box .box-content, [id*="comparisonOriginal"]');

    if (alt) {

      console.log('âœ… Found alternative element:', alt.id || alt.className);

      alt.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; padding: 10px; min-height: 50px; color: #333; font-size: 16px; line-height: 1.6;">${originalWithHighlights}</div>`;

    }

  }



  // FIXED: Populate the EXISTING #quickfixFixedTextArea element (not inside comparison box)

  const quickfixFixedTextAreaEl = document.getElementById('quickfixFixedTextArea');

  if (quickfixFixedTextAreaEl) {

    console.log('âœ… Found existing quickfixFixedTextArea element, populating with fixed text...');

    // Set the fixed text as plain text (contenteditable will handle editing)

    quickfixFixedTextAreaEl.textContent = fixedTextClean || fixedText || '';



    // Store original text for comparison

    const originalFixedText = fixedTextClean || fixedText || '';

    window.quickfixOriginalFixedText = originalFixedText;

    window.quickfixBaselineText = originalFixedText;

    window.quickfixReplacements = replacements || [];

    window.quickfixManualEdits = 0;

    window.quickfixEditingActive = false;



    console.log('âœ… Populated quickfixFixedTextArea with text, length:', (fixedTextClean || fixedText || '').length);

        } else {

    console.error('âŒ quickfixFixedTextArea element not found!');

  }



  // Also populate comparison boxes for the optional comparison view (when toggleComparison is clicked)

  if (comparisonOriginalEl) {

    // Set original text with highlights in comparison box

    comparisonOriginalEl.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; padding: 10px; min-height: 50px; color: #333; font-size: 16px; line-height: 1.6;">${originalWithHighlights}</div>`;

  }



  if (comparisonFixedEl) {

    // Set fixed text in comparison box (for comparison view only) - use plain text, not highlighted

    comparisonFixedEl.innerHTML = `<div style="white-space: pre-wrap; word-wrap: break-word; padding: 10px; min-height: 50px; color: #333; font-size: 16px; line-height: 1.6;">${fixedTextClean || fixedText || ''}</div>`;

  }



  // Verify quickfixFixedTextArea is populated (fallback check)

  setTimeout(() => {

    const editableDiv = document.getElementById('quickfixFixedTextArea');

    if (!editableDiv || !editableDiv.textContent || editableDiv.textContent.trim() === '') {

      console.error('âŒ quickfixFixedTextArea is still empty after 100ms! Forcing fallback...');

      if (editableDiv) {

        editableDiv.textContent = fixedTextClean || fixedText || '';

      }

    }

  }, 100);



  // NOTE: populateFixSections is already called at line 10003 above

  // No need to call it again here



  // VERIFY STEP 3 IS STILL VISIBLE after setting content

  const step3 = document.getElementById('quickfixStep3');

  if (step3) {

    const isVisible = step3.classList.contains('active') && 

                     window.getComputedStyle(step3).display !== 'none';

    if (!isVisible) {

      console.warn('âš ï¸ Step 3 became hidden! Forcing it back visible...');

      step3.classList.add('active');

      step3.style.setProperty('display', 'block', 'important');

      step3.style.setProperty('opacity', '1', 'important');

      step3.style.setProperty('visibility', 'visible', 'important');

      step3LockUntil = Date.now() + 10000; // Extend lock to 10 seconds

    }

    console.log('âœ… Step 3 visibility verified:', isVisible);

  }



  console.log('âœ… displayQuickFixResults completed successfully');



  // CRITICAL: Always call displayStep3Results() to populate the essay display divs

  // Convert the old function parameters to the new data structure

  const step3Data = {

    textRisk: overallScore || newScore,

    falseFlowRisk: appState.apiResponse?.falseFlowRisk || 'Low',

    beforeScore: appState.quickfixOriginalScore || (newScore + improvement),

    afterScore: overallScore || newScore,

    overallStatus: (overallScore || newScore) <= 30 ? 'Clean â€” Ready to Turn In' : (overallScore || newScore) <= 70 ? 'Low Risk' : 'Medium Risk',

    statusEmoji: (overallScore || newScore) <= 30 ? 'âœ…' : (overallScore || newScore) <= 70 ? 'âš ï¸' : 'ðŸš¨',

    fixedEssay: fixedText, // This is the key - pass the fixed text!

    originalEssay: originalText, // Pass the original text!

    flags: flags || [], // Pass the flags array

    stillFlagged: [] // Can be populated if needed

  };



  // Merge with apiResponse if it exists (may have additional data)

  if (appState.apiResponse) {

    Object.assign(step3Data, appState.apiResponse);

    // Override with function parameters if they're more complete

    if (fixedText && fixedText.length > (appState.apiResponse.fixedEssay || '').length) {

      step3Data.fixedEssay = fixedText;

    }

    if (originalText && originalText.length > (appState.apiResponse.originalEssay || '').length) {

      step3Data.originalEssay = originalText;

    }

  }



  console.log('ðŸ”„ Calling displayStep3Results with data:', {

    fixedEssayLength: step3Data.fixedEssay ? step3Data.fixedEssay.length : 0,

    originalEssayLength: step3Data.originalEssay ? step3Data.originalEssay.length : 0,

    flagsCount: step3Data.flags ? step3Data.flags.length : 0

  });



  // Check if elements are already populated (from displayQuickFixResults above)

  const existingFixedEssay = document.getElementById('fixedEssay')?.textContent || '';

  const existingOriginalEssay = document.getElementById('originalEssay')?.textContent || '';



  console.log('Existing content check:', {

    fixedEssayLength: existingFixedEssay.length,

    originalEssayLength: existingOriginalEssay.length

  });



  // Only call displayStep3Results() if elements are NOT already populated

  // displayQuickFixResults() already populated them above, so we don't need to overwrite

  if (existingFixedEssay.length < 50 && existingOriginalEssay.length < 50) {

    console.log('âš ï¸ Elements not populated, calling displayStep3Results()');

    displayStep3Results(step3Data);

  } else {

    console.log('âœ… Elements already populated by displayQuickFixResults(), skipping displayStep3Results()');

    // Still call buildChangesSummary to update the summary section

    buildChangesSummary(step3Data);

    // DIRECT UPDATE: Ensure flow risk message is updated immediately

    if (step3Data && step3Data.stillFlagged !== undefined) {

      setTimeout(() => {

        const flowRiskMsgEl = ensureFlagFlowRiskMessage();

        if (flowRiskMsgEl) {

          const count = step3Data.stillFlagged.length;

          let msg = '';

          if (count === 0) {

            msg = "No flow issues here â€” you're good âœ¨";

          } else if (count >= 1 && count <= 2) {

            msg = "These could trip up detectors, so you'll need to fix them yourself";

          } else if (count >= 3 && count <= 5) {

            msg = "Detectors will clock these flow issues but you'll need to fix them yourself. Don't stress. Take it one at a time â€” fix one, rescan, repeat";

          } else if (count >= 6) {

            msg = "Detectors will clock these flow issues but you'll need to fix them yourself. Don't stress. Take it one at a time â€” fix one, rescan, repeat";

          }

          flowRiskMsgEl.textContent = msg;

          flowRiskMsgEl.style.display = 'block';

          flowRiskMsgEl.style.visibility = 'visible';

          console.log('âœ… DIRECT UPDATE: Flow risk message set to:', msg, 'for count:', count);

        }

      }, 200);

    }

    // CRITICAL: Animate top progress bar even when skipping displayStep3Results

    // Get score from multiple sources to ensure we have the right value

    const afterScore = appState.apiResponse?.textRisk || 

                      appState.apiResponse?.afterScore || 

                      appState.quickfixOverallScore || 

                      appState.quickfixNewScore || 

                      step3Data.afterScore || 

                      step3Data.textRisk || 

                      0;

    console.log('ðŸŽ¯ Animating top progress bar from else block with score:', afterScore);

    animateTopProgressBar(afterScore);

  }

}



// NEW STEP 3 FUNCTIONS (False Flag Flowâ„¢ Architecture)



// Highlight changed words in essay (strikethrough old, green highlight new)

function highlightChangedWords(essay, flags) {

  console.log('ðŸŽ¨ highlightChangedWords called');

  console.log('Essay length:', essay ? essay.length : 0);

  console.log('Flags:', flags);



  if (!essay) {

    console.log('âŒ No essay provided');

    return essay || '';

  }



  if (!flags || !Array.isArray(flags) || flags.length === 0) {

    console.log('âš ï¸ No flags provided, returning essay as-is');

    // Escape HTML to prevent XSS, but show plain text

    return essay.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

  }



  console.log(`âœ… Processing ${flags.length} flags`);



  let highlightedEssay = essay;

  let replacementCount = 0;



  // Sort by length (longest first) to avoid nested replacements

  const sortedFlags = [...flags].sort((a, b) => {

    const aLen = a.original ? a.original.length : 0;

    const bLen = b.original ? b.original.length : 0;

    return bLen - aLen;

  });



  sortedFlags.forEach((flag, index) => {

    const original = flag.original;

    const replacement = flag.replacement;



    if (!original || !replacement) {

      console.log(`âš ï¸ Flag ${index} missing original or replacement:`, flag);

      return;

    }



    // Escape special regex characters

    const escapedOriginal = original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');



    // Check if original word exists in essay

    const regex = new RegExp(`\\b${escapedOriginal}\\b`, 'g');

    const matches = highlightedEssay.match(regex);



    if (matches && matches.length > 0) {

      console.log(`âœ… Found "${original}" ${matches.length} time(s), replacing with highlighted version`);



      // Create the highlighted replacement

      const highlighted = `<span style="text-decoration: line-through; color: #9ca3af;">${escapeHtml(original)}</span><span style="background: #d1fae5; color: #10b981; padding: 2px 4px; border-radius: 2px; font-weight: 600;">${escapeHtml(replacement)}</span>`;



      // Replace all instances (case-sensitive, word boundaries)

      highlightedEssay = highlightedEssay.replace(regex, highlighted);

      replacementCount += matches.length;

    } else {

      // Original not found - try finding the replacement word instead

      const replacementRegex = new RegExp(`\\b${escapeRegex(replacement)}\\b`, 'g');

      const replacementMatches = highlightedEssay.match(replacementRegex);



      if (replacementMatches && replacementMatches.length > 0) {

        console.log(`âš ï¸ Original "${original}" not found, but replacement "${replacement}" found ${replacementMatches.length} time(s) - highlighting replacement`);

        // Just highlight the replacement word (can't show original since it's not in the text)

        const highlightedReplacement = `<span style="background: #d1fae5; color: #10b981; padding: 2px 4px; border-radius: 2px; font-weight: 600;">${escapeHtml(replacement)}</span>`;

        highlightedEssay = highlightedEssay.replace(replacementRegex, highlightedReplacement);

        replacementCount += replacementMatches.length;

      } else {

        console.log(`âš ï¸ Neither "${original}" nor "${replacement}" found in essay`);

      }

    }

  });



  console.log(`âœ… highlightChangedWords complete: ${replacementCount} replacements made`);

  console.log('Final HTML length:', highlightedEssay.length);



  return highlightedEssay;

}



// Helper function to escape HTML

function escapeHtml(text) {

  const div = document.createElement('div');

  div.textContent = text;

  return div.innerHTML;

}



// Helper function to escape regex special characters

function escapeRegex(text) {

  return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

}



// Tooltip functions for score box icons and buttons

// Show tooltip on hover (works for both side and above positioning)

function showDesktopTooltip(iconElement, event) {

  const tooltip = iconElement.querySelector('.tooltip-text-desktop');

  if (!tooltip) {

    console.warn('âš ï¸ Tooltip not found in element:', iconElement);

    return;

  }



  // Update icon opacity (if it's an icon, not a button)

  if (iconElement.style.opacity !== undefined) {

  iconElement.style.opacity = '1';

  }



  // Show tooltip

  tooltip.style.visibility = 'visible';

  tooltip.style.opacity = '1';



  // Check if tooltip is positioned above (has bottom style) or to the side

  const computedStyle = window.getComputedStyle(tooltip);

  const hasBottom = tooltip.style.bottom || computedStyle.bottom !== 'auto';

  const hasTransform = tooltip.style.transform || computedStyle.transform;

  const isAboveTooltip = hasBottom || (hasTransform && hasTransform.indexOf('translateY(calc(-100%') !== -1);



  if (isAboveTooltip) {

    // Tooltip is above button - keep centered positioning (already set in HTML)

    // No need to adjust positioning

    return;

  }



  // Tooltip is to the side - check if it would go off-screen

  const iconRect = iconElement.getBoundingClientRect();

  const tooltipRect = tooltip.getBoundingClientRect();

  const viewportWidth = window.innerWidth;



  // If tooltip would go off right edge, position it to the left instead

  if (iconRect.right + tooltipRect.width + 8 > viewportWidth - 20) {

    tooltip.style.left = 'auto';

    tooltip.style.right = 'calc(100% + 8px)';

    tooltip.style.transform = 'translateY(calc(-50% - 3px))';

    // Flip arrow to point right

    const arrows = tooltip.querySelectorAll('span[style*="border-right"]');

    arrows.forEach(arrow => {

      arrow.style.right = 'auto';

      arrow.style.left = '100%';

      arrow.style.borderRight = 'none';

      arrow.style.borderLeft = '6px solid #ffffff';

    });

    const borderArrows = tooltip.querySelectorAll('span[style*="border-right"][style*="border-right: 6px solid #e5e7eb"]');

    borderArrows.forEach(arrow => {

      arrow.style.right = 'auto';

      arrow.style.left = '100%';

      arrow.style.borderRight = 'none';

      arrow.style.borderLeft = '6px solid #e5e7eb';

      arrow.style.transform = 'translateY(calc(-50% - 3px)) translateX(1px)';

    });

  } else {

    // Reset to default (right side)

    tooltip.style.left = 'calc(100% + 8px)';

    tooltip.style.right = 'auto';

    tooltip.style.transform = 'translateY(calc(-50% - 3px))';

    // Reset arrows

    const arrows = tooltip.querySelectorAll('span[style*="border"]');

    arrows.forEach(arrow => {

      if (arrow.style.borderRight) {

        arrow.style.right = '100%';

        arrow.style.left = 'auto';

        // Update arrow transform if it has one

        if (arrow.style.transform && arrow.style.transform.includes('translateY(-50%)')) {

          arrow.style.transform = arrow.style.transform.replace('translateY(-50%)', 'translateY(calc(-50% - 3px))');

        }

      }

    });

  }

}



// Hide tooltip on mouse leave

function hideDesktopTooltip(iconElement) {

  const tooltip = iconElement.querySelector('.tooltip-text-desktop');

  if (!tooltip) return;



  // Only update opacity if it's an icon (not a button)

  if (iconElement.style.opacity !== undefined && iconElement.classList.contains('tooltip-icon')) {

  iconElement.style.opacity = '0.65';

  }



  tooltip.style.visibility = 'hidden';

  tooltip.style.opacity = '0';

}



// Simple tooltip functions for buttons (positioned above)

function showButtonTooltip(buttonElement) {

  const tooltip = buttonElement.querySelector('.button-tooltip');

  if (!tooltip) {

    console.warn('âš ï¸ Button tooltip not found');

    return;

  }

  tooltip.style.visibility = 'visible';

  tooltip.style.opacity = '1';

}



function hideButtonTooltip(buttonElement) {

  const tooltip = buttonElement.querySelector('.button-tooltip');

  if (!tooltip) return;

  tooltip.style.visibility = 'hidden';

  tooltip.style.opacity = '0';

}



// Build Changes Summary (Dynamic) - Collapsible Dropdowns

// Helper function to ensure flagFlowRiskMessage element exists

function ensureFlagFlowRiskMessage() {

  let element = document.getElementById('flagFlowRiskMessage');



  if (!element) {

    console.log('ðŸ› ï¸ Creating missing flagFlowRiskMessage element...');



    // Find where it should go - in flagFlowScoreCard, inside the header div with the h3

    const flowCard = document.getElementById('flagFlowScoreCard');

    if (flowCard) {

      // Look for the header div that contains the h3 title

      const headerDiv = flowCard.querySelector('div[style*="flex-direction: column"]');

      if (headerDiv) {

        // Create the element with proper styling

        element = document.createElement('p');

        element.id = 'flagFlowRiskMessage';

        element.style.margin = '12px 0 0 0';

        element.style.fontSize = '14px';

        element.style.color = '#6b7280';

        element.style.textAlign = 'center';

        element.style.lineHeight = '1.5';

        element.style.padding = '8px';

        element.style.display = 'block';

        element.style.visibility = 'visible';

        element.style.minHeight = '20px';

        element.style.width = '100%';

        element.textContent = "No flow issues here â€” you're good âœ¨";



        // Insert it after the h3 title (append to header div - it will naturally go after h3)

        headerDiv.appendChild(element);

        console.log('âœ… Created flagFlowRiskMessage element inside flagFlowScoreCard');

      } else {

        console.error('âŒ Could not find header div in flagFlowScoreCard');

      }

    } else {

      console.error('âŒ flagFlowScoreCard not found - cannot create flagFlowRiskMessage');

    }

  }



  return element;

}



function buildChangesSummary(data) {

  console.log('=== buildChangesSummary called ===');



  const flags = data.flags || [];

  const stillFlagged = data.stillFlagged || [];



  console.log('flags length:', flags.length);

  console.log('stillFlagged length:', stillFlagged.length);



  // === POPULATE FIXED DROPDOWN ===

  const fixedListEl = document.getElementById('fixedListDropdown');

  const fixedCountEl = document.getElementById('fixedCountDropdown');



  if (fixedListEl && fixedCountEl) {

    fixedCountEl.textContent = flags.length;



    if (flags.length === 0) {

      fixedListEl.innerHTML = '<li style="color: #6b7280;">No changes made</li>';

    } else {

      fixedListEl.innerHTML = flags.map((flag, index) => {

        const original = flag.original || flag.phrase || 'unknown';

        const replacement = flag.replacement || flag.suggestedFix || 'N/A';

        const flagNumber = index + 1;



        // Use light green background with dark green numbering

        const circleBg = '#C8E6C9'; // Light green background

        const circleTextColor = '#059669'; // Dark green text



        return `

        <li id="flag-item-${index}" data-flag-index="${index}" style="margin-bottom: 8px; padding: 8px; background: white; border-radius: 4px; border-left: 3px solid #10b981; display: flex; align-items: center; gap: 8px;">

          <sup onclick="scrollToFlagInSummaryDropdown(${index})" style="background: ${circleBg}; color: ${circleTextColor}; border-radius: 50%; width: 20px; height: 20px; display: inline-flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 700; flex-shrink: 0; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'" title="Click to see in essay">${flagNumber}</sup>

          <span style="flex: 1;">

            <strong>${escapeHtml(original)}</strong> 

            <span style="color: #6b7280;">â†’</span> 

            <strong style="color: #10b981;">${escapeHtml(replacement)}</strong>

          </span>

        </li>

      `;

      }).join('');

    }

    console.log('âœ… Fixed list populated');

  }



  // === POPULATE STILL FLAGGED DROPDOWN ===

  const flaggedListEl = document.getElementById('flaggedListDropdown');

  const flaggedCountEl = document.getElementById('flaggedCountDropdown');

  const guidanceEl = document.getElementById('patternStructureGuidance');



  // === ENSURE FLOW RISK MESSAGE ELEMENT EXISTS (create if missing) ===

  const flowRiskMessageEl = ensureFlagFlowRiskMessage();



  if (flowRiskMessageEl) {

    const flowIssueCount = stillFlagged.length;

    let message = '';



    if (flowIssueCount === 0) {

      message = "No flow issues here â€” you're good âœ¨";

    } else if (flowIssueCount >= 1 && flowIssueCount <= 2) {

      message = "These could trip up detectors, so you'll need to fix them yourself";

    } else if (flowIssueCount >= 3 && flowIssueCount <= 5) {

      message = "Detectors will clock these flow issues but you'll need to fix them yourself. Don't stress. Take it one at a time â€” fix one, rescan, repeat";

    } else if (flowIssueCount >= 6) {

      message = "Detectors will clock these flow issues but you'll need to fix them yourself. Don't stress. Take it one at a time â€” fix one, rescan, repeat";

    }



    flowRiskMessageEl.textContent = message;

    flowRiskMessageEl.style.display = 'block';

    flowRiskMessageEl.style.visibility = 'visible';

    console.log('âœ… Updated flow risk message for count:', flowIssueCount, 'Message:', message);

  } else {

    // Element doesn't exist and couldn't be created - try to create it with retry

    console.warn('âš ï¸ flagFlowRiskMessage element NOT FOUND! Will try to create it...');

    setTimeout(() => {

      const retryEl = ensureFlagFlowRiskMessage();

      if (retryEl) {

        const flowIssueCount = stillFlagged.length;

        let message = '';

        if (flowIssueCount === 0) {

          message = "No flow issues here â€” you're good âœ¨";

        } else if (flowIssueCount >= 1 && flowIssueCount <= 2) {

          message = "These could trip up detectors, so you'll need to fix them yourself";

        } else if (flowIssueCount >= 3 && flowIssueCount <= 5) {

          message = "Detectors will clock these flow issues but you'll need to fix them yourself. Don't stress. Take it one at a time â€” fix one, rescan, repeat";

        } else if (flowIssueCount >= 6) {

          message = "Detectors will clock these flow issues but you'll need to fix them yourself. Don't stress. Take it one at a time â€” fix one, rescan, repeat";

        }

        retryEl.textContent = message;

        retryEl.style.display = 'block';

        retryEl.style.visibility = 'visible';

        console.log('âœ… Retry: Created and updated flow risk message for count:', flowIssueCount);

      } else {

        console.error('âŒ Could not create flagFlowRiskMessage element even after retry');

      }

    }, 300);

  }



  if (flaggedListEl) {

    if (flaggedCountEl) {

    flaggedCountEl.textContent = stillFlagged.length;

    }



    if (stillFlagged.length === 0) {

      flaggedListEl.innerHTML = '<li style="color: #6b7280;">No issues found</li>';

    } else {

      flaggedListEl.innerHTML = stillFlagged.map(item => `

        <li style="margin-bottom: 8px; padding: 8px; background: white; border-radius: 4px; border-left: 3px solid #f59e0b;">

          <strong>"${escapeHtml(item.phrase || item.original || 'unknown')}"</strong>

          <div style="font-size: 12px; color: #6b7280; margin-top: 4px;">${escapeHtml(item.reason || 'Consider rephrasing')}</div>

        </li>

      `).join('');

    }

    console.log('âœ… Flagged list populated');

  }



  // === SHOW/HIDE GUIDANCE SECTION ===

  // Show guidance if there are pattern/structure issues:

  // 1. Items in stillFlagged (pattern/structure issues that couldn't be fixed), OR

  // 2. Flag flow risk is Medium or High (not Low)

  if (guidanceEl) {

    const falseFlowRisk = data.falseFlowRisk || 'Low';

    const hasPatternIssues = stillFlagged.length > 0 || (falseFlowRisk !== 'Low' && falseFlowRisk !== 'low');



    if (hasPatternIssues) {

      guidanceEl.style.display = 'block';

      console.log('âœ… Showing pattern/structure guidance (issues detected)');

    } else {

      guidanceEl.style.display = 'none';

      console.log('â„¹ï¸ Hiding pattern/structure guidance (no issues detected)');

    }

  }



  console.log('=== buildChangesSummary completed ===');

}





// Build Diff View (Side-by-side highlighting)



// Helper function to escape HTML

function escapeHtml(text) {

  if (!text) return '';

  const div = document.createElement('div');

  div.textContent = text;

  return div.innerHTML;

}



// Helper function to escape regex special characters

function escapeRegex(text) {

  if (!text) return '';

  return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

}



// Get dynamic celebratory phrase based on improvement

function getDynamicPhrase(improvePercent) {

  const phrases = [

    "No cap, it's lookin' way cleaner! ðŸŽ‰",

    "Your essay just got a glow-up ðŸŒŸ Tag prof confirmed ðŸŽ‰",

    `That's a solid ${improvePercent}% improvement! âœ¨`,

    "Way better. Your prof's gonna love this. ðŸ“š"

  ];



  return phrases[Math.floor(Math.random() * phrases.length)];

}



// Clean animation function for Step 3 progress bar

function animateStep3ProgressBar(score, scoreElement) {

  console.log('ðŸŽ¬ Animating progress bar to:', score + '%');



  // Get elements

  const fill = document.getElementById('quickfixStep3ProgressFill');

  const indicator = document.getElementById('quickfixStep3ProgressIndicator');

  const bar = document.getElementById('quickfixStep3ProgressBar');



  // If scoreElement not provided, try to find it

  const scoreEl = scoreElement || document.getElementById('quickfixOverallScoreNumber');



  if (!fill || !indicator || !bar) {

    console.error('âŒ Progress bar elements not found!', {

      fill: !!fill,

      indicator: !!indicator,

      bar: !!bar

    });

    return;

  }



  // Clamp score between 0-100

  const finalScore = Math.max(0, Math.min(100, score));



  // Set initial state

  fill.style.width = '0%';

  fill.style.transition = 'none'; // Remove CSS transition - we'll animate with JS



  // Set background color dynamically based on score

  if (finalScore <= 29) {

    fill.style.background = '#10b981'; // Green only

  } else if (finalScore <= 69) {

    fill.style.background = `linear-gradient(to right, #10b981 0%, #10b981 29%, #fbbf24 30%, #fbbf24 ${finalScore}%)`;

  } else {

    fill.style.background = `linear-gradient(to right, #10b981 0%, #10b981 29%, #fbbf24 30%, #fbbf24 69%, #ef4444 70%, #ef4444 ${finalScore}%)`;

  }



  fill.style.position = 'absolute';

  fill.style.top = '0';

  fill.style.left = '0%';

  fill.style.height = '100%';

  fill.style.borderRadius = '4px';



  // Animate score number and progress bar fill together from 0 to target

  let currentScore = 0;

  const targetScore = finalScore;

  const duration = 5000; // 5 seconds (slowed down to match main animation)

  const startTime = Date.now();



  // Get new score display elements

  const step3ScoreDisplay = document.getElementById('quickfixStep3ScoreDisplay');

  const step3ScorePhrase = document.getElementById('quickfixStep3ScorePhrase');



  function animateScore() {

    const elapsed = Date.now() - startTime;

    const progress = Math.min(elapsed / duration, 1);



    // Ease-out function

    const easeOut = 1 - Math.pow(1 - progress, 3);

    currentScore = easeOut * targetScore; // Use exact value for fill, round for display

    const roundedScore = Math.round(currentScore);



    // Update percentage display (rounded) if score element exists

    if (scoreEl) {

      scoreEl.textContent = roundedScore + '%';

    }



    // Update new score display above progress bar

    if (step3ScoreDisplay) {

      step3ScoreDisplay.textContent = roundedScore + '%';

      // Update color based on current score

      if (roundedScore <= 30) {

        step3ScoreDisplay.style.color = '#10b981';

      } else if (roundedScore <= 70) {

        step3ScoreDisplay.style.color = '#f59e0b';

      } else {

        step3ScoreDisplay.style.color = '#ef4444';

      }

    }



    // Update score phrase

    if (step3ScorePhrase) {

      if (roundedScore >= 70) {

        step3ScorePhrase.textContent = 'Major Sus';

      } else if (roundedScore >= 30) {

        step3ScorePhrase.textContent = 'Mid Sus';

      } else {

        step3ScorePhrase.textContent = 'Low Sus';

      }

    }



    // Update progress bar fill width (exact same value and rate as percentage)

    fill.style.width = currentScore + '%';



    // Update indicator position

    const barWidth = bar.offsetWidth;

    const indicatorLeft = (barWidth * currentScore) / 100;

    indicator.style.left = indicatorLeft + 'px';



    if (progress < 1) {

      requestAnimationFrame(animateScore);

    } else {

      // Ensure final values match exactly

      if (scoreEl) {

        scoreEl.textContent = targetScore + '%';

      }

      fill.style.width = targetScore + '%';

      const finalIndicatorLeft = (barWidth * targetScore) / 100;

      indicator.style.left = finalIndicatorLeft + 'px';

      console.log('âœ… Progress bar animated to: ' + targetScore + '%');

    }

  }



  // Start animation

  requestAnimationFrame(animateScore);

}



// Keep old function for backwards compatibility (calls new one)

function animateTopProgressBar(score, scoreElement) {

  animateStep3ProgressBar(score, scoreElement);

}



// Display Step 3 Results with new data structure

function displayStep3Results(data) {

  console.log('ðŸŽ¯ displayStep3Results called with:', data);



  // CRITICAL DEBUG: Log what we're receiving from backend

  console.log('ðŸ“Š Backend data check:', {

    hasFixedEssay: !!data.fixedEssay,

    fixedEssayLength: data.fixedEssay ? data.fixedEssay.length : 0,

    fixedEssayPreview: data.fixedEssay ? data.fixedEssay.substring(0, 100) : 'undefined',

    hasOriginalEssay: !!data.originalEssay,

    originalEssayLength: data.originalEssay ? data.originalEssay.length : 0,

    hasFlags: !!data.flags,

    flagsCount: data.flags ? data.flags.length : 0

  });



  // Extract data with fallbacks

  // CRITICAL: Use appState.apiResponse.afterScore if available (this is the actual after-fix score)

  const afterScore = data.afterScore || appState.apiResponse?.afterScore || appState.apiResponse?.textRisk || data.textRisk || 0;

  const textRisk = data.textRisk || afterScore || 0; // Use afterScore as fallback for textRisk if needed

  const textRiskLabel = data.textRiskLabel || (textRisk <= 30 ? 'Low' : textRisk <= 70 ? 'Medium' : 'High');

  const falseFlowRisk = data.falseFlowRisk || appState.apiResponse?.falseFlowRisk || 'Low';

  const beforeScore = data.beforeScore || appState.quickfixOriginalScore || 0;



  console.log('ðŸ“Š displayStep3Results - Score values:', {

    dataAfterScore: data.afterScore,

    apiResponseAfterScore: appState.apiResponse?.afterScore,

    apiResponseTextRisk: appState.apiResponse?.textRisk,

    dataTextRisk: data.textRisk,

    finalAfterScore: afterScore,

    finalTextRisk: textRisk,

    falseFlowRisk: falseFlowRisk

  });

  const overallStatus = data.overallStatus || (afterScore <= 30 ? 'Clean â€” Ready to Turn In' : afterScore <= 70 ? 'Low Risk' : 'Medium Risk');

  const statusEmoji = data.statusEmoji || (afterScore <= 30 ? 'âœ…' : afterScore <= 70 ? 'âš ï¸' : 'ðŸš¨');



  // CRITICAL: Use appState.quickfixFixedText if data.fixedEssay is too short (likely truncated)

  let fixedEssay = data.fixedEssay || appState.quickfixFixedText || '';

  if (fixedEssay.length < 50 && appState.quickfixFixedText && appState.quickfixFixedText.length > 50) {

    console.warn('âš ï¸ data.fixedEssay is too short, using appState.quickfixFixedText instead');

    fixedEssay = appState.quickfixFixedText;

  }



  const flags = data.flags || [];



  console.log('ðŸ“ Essay lengths:', {

    dataFixedEssay: data.fixedEssay ? data.fixedEssay.length : 0,

    appStateFixedText: appState.quickfixFixedText ? appState.quickfixFixedText.length : 0,

    finalFixedEssay: fixedEssay.length,

    finalFixedEssayPreview: fixedEssay.substring(0, 100)

  });



  // Update overall score display

  const overallScoreEl = document.getElementById('quickfixOverallScoreNumber');

  const overallScoreLabelEl = document.getElementById('quickfixOverallScoreLabel');

  const overallScoreStatusEl = document.getElementById('quickfixOverallScoreText');

  const overallScoreEmojiEl = document.getElementById('quickfixOverallScoreEmoji');



  // Update new score display above progress bar

  const step3ScoreDisplay = document.getElementById('quickfixStep3ScoreDisplay');

  const step3ScorePhrase = document.getElementById('quickfixStep3ScorePhrase');



  // Determine score phrase based on afterScore

  let scorePhrase = 'Low Sus';

  let scoreColor = '#10b981';

  if (afterScore >= 70) {

    scorePhrase = 'Major Sus';

    scoreColor = '#ef4444';

  } else if (afterScore >= 30) {

    scorePhrase = 'Mid Sus';

    scoreColor = '#f59e0b';

  }



  if (step3ScoreDisplay) {

    step3ScoreDisplay.textContent = `${afterScore}%`;

    step3ScoreDisplay.style.color = scoreColor;

  }



  if (step3ScorePhrase) {

    step3ScorePhrase.textContent = scorePhrase;

    step3ScorePhrase.style.color = '#6b7280';

  }



  if (overallScoreEl) {

    overallScoreEl.textContent = `${afterScore}%`;

    // Update color based on score

    if (afterScore <= 30) {

      overallScoreEl.style.color = '#10b981';

    } else if (afterScore <= 70) {

      overallScoreEl.style.color = '#f59e0b';

    } else {

      overallScoreEl.style.color = '#ef4444';

    }

  }



  if (overallScoreStatusEl && overallScoreEmojiEl) {

    overallScoreStatusEl.textContent = overallStatus;

    overallScoreEmojiEl.textContent = statusEmoji;

    if (afterScore <= 30) {

      overallScoreStatusEl.style.color = '#10b981';

    } else if (afterScore <= 70) {

      overallScoreStatusEl.style.color = '#f59e0b';

    } else {

      overallScoreStatusEl.style.color = '#ef4444';

    }

  }



  // Update animated progress bar (like free clean sus) - FORCE ANIMATION

  // NOTE: Using Step 3 specific progress bar elements

  const progressFill = document.getElementById('quickfixStep3ProgressFill');

  const progressBar = document.getElementById('quickfixStep3ProgressBar');

  const progressIndicator = document.getElementById('quickfixStep3ProgressIndicator');

  const newScoreEl = document.getElementById('quickfixOverallScoreNumber');



  // Skip if progress bar was removed (but continue to card updates)

  if (!progressFill || !progressBar) {

    console.log('âš ï¸ Progress bar elements not found (may have been removed) - continuing to card updates');

    // Don't return - let the function continue to update cards

  }



  console.log('ðŸŽ¯ Step 3 Progress Bar Elements:', {

    progressFill: !!progressFill,

    progressBar: !!progressBar,

    progressIndicator: !!progressIndicator,

    newScoreEl: !!newScoreEl,

    afterScore: afterScore

  });



  if (progressFill && newScoreEl) {

    const clampedScore = Math.max(0, Math.min(100, Math.round(afterScore)));



    console.log('ðŸŽ¯ FORCING PROGRESS BAR ANIMATION - Score:', clampedScore);



    // CRITICAL: Clear the animatedBars Set entry so it can re-animate

    if (typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

      const key = newScoreEl.id + progressFill.id;

      animatedBars.delete(key);

      console.log('ðŸ—‘ï¸ Cleared animation lock for:', key);

    }



    // Ensure gradient is set (don't remove it!)

    // Note: animateStep3ProgressBar will set the gradient based on score

    progressFill.style.borderRadius = '5px';

    progressFill.style.position = 'absolute';

    progressFill.style.top = '0';

    progressFill.style.left = '0';

    progressFill.style.height = '100%';



    // CRITICAL: Reset width to 0 first, then wait before animating

    progressFill.style.width = '0%';



    // Force a repaint to ensure 0% is rendered

    void progressFill.offsetHeight;



    // Wait a frame to ensure DOM is ready, then animate

    requestAnimationFrame(() => {

      requestAnimationFrame(() => {

          // Animate using animateStep3ProgressBar function

          if (typeof animateStep3ProgressBar === 'function') {

            console.log('ðŸŽ¬ Calling animateStep3ProgressBar with score:', clampedScore);

            animateStep3ProgressBar(clampedScore, newScoreEl);

        } else {

          // Fallback: direct animation with transition

            console.log('âš ï¸ animateStep3ProgressBar not found, using fallback');

          progressFill.style.transition = 'width 2s ease';

          progressFill.style.width = clampedScore + '%';

            if (newScoreEl) {

          newScoreEl.textContent = clampedScore + '%';

            }

        }



        // Update progress indicator position and color AFTER animation starts

        if (progressIndicator) {

          setTimeout(() => {

              updateProgressIndicator(clampedScore, 'quickfixStep3ProgressIndicator');

          }, 200);

        }

      });

    });

  } else {

    console.error('âŒ Progress bar elements not found!', {

      progressFill: !!progressFill,

      newScoreEl: !!newScoreEl

    });

  }



  // Animate the top progress bar (quickfixStep3ProgressBar)

  animateTopProgressBar(afterScore);



  // Update dynamic phrase

  const improvePercent = Math.abs(beforeScore - afterScore);

  const dynamicPhrase = getDynamicPhrase(improvePercent);

  const dynamicPhraseEl = document.getElementById('dynamicPhrase');

  if (dynamicPhraseEl) {

    dynamicPhraseEl.textContent = dynamicPhrase;

  }



  // Call the new displayScores function to update redesigned score cards

  // CRITICAL: Use afterScore for textRisk so boxes show correct color

  displayScores({

    textRisk: afterScore, // Use afterScore, not textRisk, so boxes get correct color

    flagFlowScore: falseFlowRisk,

    flags: data.flags || appState.quickfixFlags || [],

    originalEssay: data.originalEssay || appState.quickfixOriginalText || '',

    fixedEssay: data.fixedEssay || appState.quickfixFixedText || ''

  });



  // Update final CTA title

  const finalCTATitleEl = document.getElementById('quickfixFinalCTATitle');

  if (finalCTATitleEl) {

    finalCTATitleEl.textContent = `Your False Flag Flow Risk is ${falseFlowRisk} ðŸ›¡ï¸`;

  }



  // Show appropriate QuickFix banner card based on afterScore

  // Use Step 3 specific card IDs (these are in Step 3, not Step 2)

  const quickfixHellaSusCard = document.getElementById('quickfixStep3HellaSusCard');

  const quickfixKindaSusCard = document.getElementById('quickfixStep3KindaSusCard');

  const quickfixYoureGoodCard = document.getElementById('quickfixStep3YoureGoodCard');

  const quickfixHellaSusCTA = document.getElementById('quickfixStep3HellaSusCTA');

  const quickfixKindaSusCTA = document.getElementById('quickfixStep3KindaSusCTA');

  const quickfixCleanNoSusCTA = document.getElementById('quickfixStep3CleanNoSusCTA');



  console.log('ðŸ” ABOUT TO UPDATE CARDS - afterScore:', afterScore);

  console.log('ðŸ” Step 3 Card Elements Check:', {

    hellaSusCard: !!quickfixHellaSusCard,

    kindaSusCard: !!quickfixKindaSusCard,

    youreGoodCard: !!quickfixYoureGoodCard,

    hellaSusCTA: !!quickfixHellaSusCTA,

    kindaSusCTA: !!quickfixKindaSusCTA,

    cleanNoSusCTA: !!quickfixCleanNoSusCTA

  });



  // Hide all cards and CTAs first

  if (quickfixHellaSusCard) quickfixHellaSusCard.style.display = 'none';

  if (quickfixKindaSusCard) quickfixKindaSusCard.style.display = 'none';

  if (quickfixYoureGoodCard) quickfixYoureGoodCard.style.display = 'none';

  if (quickfixHellaSusCTA) {

    quickfixHellaSusCTA.style.display = 'none';

    quickfixHellaSusCTA.style.setProperty('display', 'none', 'important');

  }

  if (quickfixKindaSusCTA) {

    quickfixKindaSusCTA.style.display = 'none';

    quickfixKindaSusCTA.style.setProperty('display', 'none', 'important');

  }

  if (quickfixCleanNoSusCTA) quickfixCleanNoSusCTA.style.display = 'none';

  // Hide all Step 3 rotating phrase containers

  const rotatingPhrases = document.getElementById('quickfixStep3CleanNoSusRotatingPhrases');

  const step3HellaRotatingPhrases = document.getElementById('quickfixStep3HellaSusRotatingPhrases');

  const step3KindaRotatingPhrases = document.getElementById('quickfixStep3KindaSusRotatingPhrases');

  if (rotatingPhrases) rotatingPhrases.style.display = 'none';

  if (step3HellaRotatingPhrases) step3HellaRotatingPhrases.style.display = 'none';

  if (step3KindaRotatingPhrases) step3KindaRotatingPhrases.style.display = 'none';



  // Hide Pro message elements initially

  const proHellaSusMessage = document.getElementById('proStep3HellaSusMessage');

  const proKindaSusMessage = document.getElementById('proStep3KindaSusMessage');

  if (proHellaSusMessage) proHellaSusMessage.style.display = 'none';

  if (proKindaSusMessage) proKindaSusMessage.style.display = 'none';



  // Hide info box initially

  const infoBox = document.getElementById('quickfixInfoBox');

  if (infoBox) {

    infoBox.style.display = 'none';

  }



  // Show appropriate card and CTA based on afterScore

  // Update status text dynamically based on afterScore

  const statusEmojiEl = document.getElementById('quickfixStatusEmoji');

  const statusMessageEl = document.getElementById('quickfixStatusMessage');

  const statusSubtextEl = document.getElementById('quickfixStatusSubtext');

  const statusTextEl = document.getElementById('quickfixStatusText');



  console.log('ðŸŽ¯ Step 3 Dynamic Update - afterScore:', afterScore, 'textRisk:', textRisk, 'falseFlowRisk:', falseFlowRisk);

  console.log('ðŸŽ¯ Status elements found:', {

    statusEmojiEl: !!statusEmojiEl,

    statusMessageEl: !!statusMessageEl,

    statusSubtextEl: !!statusSubtextEl,

    statusTextEl: !!statusTextEl

  });



  // FORCE UPDATE STATUS TEXT AND COLORS IMMEDIATELY

  if (afterScore >= 70) {

    // Hella Sus (70-100%)

    console.log('ðŸš¨ Setting Step 3 to HELLA SUS mode - Score:', afterScore);

    if (quickfixHellaSusCard) {

      quickfixHellaSusCard.style.display = 'block';

      quickfixHellaSusCard.style.visibility = 'visible';

      quickfixHellaSusCard.style.opacity = '1';

      console.log('âœ… Showing Hella Sus card - display:', quickfixHellaSusCard.style.display);

    } else {

      console.error('âŒ quickfixStep3HellaSusCard NOT FOUND in DOM!');

    }

    if (step3HellaRotatingPhrases) {

      step3HellaRotatingPhrases.style.display = 'block';

    }

    // For Pro: Hide red box completely - DO NOT SHOW IT

    // For QuickFix: Show red box with rotating messages

    if (isPro) {

      // FORCE HIDE red box for Pro (use !important to ensure it stays hidden)

      if (quickfixHellaSusCTA) {

        quickfixHellaSusCTA.style.display = 'none';

        quickfixHellaSusCTA.style.setProperty('display', 'none', 'important');

        quickfixHellaSusCTA.style.visibility = 'hidden';

        quickfixHellaSusCTA.style.opacity = '0';

        quickfixHellaSusCTA.style.height = '0';

        quickfixHellaSusCTA.style.margin = '0';

        quickfixHellaSusCTA.style.padding = '0';

        quickfixHellaSusCTA.style.overflow = 'hidden';

        quickfixHellaSusCTA.style.position = 'absolute';

        quickfixHellaSusCTA.style.left = '-9999px';

        quickfixHellaSusCTA.classList.add('pro-hidden');

        quickfixHellaSusCTA.setAttribute('data-pro', 'true');

        console.log('âœ… FORCE HIDDEN red CTA box for Pro user');

      }



      // Also ensure it stays hidden with a MutationObserver

      if (quickfixHellaSusCTA && typeof MutationObserver !== 'undefined') {

        const observer = new MutationObserver(function(mutations) {

          mutations.forEach(function(mutation) {

            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {

              const display = quickfixHellaSusCTA.style.display;

              if (display !== 'none' && display !== '') {

                quickfixHellaSusCTA.style.setProperty('display', 'none', 'important');

                console.log('ðŸ›‘ Prevented red box from showing for Pro user');

              }

            }

          });

        });

        observer.observe(quickfixHellaSusCTA, { attributes: true, attributeFilter: ['style'] });

      }



      // Create or get Pro rotating message element

      let proHellaSusMessage = document.getElementById('proStep3HellaSusMessage');

      if (!proHellaSusMessage) {

        proHellaSusMessage = document.createElement('div');

        proHellaSusMessage.id = 'proStep3HellaSusMessage';

        proHellaSusMessage.style.cssText = 'text-align: center; margin: 12px auto; max-width: 600px; padding: 12px 0;';

        // Insert after the Hella Sus card or before score boxes

        const insertAfter = quickfixHellaSusCard || document.getElementById('quickfixStep3HellaSusCard');

        if (insertAfter && insertAfter.parentNode) {

          insertAfter.parentNode.insertBefore(proHellaSusMessage, insertAfter.nextSibling);

        }

      }



      const proHellaSusText = document.createElement('p');

      proHellaSusText.id = 'proStep3HellaSusText';

      proHellaSusText.style.cssText = 'color: #0b0646; font-size: 18px; font-weight: 700; margin: 0; line-height: 1.4; transition: opacity 0.3s ease-in-out;';

      proHellaSusMessage.innerHTML = '';

      proHellaSusMessage.appendChild(proHellaSusText);

      proHellaSusMessage.style.display = 'block';



      // Rotating messages for Pro Hella Sus (navy blue)

      const proHellaSusMessages = [

        'Detectors are definitely side-eyeing this ðŸš¨ Gonna need more work to pass the vibe check',

        'Yeah... detectors are definitely side-eyeing this ðŸ˜¬ Better fix this before turning it in',

        'This is screaming AI to detectors ðŸš¨ High risk of getting flagged',

        'Too many AI markers detected âš ï¸ This needs fixing before submission',

        'Your professor would flag this in seconds â° Better safe than sus'

      ];



      // Initialize rotation

      if (!window.proHellaSusMessageIndex) {

        window.proHellaSusMessageIndex = 0;

      }



      // Set initial message

      proHellaSusText.textContent = proHellaSusMessages[window.proHellaSusMessageIndex];



      // Start rotating messages every 3 seconds

      if (window.proHellaSusRotationInterval) {

        clearInterval(window.proHellaSusRotationInterval);

      }

      window.proHellaSusRotationInterval = setInterval(() => {

        if (proHellaSusText && proHellaSusMessage.style.display !== 'none') {

          window.proHellaSusMessageIndex = (window.proHellaSusMessageIndex + 1) % proHellaSusMessages.length;

          proHellaSusText.style.opacity = '0';

          setTimeout(() => {

            proHellaSusText.textContent = proHellaSusMessages[window.proHellaSusMessageIndex];

            proHellaSusText.style.opacity = '1';

          }, 300);

        }

      }, 3000);

    } else {

      // QuickFix: Show red box with rotating messages (ONLY if NOT Pro)

      // CRITICAL: Hide for Pro users - this should NEVER show for Pro

      if (isPro) {

        if (quickfixHellaSusCTA) {

          quickfixHellaSusCTA.style.display = 'none';

          quickfixHellaSusCTA.style.setProperty('display', 'none', 'important');

          quickfixHellaSusCTA.style.visibility = 'hidden';

          quickfixHellaSusCTA.style.opacity = '0';

        }

        // Stop any rotation intervals for Pro users

        if (window.hellaSusRotationInterval) {

          clearInterval(window.hellaSusRotationInterval);

          window.hellaSusRotationInterval = null;

        }

        console.log('âœ… Hidden Hella Sus CTA for Pro user');

      } else {

        // REMOVED: First duplicate phrase box for Hella Sus - always hide it

        if (quickfixHellaSusCTA) {

          quickfixHellaSusCTA.style.display = 'none';

          quickfixHellaSusCTA.style.visibility = 'hidden';

          quickfixHellaSusCTA.style.opacity = '0';

          console.log('âœ… Hidden first duplicate phrase box for Hella Sus');

        }

        // Update CTA text dynamically with rotating messages (ONLY for non-Pro)

        // CRITICAL: Stop ALL existing rotation intervals first to prevent duplicates

        if (window.hellaSusRotationInterval) {

          clearInterval(window.hellaSusRotationInterval);

          window.hellaSusRotationInterval = null;

        }

        if (window.hellaSusTextTimeout) {

          clearTimeout(window.hellaSusTextTimeout);

          window.hellaSusTextTimeout = null;

        }



        const hellaSusCTAText = document.getElementById('quickfixStep3HellaSusCTAText');

        if (hellaSusCTAText) {

          // Rotating messages for Hella Sus

          const hellaSusMessages = [

            'Detectors are definitely side-eyeing this ðŸš¨ Gonna need more work to pass the vibe check',

            'Yeah... detectors are definitely side-eyeing this ðŸ˜¬ Better fix this before turning it in',

            'This is screaming AI to detectors ðŸš¨ High risk of getting flagged',

            'Too many AI markers detected âš ï¸ This needs fixing before submission',

            'Your professor would flag this in seconds â° Better safe than sus'

          ];



          // Reset index and clear text completely

          window.hellaSusMessageIndex = 0;



          // CRITICAL: Completely clear and set initial message - prevent any duplication

          hellaSusCTAText.innerHTML = '';

          hellaSusCTAText.textContent = hellaSusMessages[0];

          hellaSusCTAText.style.opacity = '1';

          hellaSusCTAText.style.visibility = 'visible';

          hellaSusCTAText.style.whiteSpace = 'normal';

          hellaSusCTAText.style.overflow = 'visible';



          // Start rotating messages every 3 seconds - only ONE interval

          window.hellaSusRotationInterval = setInterval(() => {

            const hellaSusCTA = document.getElementById('quickfixStep3HellaSusCTA');

            // CRITICAL: Don't rotate if CTA is hidden or if Pro user

            if (!hellaSusCTAText || !hellaSusCTA || hellaSusCTA.style.display === 'none' || appState.isProUser) {

              // Clean up if conditions not met

              if (window.hellaSusRotationInterval) {

                clearInterval(window.hellaSusRotationInterval);

                window.hellaSusRotationInterval = null;

              }

              return;

            }



            window.hellaSusMessageIndex = (window.hellaSusMessageIndex + 1) % hellaSusMessages.length;



            // Clear any existing timeout to prevent overlap

            if (window.hellaSusTextTimeout) {

              clearTimeout(window.hellaSusTextTimeout);

            }



            // Fade out

            hellaSusCTAText.style.opacity = '0';



            // After fade, update text

            window.hellaSusTextTimeout = setTimeout(() => {

              if (hellaSusCTAText && hellaSusCTA && hellaSusCTA.style.display !== 'none' && !appState.isProUser) {

                // CRITICAL: Completely clear before setting new text to prevent jumbling

                hellaSusCTAText.innerHTML = '';

                hellaSusCTAText.textContent = '';

                hellaSusCTAText.textContent = hellaSusMessages[window.hellaSusMessageIndex];

                hellaSusCTAText.style.opacity = '1';

                hellaSusCTAText.style.visibility = 'visible';

              }

            }, 300);

          }, 3000);

        }

      }

    }



    // Hide Pro message element for QuickFix

    const proHellaSusMessage = document.getElementById('proStep3HellaSusMessage');

    if (proHellaSusMessage) {

      proHellaSusMessage.style.display = 'none';

    }

    // Show info box for Hella Sus - ONLY for QuickFix, NOT for Pro

    if (infoBox && !isPro) {

      infoBox.style.display = 'block';

      // Set dynamic content for Major Sus

      const titleEl = document.getElementById('quickfixInfoTitle');

      if (titleEl) titleEl.textContent = 'Score still high?';

    } else if (infoBox && isPro) {

      infoBox.style.display = 'none'; // Hide for Pro users

    }

    if (statusEmojiEl) {

      statusEmojiEl.textContent = 'ðŸš¨';

      console.log('âœ… Updated status emoji to ðŸš¨');

    }

    if (statusMessageEl) {

      statusMessageEl.textContent = 'Major Sus â€” Needs More Work';

      console.log('âœ… Updated status message to Hella Sus');

    }

    if (statusSubtextEl) {

      statusSubtextEl.textContent = 'Detectors are definitely side-eyeing this.';

      console.log('âœ… Updated status subtext');

    }

    if (statusTextEl) {

      statusTextEl.style.color = '#ef4444'; // Red

      console.log('âœ… Updated status text color to red');

    }

    // Force update score boxes to red

    setTimeout(() => {

      const textRiskBox = document.getElementById('textRiskScoreBox');

      const flagFlowBox = document.getElementById('flagFlowScoreBox');

      if (textRiskBox) {

        textRiskBox.style.background = '#ef4444';

        console.log('âœ… FORCED Text Risk box to RED');

      }

      if (flagFlowBox) {

        flagFlowBox.style.background = '#ef4444';

        console.log('âœ… FORCED Flag Flow box to RED');

      }

    }, 100);

  } else if (afterScore >= 30) {

    // Kinda Sus (30-69%)

    console.log('âš ï¸ Setting Step 3 to KINDA SUS mode - Score:', afterScore);

    if (quickfixKindaSusCard) {

      quickfixKindaSusCard.style.display = 'block';

      quickfixKindaSusCard.style.visibility = 'visible';

      quickfixKindaSusCard.style.opacity = '1';

      console.log('âœ… Showing Kinda Sus card - display:', quickfixKindaSusCard.style.display);

    } else {

      console.error('âŒ quickfixStep3KindaSusCard NOT FOUND in DOM!');

    }

    if (step3KindaRotatingPhrases) {

      step3KindaRotatingPhrases.style.display = 'block';

    }

    // For Pro: Hide yellow box and show rotating navy blue text instead

    // For QuickFix: Show yellow box with rotating messages

    if (isPro) {

      // FORCE HIDE yellow box for Pro (use !important to ensure it stays hidden)

      if (quickfixKindaSusCTA) {

        quickfixKindaSusCTA.style.display = 'none';

        quickfixKindaSusCTA.style.setProperty('display', 'none', 'important');

        quickfixKindaSusCTA.style.visibility = 'hidden';

        quickfixKindaSusCTA.style.opacity = '0';

      }



      // Create or get Pro rotating message element

      let proKindaSusMessage = document.getElementById('proStep3KindaSusMessage');

      if (!proKindaSusMessage) {

        proKindaSusMessage = document.createElement('div');

        proKindaSusMessage.id = 'proStep3KindaSusMessage';

        proKindaSusMessage.style.cssText = 'text-align: center; margin: 12px auto; max-width: 600px; padding: 12px 0;';

        // Insert after the Kinda Sus card or before score boxes

        const insertAfter = quickfixKindaSusCard || document.getElementById('quickfixStep3KindaSusCard');

        if (insertAfter && insertAfter.parentNode) {

          insertAfter.parentNode.insertBefore(proKindaSusMessage, insertAfter.nextSibling);

        }

      }



      const proKindaSusText = document.createElement('p');

      proKindaSusText.id = 'proStep3KindaSusText';

      proKindaSusText.style.cssText = 'color: #0b0646; font-size: 18px; font-weight: 700; margin: 0; line-height: 1.4; transition: opacity 0.3s ease-in-out;';

      proKindaSusMessage.innerHTML = '';

      proKindaSusMessage.appendChild(proKindaSusText);

      proKindaSusMessage.style.display = 'block';



      // Rotating messages for Pro Kinda Sus (navy blue)

      const proKindaSusMessages = [

        'A couple lines are giving sus. Detectors might side-eye it, but we\'re getting there âš ï¸',

        'Some phrases might raise eyebrows, but you\'re on the right track âš ï¸',

        'A few spots need tweaking, but you\'re almost there âš ï¸',

        'Detectors might flag a couple things, but we can fix it âš ï¸',

        'Some wording looks a bit AI-like, but we\'re making progress âš ï¸'

      ];



      // Initialize rotation

      if (!window.proKindaSusMessageIndex) {

        window.proKindaSusMessageIndex = 0;

      }



      // Set initial message

      proKindaSusText.textContent = proKindaSusMessages[window.proKindaSusMessageIndex];



      // Start rotating messages every 3 seconds

      if (window.proKindaSusRotationInterval) {

        clearInterval(window.proKindaSusRotationInterval);

      }

      window.proKindaSusRotationInterval = setInterval(() => {

        if (proKindaSusText && proKindaSusMessage.style.display !== 'none') {

          window.proKindaSusMessageIndex = (window.proKindaSusMessageIndex + 1) % proKindaSusMessages.length;

          proKindaSusText.style.opacity = '0';

          setTimeout(() => {

            proKindaSusText.textContent = proKindaSusMessages[window.proKindaSusMessageIndex];

            proKindaSusText.style.opacity = '1';

          }, 300);

        }

      }, 3000);

    } else {

      // QuickFix: Show yellow box with rotating messages (ONLY if NOT Pro)

      // Double-check isPro to prevent yellow box from showing for Pro users

      // REMOVED: First duplicate phrase box - always hide it

      if (quickfixKindaSusCTA) {

        quickfixKindaSusCTA.style.display = 'none';

        quickfixKindaSusCTA.style.visibility = 'hidden';

        quickfixKindaSusCTA.style.opacity = '0';

        console.log('âœ… Hidden first duplicate phrase box for Kinda Sus');

      // Update CTA text dynamically with rotating messages

      const kindaSusCTAText = document.getElementById('quickfixStep3KindaSusCTAText');

      if (kindaSusCTAText) {

        const kindaSusMessages = [

          'A couple lines are giving sus. Detectors might side-eye it, but we\'re getting there',

          'Some phrases might raise eyebrows, but you\'re on the right track',

          'A few spots need tweaking, but you\'re almost there',

          'Detectors might flag a couple things, but we can fix it',

          'Some wording looks a bit AI-like, but we\'re making progress'

        ];



        // Clear any existing Step 3 rotation interval

        if (window.kindaSusStep3RotationInterval) {

          clearInterval(window.kindaSusStep3RotationInterval);

          window.kindaSusStep3RotationInterval = null;

        }



        // Initialize currentIndex on window object to persist across interval calls

        if (typeof window.kindaSusStep3CurrentIndex === 'undefined') {

          window.kindaSusStep3CurrentIndex = Math.floor(Math.random() * kindaSusMessages.length);

        }



        // Set initial message

        kindaSusCTAText.innerHTML = `<span style="font-size: 20px;">âš ï¸</span> ${kindaSusMessages[window.kindaSusStep3CurrentIndex]}`;



        // Rotate messages every 3 seconds

        window.kindaSusStep3RotationInterval = setInterval(() => {

          const ctaElement = document.getElementById('quickfixStep3KindaSusCTA');

          const textElement = document.getElementById('quickfixStep3KindaSusCTAText');

          if (ctaElement && textElement && ctaElement.style.display !== 'none') {

            window.kindaSusStep3CurrentIndex = (window.kindaSusStep3CurrentIndex + 1) % kindaSusMessages.length;

            textElement.innerHTML = `<span style="font-size: 20px;">âš ï¸</span> ${kindaSusMessages[window.kindaSusStep3CurrentIndex]}`;

          } else {

            // Stop rotation if CTA is hidden

            clearInterval(window.kindaSusStep3RotationInterval);

            window.kindaSusStep3RotationInterval = null;

          }

        }, 3000);

      }

    } else {

      console.error('âŒ quickfixStep3KindaSusCTA NOT FOUND in DOM!');

    }



      // Hide Pro message element for QuickFix

      const proKindaSusMessage = document.getElementById('proStep3KindaSusMessage');

      if (proKindaSusMessage) {

        proKindaSusMessage.style.display = 'none';

      }

    }

    // Show info box for Kinda Sus - ONLY for QuickFix, NOT for Pro

    if (infoBox && !isPro) {

      infoBox.style.display = 'block';

      // Set dynamic content for Mid Sus

      const titleEl = document.getElementById('quickfixTitleText');

      if (titleEl) titleEl.textContent = 'Score still mid?';

      // Trigger confetti animation

      setTimeout(function() { triggerConfetti(); }, 300);

    } else if (infoBox && isPro) {

      infoBox.style.display = 'none'; // Hide for Pro users

    }

    if (statusEmojiEl) {

      statusEmojiEl.textContent = 'âš ï¸';

      console.log('âœ… Updated status emoji to âš ï¸');

    }

    if (statusMessageEl) {

      statusMessageEl.textContent = 'Mid Sus â€” Getting There';

      console.log('âœ… Updated status message to Kinda Sus');

    }

    if (statusSubtextEl) {

      statusSubtextEl.textContent = 'A couple lines are giving sus. Detectors might side-eye it.';

      console.log('âœ… Updated status subtext');

    }

    if (statusTextEl) {

      statusTextEl.style.color = '#f59e0b'; // Amber

      console.log('âœ… Updated status text color to amber');

    }

    // Force update score boxes to amber

    setTimeout(() => {

      const textRiskBox = document.getElementById('textRiskScoreBox');

      const flagFlowBox = document.getElementById('flagFlowScoreBox');

      if (textRiskBox) {

        textRiskBox.style.background = '#f59e0b';

        console.log('âœ… FORCED Text Risk box to AMBER');

      }

      if (flagFlowBox) {

        flagFlowBox.style.background = '#f59e0b';

        console.log('âœ… FORCED Flag Flow box to AMBER');

      }

    }, 100);

  } else {

    // Low Sus (0-29%)

    console.log('âœ… Setting Step 3 to CLEAN mode - Score:', afterScore);

    if (quickfixYoureGoodCard) {

      quickfixYoureGoodCard.style.display = 'block';

      quickfixYoureGoodCard.style.visibility = 'visible';

      quickfixYoureGoodCard.style.opacity = '1';

      console.log('âœ… Showing Clean card - display:', quickfixYoureGoodCard.style.display);

    } else {

      console.error('âŒ quickfixStep3YoureGoodCard NOT FOUND in DOM!');

    }

    if (quickfixCleanNoSusCTA) {

      quickfixCleanNoSusCTA.style.display = 'block';

      quickfixCleanNoSusCTA.style.visibility = 'visible';

      quickfixCleanNoSusCTA.style.opacity = '1';

      console.log('âœ… Showing Clean CTA - display:', quickfixCleanNoSusCTA.style.display);

      // Update CTA text dynamically

      const cleanNoSusCTAText = document.getElementById('quickfixStep3CleanNoSusCTAText');

      if (cleanNoSusCTAText) {

        cleanNoSusCTAText.innerHTML = 'Vibe check passed âœ…<br>No cap, it\'s lookin\' way cleaner! ðŸŽ‰';

      }

    } else {

      console.error('âŒ quickfixStep3CleanNoSusCTA NOT FOUND in DOM!');

    }

    // CRITICAL: On Clean No Sus Pro Step 3, REMOVE the "Try Different Words" CTA (user requested)

    if (isPro) {

      const step3EditFixesBtn = document.getElementById('step3EditFixes');

      if (step3EditFixesBtn) {

        step3EditFixesBtn.style.display = 'none';

        step3EditFixesBtn.style.setProperty('display', 'none', 'important');

        step3EditFixesBtn.style.visibility = 'hidden';

        step3EditFixesBtn.style.setProperty('visibility', 'hidden', 'important');

        console.log('âœ… Hidden "Try Different Words" CTA on Clean No Sus Pro Step 3');

      }

    }

    // Show rotating phrases for Clean No Sus Step 3

    const rotatingPhrases = document.getElementById('quickfixStep3CleanNoSusRotatingPhrases');

    if (rotatingPhrases) {

      rotatingPhrases.style.display = 'block';

      // Start rotating messages if function exists

      if (typeof setupRotatingMessages === 'function') {

        setupRotatingMessages(afterScore);

      }

    }

    setTimeout(function() { showCanvasConfetti(); }, 300);

    // Hide "We found X AI trigger words. Here are the top 5 highest risk:" for Clean

    const top5SummaryEl = document.getElementById('originalEssayTop5Summary');

    if (top5SummaryEl) top5SummaryEl.style.display = 'none';

    if (statusEmojiEl) {

      statusEmojiEl.textContent = 'âœ…';

      console.log('âœ… Updated status emoji to âœ…');

    }

    if (statusMessageEl) {

      statusMessageEl.textContent = 'Vibe check passed âœ…';

      console.log('âœ… Updated status message to Clean');

    }

    if (statusSubtextEl) {

      statusSubtextEl.textContent = 'No cap, it\'s lookin\' way cleaner! ðŸŽ‰';

      console.log('âœ… Updated status subtext');

    }

    if (statusTextEl) {

      statusTextEl.style.color = '#10b981'; // Green

      console.log('âœ… Updated status text color to green');

    }

    // Force update score boxes to green

    setTimeout(() => {

      const textRiskBox = document.getElementById('textRiskScoreBox');

      const flagFlowBox = document.getElementById('flagFlowScoreBox');

      if (textRiskBox) {

        textRiskBox.style.background = '#10b981';

        console.log('âœ… FORCED Text Risk box to GREEN');

      }

      if (flagFlowBox) {

        flagFlowBox.style.background = '#10b981';

        console.log('âœ… FORCED Flag Flow box to GREEN');

      }

    }, 100);



    // Hide info box and message for clean scores

    if (infoBox) {

      infoBox.style.display = 'none';

    }

  }



  // Build changes summary

  buildChangesSummary(data);



  // Populate essay views

  // CRITICAL: Use appState.quickfixOriginalText if data.originalEssay is too short

  let originalEssay = data.originalEssay || appState.quickfixOriginalText || fixedEssay;

  if (originalEssay.length < 50 && appState.quickfixOriginalText && appState.quickfixOriginalText.length > 50) {

    console.warn('âš ï¸ data.originalEssay is too short, using appState.quickfixOriginalText instead');

    originalEssay = appState.quickfixOriginalText;

  }

  const fixedEssayEl = document.getElementById('fixedEssay');

  const originalEssayEl = document.getElementById('originalEssay');

  const diffEssayEl = document.getElementById('diffEssay');

  const textAreaEl = document.getElementById('quickfixFixedTextArea');

  const textForCopyEl = document.getElementById('quickfixFixedTextForCopy');



  // DEBUG: Log element finding

  console.log('ðŸ” Finding essay display elements...');

  console.log('fixedEssayEl found?', !!fixedEssayEl);

  console.log('originalEssayEl found?', !!originalEssayEl);

  console.log('diffEssayEl found?', !!diffEssayEl);

  console.log('textAreaEl found?', !!textAreaEl);

  console.log('fixedEssay length:', fixedEssay ? fixedEssay.length : 'EMPTY');

  console.log('originalEssay length:', originalEssay ? originalEssay.length : 'EMPTY');



  // CRITICAL: Use appState.quickfixFixedText (has FULL text) instead of data.fixedEssay (only 28 chars!)

  const fullFixedText = appState.quickfixFixedText || fixedEssay || '';

  const fullOriginalText = appState.quickfixOriginalText || originalEssay || fullFixedText;



  console.log('ðŸ“Š Text sources:', {

    dataFixedEssay: fixedEssay ? fixedEssay.length : 0,

    appStateFixedText: appState.quickfixFixedText ? appState.quickfixFixedText.length : 0,

    finalFixedText: fullFixedText.length,

    finalOriginalText: fullOriginalText.length

  });



  // CRITICAL FIX: Changed from > 28 to > 0 - the 28 character check was blocking text display

  // Even if text is short, we should still show it!

  if (fullFixedText && fullFixedText.trim().length > 0) {

    // Store plain text for copying

    appState.quickfixFixedText = fullFixedText;



    // Populate Fixed Essay view (default) - USE FULL TEXT FROM appState

    if (fixedEssayEl) {

      console.log('ðŸ” BEFORE populating fixedEssayEl:', {

        elementExists: !!fixedEssayEl,

        currentTextContent: fixedEssayEl.textContent.substring(0, 50),

        currentLength: fixedEssayEl.textContent.length,

        fullFixedTextLength: fullFixedText.length,

        fullFixedTextPreview: fullFixedText.substring(0, 100)

      });



      fixedEssayEl.textContent = fullFixedText;

      fixedEssayEl.style.setProperty('display', 'block', 'important'); // FORCE VISIBLE - Override any CSS

      fixedEssayEl.style.setProperty('visibility', 'visible', 'important');

      fixedEssayEl.style.setProperty('opacity', '1', 'important'); // Ensure it's not transparent



      console.log('âœ… AFTER populating fixedEssayEl:', {

        textContentLength: fixedEssayEl.textContent.length,

        textContentPreview: fixedEssayEl.textContent.substring(0, 100),

        display: window.getComputedStyle(fixedEssayEl).display,

        visibility: window.getComputedStyle(fixedEssayEl).visibility,

        opacity: window.getComputedStyle(fixedEssayEl).opacity

      });

    } else {

      console.error('âŒ fixedEssay element NOT FOUND!');

    }



    // Populate Original Essay view - USE CLEAN FLAG NUMBERING

    if (originalEssayEl) {

      // Use clean flag numbering for the original essay

      populateOriginalWithCleanFlags(fullOriginalText || '', data.flags || appState.quickfixFlags || []);

      originalEssayEl.style.setProperty('display', 'none', 'important'); // Hidden by default

    } else {

      console.error('âŒ originalEssay element NOT FOUND!');

    }



    // Populate Diff Essay view - USE FULL TEXT

    if (diffEssayEl) {

      buildDiffView({

        fixedEssay: fullFixedText,

        flags: flags

      });

      diffEssayEl.style.setProperty('display', 'none', 'important'); // Hidden by default

      console.log('âœ… Diff view built with FULL TEXT');

    } else {

      console.error('âŒ diffEssay element NOT FOUND!');

    }



    // Populate TEXTAREA (editable) - USE FULL TEXT

    if (textAreaEl) {

      textAreaEl.value = fullFixedText;

      console.log('âœ… Textarea populated with FULL TEXT, length:', textAreaEl.value.length);

    } else {

      console.error('âŒ textArea element NOT FOUND!');

    }



    // Populate hidden textarea for copy function

    if (textForCopyEl) {

      textForCopyEl.value = fullFixedText;

    }



    // Build diff view - USE FULL TEXT

    if (diffEssayEl) {

      buildDiffView({

        fixedEssay: fullFixedText,

        flags: flags

      });

      diffEssayEl.style.setProperty('display', 'none', 'important'); // Hidden by default

      console.log('âœ… Diff view built with FULL TEXT');

    } else {

      console.error('âŒ diffEssay element NOT FOUND!');

    }



    // DON'T call showVersion - it hides everything first!

    // Fixed essay is already visible with display: block !important above

    console.log('âœ… Fixed essay is VISIBLE with full text - DO NOT HIDE IT!');

  } else {

    console.error('âŒ Full fixed text is EMPTY or too short!', {

      fullFixedTextLength: fullFixedText.length,

      appStateFixedText: appState.quickfixFixedText ? appState.quickfixFixedText.length : 0,

      dataFixedEssay: fixedEssay ? fixedEssay.length : 0

    });

  }



  // Show/hide Pro scan count display for Pro users only

  const proScanCountDisplay = document.getElementById('proStep3ScanCount');

  const isPro = appState.isProUser || false;

  if (proScanCountDisplay) {

    if (isPro) {

      // Show scan count display for Pro users

      proScanCountDisplay.style.display = 'block';



      // Get scan count from localStorage or appState (Pro scans are tracked monthly)

      let scansUsed = 0;

      if (typeof getScansUsed === 'function') {

        scansUsed = getScansUsed() || 0;

      } else if (appState.scansUsed !== undefined) {

        scansUsed = appState.scansUsed || 0;

      } else {

        // Try to get from localStorage

        try {

          const today = new Date().toDateString();

          const monthKey = 'proScans_' + new Date().getFullYear() + '_' + (new Date().getMonth() + 1);

          const stored = localStorage.getItem(monthKey);

          scansUsed = stored ? parseInt(stored, 10) : 0;

        } catch (e) {

          console.warn('Could not get scan count from localStorage:', e);

        }

      }



      const maxScans = 100; // Pro gets 100 scans per month

      const remaining = Math.max(0, maxScans - scansUsed);



      // Update display

      const scansUsedEl = document.getElementById('proStep3ScansUsed');

      const remainingEl = document.getElementById('proStep3RemainingCount');

      const scanCountTextEl = document.getElementById('proStep3ScanCountText');



      if (scansUsedEl) scansUsedEl.textContent = scansUsed;

      if (remainingEl) remainingEl.textContent = remaining;

      if (scanCountTextEl) {

        scanCountTextEl.innerHTML = `<span id="proStep3ScansUsed">${scansUsed}</span> / ${maxScans} scans used`;

      }



      // Update remaining count color based on usage

      const remainingCountEl = document.getElementById('proStep3ScansRemaining');

      if (remainingCountEl) {

        if (remaining < 50) {

          remainingCountEl.style.color = '#dc2626'; // Red if low

        } else if (remaining < 100) {

          remainingCountEl.style.color = '#f59e0b'; // Amber if medium

        } else {

          remainingCountEl.style.color = '#075985'; // Blue if plenty

        }

      }



      console.log('âœ… Pro scan count displayed:', { scansUsed, remaining, maxScans });

    } else {

      // Hide scan count display for non-Pro users

      proScanCountDisplay.style.display = 'none';

    }

  }



  // Show Step 3

  const step3 = document.getElementById('quickfixStep3');

  if (step3) {

    step3.classList.add('active');

    step3.style.display = 'block';

    step3.scrollIntoView({ behavior: 'smooth', block: 'start' });

  }



  // Animate the progress bar after all content is populated

  // Use afterScore which is already defined in this function scope

  const scoreToAnimate = afterScore || textRisk || 0;

  setTimeout(() => {

    animateStep3ProgressBar(scoreToAnimate);

  }, 300);

}



// Rescan essay after user edits

async function rescanEssay() {

  // Get rescan button and store original state for restoration

  const rescanBtn = document.getElementById('rescanAfterEditsBtn');

  let originalButtonText = '';

  let originalButtonDisabled = false;



  if (rescanBtn) {

    originalButtonText = rescanBtn.innerHTML;

    originalButtonDisabled = rescanBtn.disabled;



    // Immediately disable button and show loading state

    rescanBtn.disabled = true;

    rescanBtn.style.cursor = 'not-allowed';

    rescanBtn.style.opacity = '0.7';

    rescanBtn.style.pointerEvents = 'none';



    // Add spinner icon with animation and estimated time (10 seconds)

    rescanBtn.innerHTML = '<span class="spinner-icon" style="display: inline-block; width: 14px; height: 14px; margin-right: 8px; border: 2px solid rgba(255, 255, 255, 0.3); border-top-color: white; border-radius: 50%; animation: rescanButtonSpin 0.8s linear infinite; vertical-align: middle;"></span> Scanning... (~10s)';

  }



  // Get text from the EDITABLE textarea (what user actually edited)

  const textAreaEl = document.getElementById('quickfixFixedTextArea');

  if (!textAreaEl) {

    // Restore button state

    if (rescanBtn) {

      rescanBtn.disabled = originalButtonDisabled;

      rescanBtn.innerHTML = originalButtonText;

      rescanBtn.style.cursor = 'pointer';

      rescanBtn.style.opacity = '1';

    }

    showSuccessMessage('âŒ Text area not found');

    return;

  }



  const editedText = textAreaEl.value || '';

  if (!editedText.trim()) {

    // Restore button state

    if (rescanBtn) {

      rescanBtn.disabled = originalButtonDisabled;

      rescanBtn.innerHTML = originalButtonText;

      rescanBtn.style.cursor = 'pointer';

      rescanBtn.style.opacity = '1';

    }

    showSuccessMessage('âŒ Please enter some text to scan');

    return;

  }



  // Check if we're in QuickFix flow or Pro flow (NOT free)

  const quickfixStep3 = document.getElementById('quickfixStep3');

  const isInQuickFixFlow = quickfixStep3 && (quickfixStep3.style.display !== 'none' || quickfixStep3.classList.contains('active'));

  const isPro = appState.isProUser || false;

  const isProOrQuickFix = isPro || isInQuickFixFlow;



  // For QuickFix: Check rescan count (only ONE rescan allowed)

  if (isInQuickFixFlow && !isPro) {

    if (appState.quickfixRescanCount === undefined) {

      appState.quickfixRescanCount = 0;

    }

    if (appState.quickfixRescanCount >= 1) {

      // Restore button state

      if (rescanBtn) {

        rescanBtn.disabled = originalButtonDisabled;

        rescanBtn.innerHTML = originalButtonText;

        rescanBtn.style.cursor = 'pointer';

        rescanBtn.style.opacity = '1';

      }

      // Show upgrade modal instead of success message

      showQuickFixRescanUpgradeModal();

      return;

    }

  }



  // STEP 2: Store BEFORE score BEFORE calling API (for comparison modal)

  const beforeScore = appState.apiResponse?.afterScore || appState.apiResponse?.textRisk || appState.quickfixOriginalScore || 0;



  // Determine tier based on user type

  const tier = isPro ? 'pro' : 'free';



  try {

    showSuccessMessage('ðŸ”„ Re-scanning your essay...');



    // Call rescan API (existing code - don't modify this part)

    const response = await fetch('/analyze', {

      method: 'POST',

      headers: { 'Content-Type': 'application/json' },

      body: JSON.stringify({ essay: editedText, tier })

    });



    if (!response.ok) throw new Error('Analysis failed');



    const data = await response.json();



    // Store in appState

    appState.apiResponse = data;

    appState.quickfixFixedText = data.fixedEssay || editedText;



    // Increment QuickFix rescan count (only for QuickFix, not Pro)

    if (isInQuickFixFlow && !isPro) {

      appState.quickfixRescanCount = (appState.quickfixRescanCount || 0) + 1;

    }



    // Get new score

    const afterScore = data.afterScore || data.textRisk || 0;



    console.log('ðŸ“Š Rescan complete - scores:', {

      beforeScore,

      afterScore,

      isPro,

      isInQuickFixFlow,

      isProOrQuickFix

    });



    // Update Step 3 with new results (existing function - DO NOT MODIFY)

    displayStep3Results(data);



    // STEP 2: Show modal AFTER displayStep3Results completes - ONLY for Pro and QuickFix (NOT free)

    // Add debugging RIGHT BEFORE modal should appear

    console.log('ðŸ” About to show rescan modal - beforeScore:', beforeScore, 'afterScore:', afterScore);

    console.log('ðŸ” Modal element exists:', !!document.getElementById('rescanComparisonModal'));

    console.log('ðŸ” Is Pro/QuickFix:', { isPro, isInQuickFixFlow, isProOrQuickFix });



    if (isProOrQuickFix) {

      console.log('âœ… User is Pro or QuickFix - showing modal');

      // Show modal immediately after displayStep3Results completes

      // Use setTimeout with 0 delay to ensure displayStep3Results has fully rendered

      setTimeout(() => {

        console.log('â° Showing rescan comparison modal now...');

        showRescanComparisonModal({

          beforeScore: beforeScore,

          afterScore: afterScore,

          isPro: isPro

        });

      }, 0);

    } else {

      // Free users: Just show success message (no modal)

      console.log('â„¹ï¸ Free user - no modal shown');

    showSuccessMessage('âœ… Re-scan complete!');

    }



    // Restore button state after scan completes and modal is shown

    // BUT: For QuickFix users who used their one rescan, disable the button

    if (rescanBtn) {

      if (isInQuickFixFlow && !isPro && appState.quickfixRescanCount >= 1) {

        // QuickFix user has used their one rescan - disable button but make it clickable to show upgrade modal

        rescanBtn.disabled = false; // Keep enabled so onclick still works

        rescanBtn.style.cursor = 'pointer';

        rescanBtn.style.opacity = '0.8';

        rescanBtn.innerHTML = 'ðŸ”’ Rescan Used - Upgrade to Pro';

        rescanBtn.style.background = '#f59e0b'; // Amber/orange to indicate upgrade needed

        rescanBtn.style.color = 'white';

        rescanBtn.style.border = 'none';

        // Remove old onclick and set new one

        rescanBtn.removeAttribute('onclick');

        rescanBtn.onclick = function(e) {

          e.preventDefault();

          e.stopPropagation();

          showQuickFixRescanUpgradeModal();

          return false;

        };

        rescanBtn.setAttribute('onclick', 'showQuickFixRescanUpgradeModal(); return false;');

        console.log('ðŸ”’ QuickFix rescan button updated - shows upgrade modal on click');

      } else {

        // Pro users or QuickFix users who haven't used rescan yet - restore normal state

        rescanBtn.disabled = originalButtonDisabled;

        rescanBtn.innerHTML = originalButtonText;

        rescanBtn.style.cursor = 'pointer';

        rescanBtn.style.opacity = '1';

      }

    }

  } catch (error) {

    console.error('âŒ Rescan error:', error);

    showSuccessMessage('âŒ Failed to re-scan. Please try again.');



    // Restore button state on error

    if (rescanBtn) {

      rescanBtn.disabled = originalButtonDisabled;

      rescanBtn.innerHTML = originalButtonText;

      rescanBtn.style.cursor = 'pointer';

      rescanBtn.style.opacity = '1';

    }

  }

}



// STEP 1: Simple rescan comparison modal - shows before/after scores

function showRescanComparisonModal(data) {

  console.log('ðŸŽ¯ showRescanComparisonModal called with:', data);



  // Extract values from object

  const beforeScore = data.beforeScore || data.before || 0;

  const afterScore = data.afterScore || data.after || 0;

  const isPro = data.isPro || false;



  // === 1. COMPLETE CLEANUP FIRST ===

  const existingModal = document.getElementById('rescanComparisonModal');

  if (existingModal) {

    // Remove all event listeners by cloning

    const cloned = existingModal.cloneNode(false);

    existingModal.replaceWith(cloned);

    existingModal.remove();

    console.log('âœ… Removed existing modal and event listeners');

  }



  // Clean up any modals with timestamp IDs

  const allModals = document.querySelectorAll('[id^="rescanComparisonModal_"]');

  allModals.forEach(m => {

    m.style.display = 'none';

    setTimeout(() => m.remove(), 100);

  });



  // Clean up body classes

  document.body.classList.remove('modal-open', 'modal-active');

  document.body.style.overflow = '';



  // Remove any global references

  if (window.activeRescanModal) {

    window.activeRescanModal = null;

  }



  // === 2. CREATE MODAL WITH UNIQUE ID ===

  const modalId = 'rescanComparisonModal_' + Date.now();

  const modal = document.createElement('div');

  modal.id = modalId;

  modal.className = 'rescan-comparison-modal';



  // Determine score color

  let afterScoreColor = '#10b981'; // Green

  if (afterScore > 30 && afterScore <= 70) {

    afterScoreColor = '#f59e0b'; // Amber

  } else if (afterScore > 70) {

    afterScoreColor = '#ef4444'; // Red

  }



  // === 3. USE INLINE EVENT HANDLERS (MORE RELIABLE) ===

  const contentId = 'rescanComparisonModalContent_' + Date.now();

  modal.innerHTML = `

    <div id="${contentId}" class="rescan-comparison-modal-content" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000000; background: white; padding: 40px; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); max-width: 500px; width: 90%; min-width: 300px;">

      <button onclick="document.getElementById('${modalId}').style.display='none'; document.body.classList.remove('modal-open'); document.body.style.overflow='';" 

              style="position: absolute; top: 16px; right: 16px; background: none; border: none; font-size: 28px; color: #6b7280; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 50%;" 

              onmouseover="this.style.background='#f3f4f6';" 

              onmouseout="this.style.background='none';">

        Ã—

      </button>

      <h2 style="font-size: 24px; font-weight: 700; color: #1f2937; margin: 0 0 24px 0; text-align: center;">ðŸ”„ Rescan Complete</h2>

      <div style="display: flex; gap: 20px; justify-content: center; margin-bottom: 24px;">

        <div style="text-align: center;">

          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">Before Score</div>

          <div style="font-size: 36px; font-weight: 700; color: #374151;">${Math.round(beforeScore)}%</div>

        </div>

        <div style="display: flex; align-items: center; font-size: 24px; color: #6b7280;">â†’</div>

        <div style="text-align: center;">

          <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">After Score</div>

          <div style="font-size: 36px; font-weight: 700; color: ${afterScoreColor};">${Math.round(afterScore)}%</div>

        </div>

      </div>

      <div style="display: flex; flex-direction: column; gap: 12px;">

        <button onclick="

          const modal = document.getElementById('${modalId}');

          if (modal) { modal.style.display='none'; document.body.classList.remove('modal-open'); document.body.style.overflow=''; }

          console.log('ðŸ”µ View Results clicked');

          setTimeout(function() { if (typeof viewFullResultsFromRescanModal === 'function') viewFullResultsFromRescanModal(); }, 100);

        " style="width: 100%; padding: 14px 24px; font-size: 16px; font-weight: 700; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer;" 

        onmouseover="this.style.background='#059669';" 

        onmouseout="this.style.background='#10b981';">

          âœ… View Full Results

        </button>

        <button onclick="

          const modal = document.getElementById('${modalId}');

          if (modal) { modal.style.display='none'; document.body.classList.remove('modal-open'); document.body.style.overflow=''; }

          console.log('ðŸ”µ Edit More clicked');

          setTimeout(function() { if (typeof closeRescanComparisonModalAndFocusEdit === 'function') closeRescanComparisonModalAndFocusEdit(); }, 100);

        " style="width: 100%; padding: 14px 24px; font-size: 16px; font-weight: 700; background: white; color: #00a8e8; border: 2px solid #00a8e8; border-radius: 8px; cursor: pointer; display: ${isPro ? 'block' : 'none'};" 

        onmouseover="this.style.background='#f0f9ff';" 

        onmouseout="this.style.background='white';">

          âœï¸ Edit More

        </button>

      </div>

    </div>

  `;



  // === 4. APPLY STYLES ===

  modal.style.cssText = `

    position: fixed !important;

    top: 0 !important;

    left: 0 !important;

    width: 100vw !important;

    height: 100vh !important;

    background: rgba(0,0,0,0.85) !important;

    z-index: 999999 !important;

    display: block !important;

    visibility: visible !important;

    opacity: 1 !important;

  `;



  // === 5. ADD BACKDROP CLICK HANDLER ===

  modal.onclick = function(e) {

    if (e.target === modal) {

      e.stopPropagation();

      e.preventDefault();

      console.log('ðŸ”µ Backdrop clicked - hiding modal');

      modal.style.display = 'none';

      document.body.classList.remove('modal-open');

      document.body.style.overflow = '';

    }

  };



  // === 6. APPEND AND SHOW ===

  document.body.appendChild(modal);

  document.body.classList.add('modal-open');

  document.body.style.overflow = 'hidden';



  // === 7. STORE REFERENCE (optional) ===

  window.activeRescanModal = modal;



  // === 8. RETURN WITH CLEANUP METHOD ===

  return {

    modal: modal,

    close: function() {

      if (modal && modal.parentNode) {

        console.log('ðŸ”µ Closing modal via cleanup method');

        modal.style.display = 'none';

        document.body.classList.remove('modal-open');

        document.body.style.overflow = '';

        setTimeout(() => {

          if (modal.parentNode) modal.remove();

        }, 300);

      }

    }

  };

}



// Close rescan comparison modal

function closeRescanComparisonModal() {

  const modal = document.getElementById('rescanComparisonModal');

  if (modal) {

    console.log('ðŸ”µ closeRescanComparisonModal called - hiding modal');

    modal.style.display = 'none';

    modal.style.visibility = 'hidden';

    modal.style.opacity = '0';

    document.body.style.overflow = '';

  } else {

    console.warn('âš ï¸ closeRescanComparisonModal: modal not found');

  }

}



// Close modal and focus on edit textarea (Pro only)

// Note: Modal is already hidden by button handler, so this just focuses textarea

function closeRescanComparisonModalAndFocusEdit() {

  console.log('ðŸ”µ closeRescanComparisonModalAndFocusEdit called - focusing textarea');

  setTimeout(() => {

    const textAreaEl = document.getElementById('quickfixFixedTextArea');

    if (textAreaEl) {

      textAreaEl.focus();

      textAreaEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

      console.log('âœ… Textarea focused for editing');

    } else {

      console.warn('âš ï¸ Textarea not found for focusing');

    }

  }, 100);

}



// STEP 3: View Full Results - Re-scan edited essay and show Step 2 with fresh analysis

async function viewFullResultsFromRescanModal() {

  // Close the modal

  closeRescanComparisonModal();



  // STEP 3: Get edited text from textarea (user specified quickfixEditableEssay)

  const textAreaEl = document.getElementById('quickfixEditableEssay') || document.getElementById('quickfixFixedTextArea');

  if (!textAreaEl || !textAreaEl.value?.trim()) {

    showSuccessMessage('âŒ No edited text found to analyze');

    return;

  }



  const editedText = textAreaEl.value.trim();

  console.log('âœ… View Full Results - Re-scanning edited text, length:', editedText.length);



  try {

    // No success message needed - user already clicked "View Full Results" from modal

    // The analysis will happen silently and show Step 2 with results



    // STEP 3: Call the EXACT SAME functions used for initial Pro scans

    // Reuse existing analyzeTextWithAPI function (same as line 8519)

    if (typeof analyzeTextWithAPI === 'function') {

      console.log('âœ… Using analyzeTextWithAPI function (reusing existing code)');

      // Use analyzeTextWithAPI with tier parameter as user specified

      const data = await analyzeTextWithAPI(editedText, 'pro');



      // Convert API issues to flags format (same pattern as line 8530-8548)

      const flags = (data.issues || []).map(issue => {

        let impact = 15; // Default

        if (issue.severity === 'high') {

          impact = 25;

        } else if (issue.severity === 'medium') {

          impact = 18;

        } else {

          impact = 12;

        }



        return {

          phrase: issue.phrase || issue.text || '',

          explanation: issue.explanation || issue.reason || 'AI pattern detected',

          suggestedFix: (issue.alternatives && issue.alternatives[0]) || 'Rephrase in your own words',

          severity: issue.severity || 'medium',

          impact: issue.impact || impact

        };

      });



      // Store in appState (same as initial Pro scan - line 8562-8574)

      appState.quickfixOriginalText = editedText;

      appState.quickfixFlags = flags;

      appState.quickfixOriginalScore = data.score;

      appState.quickfixOriginalTextPhraseScore = data.textPhraseScore || data.score;

      appState.quickfixOriginalStructuralScore = data.structuralScore || data.score;



      // IMPORTANT: Don't reset rescan count here - it should persist through the cycle

      // The rescan count tracks rescans within a single analysis cycle

      // It only resets when starting a completely new scan from Step 1

      const isInQuickFixFlow = document.getElementById('quickfixStep3') && 

                                (document.getElementById('quickfixStep3').style.display !== 'none' || 

                                 document.getElementById('quickfixStep3').classList.contains('active'));

      const isPro = appState.isProUser || false;



      console.log('âœ… Fresh analysis complete:', {

        score: data.score,

        flagsCount: flags.length,

        isPro: isPro,

        isInQuickFixFlow: isInQuickFixFlow,

        currentRescanCount: appState.quickfixRescanCount

      });



      // STEP 3: Call the EXACT SAME functions used for initial Pro scans

      // showQuickFixStep(2) - same as line 8581

      if (typeof showQuickFixStep === 'function') {

        showQuickFixStep(2);

      }



      // displayQuickFixAnalysis(editedText, data.score, data.flags) - same as line 8583

      appState.quickfixResetOriginalText = editedText;

      appState.quickfixResetOriginalScore = data.score;

      appState.quickfixResetFlagsOriginal = JSON.parse(JSON.stringify(flags));

      if (typeof displayQuickFixAnalysis === 'function') {

        displayQuickFixAnalysis(editedText, data.score, flags);

      }



      console.log('âœ… Showing Step 2 with fresh analysis - user can now apply fixes and rescan again');

    } else {

      // Fallback if analyzeTextWithAPI doesn't exist - use same fetch pattern

      console.warn('âš ï¸ analyzeTextWithAPI not found, using direct fetch pattern');

      const BACKEND_URL = window.BACKEND_URL || 'http://localhost:5000';

      const response = await fetch(`${BACKEND_URL}/analyze`, {

        method: 'POST',

        headers: { 'Content-Type': 'application/json' },

        body: JSON.stringify({ essay: editedText, tier: 'pro' })

      });



      if (!response.ok) throw new Error('Analysis failed');



      const data = await response.json();



      // Extract score and flags - handle different possible formats

      const score = data.afterScore || data.textRisk || data.score || 0;

      let flags = data.flags || data.triggerWords || [];

      if (!Array.isArray(flags)) {

        flags = [];

      }



      // Store in appState

      appState.quickfixOriginalText = editedText;

      appState.quickfixFlags = flags;

      appState.quickfixOriginalScore = score;



      // Call the same functions

      if (typeof showQuickFixStep === 'function') {

        showQuickFixStep(2);

      }

      appState.quickfixResetOriginalText = editedText;

      appState.quickfixResetOriginalScore = score;

      appState.quickfixResetFlagsOriginal = JSON.parse(JSON.stringify(flags));

      if (typeof displayQuickFixAnalysis === 'function') {

        displayQuickFixAnalysis(editedText, score, flags);

      }

    }



  } catch (error) {

    console.error('âŒ Failed to re-analyze essay:', error);

    showSuccessMessage('âŒ Failed to analyze. Please try again.');

  }

}



// Close modal when clicking outside

window.addEventListener('click', function(event) {

  const modal = document.getElementById('rescanComparisonModal');

  if (modal && event.target === modal) {

    closeRescanComparisonModal();

  }

});



// Copy essay to clipboard (plain text from textarea)

async function copyEssay() {

  // Get text from the EDITABLE textarea (whatever user edited)

  const textAreaEl = document.getElementById('quickfixFixedTextArea');



  if (!textAreaEl) {

    showSuccessMessage('âŒ Text area not found');

    return;

  }



  const text = textAreaEl.value || '';



  if (!text.trim()) {

    showSuccessMessage('âŒ No text to copy');

    return;

  }



  try {

    await navigator.clipboard.writeText(text);

    showSuccessMessage('âœ… Copied to clipboard!');

  } catch (error) {

    console.error('âŒ Copy error:', error);

    // Fallback for older browsers

    const textArea = document.createElement('textarea');

    textArea.value = text;

    document.body.appendChild(textArea);

    textArea.select();

    document.execCommand('copy');

    document.body.removeChild(textArea);

    showSuccessMessage('âœ… Copied to clipboard!');

  }

}



// Show False Flag Flowâ„¢ tooltip

function showFalseFlowTooltip() {

  const tooltip = document.getElementById('falseFlowTooltip');

  if (tooltip) {

    tooltip.style.display = 'block';

  }

}



// Hide False Flag Flowâ„¢ tooltip

function hideFalseFlowTooltip() {

  const tooltip = document.getElementById('falseFlowTooltip');

  if (tooltip) {

    // Only hide if not clicked (clicked state persists)

    const btn = document.getElementById('falseFlowTooltipBtn');

    if (btn && !btn.classList.contains('tooltip-active')) {

      tooltip.style.display = 'none';

    }

  }

}



// Toggle False Flag Flowâ„¢ tooltip (for click)

function toggleFalseFlowTooltip() {

  const tooltip = document.getElementById('falseFlowTooltip');

  const btn = document.getElementById('falseFlowTooltipBtn');

  if (tooltip && btn) {

    const isVisible = tooltip.style.display === 'block';

    tooltip.style.display = isVisible ? 'none' : 'block';

    if (isVisible) {

      btn.classList.remove('tooltip-active');

    } else {

      btn.classList.add('tooltip-active');

    }

  }

}



// Show QuickFix rescan upgrade modal when user tries to rescan after using their one rescan

function showQuickFixRescanUpgradeModal() {

  // Remove any existing modal

  const existingModal = document.getElementById('quickfixRescanUpgradeModal');

  if (existingModal) {

    existingModal.remove();

  }



  // Create modal overlay

  const modal = document.createElement('div');

  modal.id = 'quickfixRescanUpgradeModal';

  modal.style.cssText = `

    position: fixed;

    top: 0;

    left: 0;

    width: 100vw;

    height: 100vh;

    background: rgba(0, 0, 0, 0.7);

    z-index: 1000001;

    display: flex;

    align-items: center;

    justify-content: center;

    padding: 20px;

  `;



  // Create modal content

  const content = document.createElement('div');

  content.style.cssText = `

    background: white;

    border-radius: 16px;

    padding: 30px;

    max-width: 450px;

    width: 100%;

    text-align: center;

    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);

    position: relative;

  `;



  content.innerHTML = `

    <button onclick="document.getElementById('quickfixRescanUpgradeModal').remove(); document.body.classList.remove('modal-open');" 

            style="position: absolute; top: 15px; right: 15px; background: transparent; border: none; font-size: 28px; color: #999; cursor: pointer; padding: 5px; line-height: 1;">Ã—</button>

    <div style="font-size: 48px; margin-bottom: 15px;">âš¡</div>

    <h3 style="color: #0b0646; margin-bottom: 12px; font-size: 22px; font-weight: 700;">Want Another Rescan?</h3>

    <p style="color: #6b7280; margin-bottom: 20px; font-size: 15px; line-height: 1.6;">

      QuickFix includes ONE rescan per essay. You've already used yours! ðŸŽ¯

    </p>

    <p style="color: #374151; margin-bottom: 24px; font-size: 14px; line-height: 1.5; font-weight: 600;">

      Upgrade to Pro for unlimited rescans + 100 monthly scans!

    </p>

    <div style="display: flex; flex-direction: column; gap: 12px;">

      <button onclick="handleProUpgrade(); document.getElementById('quickfixRescanUpgradeModal').remove(); document.body.classList.remove('modal-open');" 

              style="background: linear-gradient(135deg, #00a8e8 0%, #0087c4 100%); color: white; border: none; padding: 14px 24px; border-radius: 8px; font-size: 16px; font-weight: 700; cursor: pointer; transition: transform 0.2s; box-shadow: 0 4px 12px rgba(0, 168, 232, 0.25);"

              onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 168, 232, 0.4)';"

              onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0, 168, 232, 0.25)';">

        â†’ Get Pro - $9.99/mo

      </button>

      <button onclick="document.getElementById('quickfixRescanUpgradeModal').remove(); document.body.classList.remove('modal-open');" 

              style="background: white; color: #6b7280; border: 1px solid #e5e7eb; padding: 12px 24px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background 0.2s;"

              onmouseover="this.style.background='#f9fafb';"

              onmouseout="this.style.background='white';">

        Maybe Later

      </button>

    </div>

    <p style="color: #9ca3af; margin-top: 16px; font-size: 11px; line-height: 1.4;">

      Cancel anytime â€¢ 100 monthly scans â€¢ Unlimited rescans

    </p>

  `;



  modal.appendChild(content);

  document.body.appendChild(modal);

  document.body.classList.add('modal-open');



  // Close on backdrop click

  modal.addEventListener('click', function(e) {

    if (e.target === modal) {

      modal.remove();

      document.body.classList.remove('modal-open');

    }

  });

}



// Helper function to get flag color based on score

function getFlagColor(score) {

  if (typeof score === 'number') {

    if (score <= 30) return '#10b981'; // Green

    if (score <= 70) return '#f59e0b'; // Amber

    return '#ef4444'; // Red

  } else if (typeof score === 'string') {

    const scoreLower = score.toLowerCase();

    if (scoreLower === 'low') return '#10b981'; // Green

    if (scoreLower === 'medium' || scoreLower === 'med') return '#f59e0b'; // Amber

    if (scoreLower === 'high') return '#ef4444'; // Red

    return '#10b981'; // Default green

  }

  return '#10b981'; // Default green

}



// Update flag colors dynamically using CSS filters

// The ðŸš© emoji is RED by default, so we need to hue-rotate to change colors

function updateFlagColors(textRisk, flagFlowScore) {

  const leftFlag = document.getElementById('leftFlag');

  const rightFlag = document.getElementById('rightFlag');



  console.log('ðŸŽ¨ updateFlagColors called:', { textRisk, flagFlowScore });



  if (leftFlag) {

    const textRiskColor = getFlagColor(textRisk);

    console.log('ðŸŽ¨ Left flag - textRisk:', textRisk, 'color:', textRiskColor);

    // Red emoji (0deg) -> Green (120deg), Amber (60deg), Red (0deg)

    if (textRiskColor === '#10b981') {

      leftFlag.style.filter = 'hue-rotate(120deg) saturate(1.2)'; // Red -> Green

      console.log('âœ… Left flag set to GREEN');

    } else if (textRiskColor === '#f59e0b') {

      leftFlag.style.filter = 'hue-rotate(60deg) saturate(1.2)'; // Red -> Amber/Yellow

      console.log('ðŸŸ¡ Left flag set to AMBER');

    } else {

      leftFlag.style.filter = 'none'; // Red (default emoji color)

      console.log('ðŸ”´ Left flag set to RED');

    }

  }



  if (rightFlag) {

    const flagFlowColor = typeof flagFlowScore === 'string' 

      ? getFlagColor(flagFlowScore)

      : getFlagColor(flagFlowScore === 'Low' ? 25 : flagFlowScore === 'Medium' ? 50 : 75);

    console.log('ðŸŽ¨ Right flag - flagFlowScore:', flagFlowScore, 'color:', flagFlowColor);

    // Same color filter logic

    if (flagFlowColor === '#10b981') {

      rightFlag.style.filter = 'hue-rotate(120deg) saturate(1.2)'; // Red -> Green

      console.log('âœ… Right flag set to GREEN');

    } else if (flagFlowColor === '#f59e0b') {

      rightFlag.style.filter = 'hue-rotate(60deg) saturate(1.2)'; // Red -> Amber/Yellow

      console.log('ðŸŸ¡ Right flag set to AMBER');

    } else {

      rightFlag.style.filter = 'none'; // Red (default emoji color)

      console.log('ðŸ”´ Right flag set to RED');

    }

  }

}



// Update score box colors (top two boxes) dynamically based on scores

function updateScoreBoxColors(textRisk, flagFlowScore) {

  const textRiskScoreBox = document.getElementById('textRiskScoreBox');

  const flagFlowScoreBox = document.getElementById('flagFlowScoreBox');



  console.log('ðŸŽ¨ updateScoreBoxColors called:', { textRisk, flagFlowScore });



  if (textRiskScoreBox) {

    const textRiskColor = getFlagColor(textRisk);

    textRiskScoreBox.style.background = textRiskColor;

    textRiskScoreBox.style.color = '#ffffff'; // Ensure white text

    console.log('âœ… Text Risk box color set to:', textRiskColor, 'for score:', textRisk);

  }



  if (flagFlowScoreBox) {

    const flagFlowColor = getFlagColor(flagFlowScore);

    flagFlowScoreBox.style.background = flagFlowColor;

    flagFlowScoreBox.style.color = '#ffffff'; // Ensure white text

    console.log('âœ… Flag Flow box color set to:', flagFlowColor, 'for score:', flagFlowScore);

  }

}



// Update box colors dynamically based on scores

function updateBoxColors(textRisk, flagFlowScore) {

  // TEXT RISK CARD

  const textRiskCard = document.getElementById('textRiskCard');

  const textRiskCardTitle = document.getElementById('textRiskCardTitle');

  const textRiskCardDivider = document.getElementById('textRiskCardDivider');



  if (textRiskCard && textRiskCardTitle) {

    const textRiskColor = getFlagColor(textRisk);

    let bgColor, borderColor, titleColor, dividerColor;



    if (textRiskColor === '#10b981') {

      // Green - CLEAN

      bgColor = '#f0fdf4';

      borderColor = '#10b981';

      titleColor = '#10b981';

      dividerColor = '#d1fae5';

    } else if (textRiskColor === '#f59e0b') {

      // Amber - KINDA SUS

      bgColor = '#fffbeb';

      borderColor = '#f59e0b';

      titleColor = '#f59e0b';

      dividerColor = '#fde68a';

    } else {

      // Red - HELLA SUS

      bgColor = '#fef2f2';

      borderColor = '#ef4444';

      titleColor = '#ef4444';

      dividerColor = '#fecaca';

    }



    textRiskCard.style.background = bgColor;

    textRiskCard.style.borderColor = borderColor;

    textRiskCardTitle.style.color = titleColor;

    if (textRiskCardDivider) {

      textRiskCardDivider.style.borderTopColor = dividerColor;

    }

  }



  // FLAG FLOW SCORE CARD

  const flagFlowScoreCard = document.getElementById('flagFlowScoreCard');

  const flagFlowScoreCardTitle = document.getElementById('flagFlowScoreCardTitle');



  if (flagFlowScoreCard && flagFlowScoreCardTitle) {

    const flagFlowColor = typeof flagFlowScore === 'string' 

      ? getFlagColor(flagFlowScore)

      : getFlagColor(flagFlowScore === 'Low' ? 25 : flagFlowScore === 'Medium' ? 50 : 75);



    let bgColor, borderColor, titleColor;



    if (flagFlowColor === '#10b981') {

      // Green

      bgColor = '#f0fdf4';

      borderColor = '#10b981';

      titleColor = '#10b981';

    } else if (flagFlowColor === '#f59e0b') {

      // Amber

      bgColor = '#fffbeb';

      borderColor = '#f59e0b';

      titleColor = '#f59e0b';

    } else {

      // Red

      bgColor = '#fef2f2';

      borderColor = '#ef4444';

      titleColor = '#ef4444';

    }



    flagFlowScoreCard.style.background = bgColor;

    flagFlowScoreCard.style.borderColor = borderColor;

    flagFlowScoreCardTitle.style.color = titleColor;

  }

}



// Display scores in redesigned score cards

function displayScores(data) {

  // TEXT RISK SCORE (Top left)

  const textRiskScoreEl = document.getElementById('textRiskScoreDisplay');

  let textRisk = 0;

  if (textRiskScoreEl) {

    // Use textRisk from data (which should be afterScore when called from displayStep3Results)

    textRisk = data.textRisk || 0;

    textRiskScoreEl.textContent = `${textRisk}%`;

    // Color is now handled by updateScoreBoxColors - text is always white

    textRiskScoreEl.style.color = '#ffffff'; // White text on colored background

    console.log('ðŸ“Š displayScores - Text Risk Score:', textRisk, '%');

  }



  // FLAG FLOW SCORE (Top right with emoji)

  const flagFlowScoreEl = document.getElementById('flagFlowScoreDisplay');

  let flagFlowScore = 'Low';

  if (flagFlowScoreEl) {

    flagFlowScore = data.flagFlowScore || 'Low';

    let emoji = 'ðŸŸ¢';

    let color = '#10b981';

    if (flagFlowScore === 'High') {

      emoji = 'ðŸ”´';

      color = '#ef4444';

    } else if (flagFlowScore === 'Medium') {

      emoji = 'ðŸŸ¡';

      color = '#f59e0b';

    }

    // Format flagFlowScore for display (Low/Medium/High or MED/HIGH)

    let displayText = flagFlowScore;

    if (flagFlowScore === 'Medium') {

      displayText = 'MED'; // Shortened for display

    } else if (flagFlowScore === 'High') {

      displayText = 'HIGH';

    } else if (flagFlowScore === 'Low') {

      displayText = 'Low';

    }

    flagFlowScoreEl.textContent = displayText;

    // Color is now handled by updateScoreBoxColors - text is always white

    flagFlowScoreEl.style.color = '#ffffff'; // White text on colored background

  }



  // Update flag colors dynamically based on scores

  updateFlagColors(textRisk, flagFlowScore);



  // Update score box colors dynamically based on scores

  console.log('ðŸŽ¨ displayScores calling updateScoreBoxColors with:', { textRisk, flagFlowScore });

  updateScoreBoxColors(textRisk, flagFlowScore);



  // Update box colors dynamically based on scores

  updateBoxColors(textRisk, flagFlowScore);



  // FORCE UPDATE: Double-check boxes are correct color after a brief delay

  setTimeout(() => {

    const textRiskBox = document.getElementById('textRiskScoreBox');

    const flagFlowBox = document.getElementById('flagFlowScoreBox');

    const expectedColor = textRisk <= 30 ? '#10b981' : textRisk <= 70 ? '#f59e0b' : '#ef4444';

    if (textRiskBox && textRiskBox.style.background !== expectedColor) {

      textRiskBox.style.background = expectedColor;

      console.log('ðŸ”§ FORCED Text Risk box color to:', expectedColor);

    }

    const flagFlowColor = flagFlowScore === 'Low' ? '#10b981' : flagFlowScore === 'Medium' ? '#f59e0b' : '#ef4444';

    if (flagFlowBox && flagFlowBox.style.background !== flagFlowColor) {

      flagFlowBox.style.background = flagFlowColor;

      console.log('ðŸ”§ FORCED Flag Flow box color to:', flagFlowColor);

    }

  }, 200);



  // TEXT RISK SUMMARY (Bottom left)

  const textRiskSummaryEl = document.getElementById('textRiskSummary');

  if (textRiskSummaryEl) {

    const flagCount = (data.flags || []).length;

    textRiskSummaryEl.textContent = `${flagCount} AI-flagged words identified and replaced with natural alternatives.`;

  }



  // TEXT RISK EXAMPLES (Bottom left examples)

  const textRiskExamplesEl = document.getElementById('textRiskExamples');

  if (textRiskExamplesEl && data.flags && data.flags.length > 0) {

    // Get first 3 flags as examples

    const examples = data.flags.slice(0, 3).map(flag => {

      const original = flag.phrase || flag.original || '';

      const fixed = flag.suggestedFix || flag.replacement || '';

      return `${original} â†’ ${fixed}`;

    });

    if (examples.length > 0) {

      textRiskExamplesEl.textContent = `âœ… Fixed: ${examples.join(', ')}`;

    }

  }



  // FLAG FLOW SCORE SUMMARY (Bottom right)

  const flagFlowScoreSummaryEl = document.getElementById('flagFlowScoreSummary');

  if (flagFlowScoreSummaryEl) {

    const score = data.flagFlowScore || 'Low';



    if (score === 'Low') {

      flagFlowScoreSummaryEl.textContent = 'Your natural voice and rhythm are strong. To further improve:';

    } else if (score === 'Medium') {

      flagFlowScoreSummaryEl.textContent = 'Your writing shows some AI patterns. Focus on these areas:';

    } else {

      flagFlowScoreSummaryEl.textContent = 'Your writing needs more human characteristics. Work on:';

    }

  }



  // RECOMMENDATIONS (Bottom right list)

  const recommendationsEl = document.getElementById('flagFlowScoreRecommendations');

  if (recommendationsEl) {

    const recommendations = getRecommendations(data);

    recommendationsEl.innerHTML = recommendations.map(rec => 

      `<li>${rec}</li>`

    ).join('');

  }

}



// Get recommendations based on essay analysis

function getRecommendations(data) {

  const recs = [];



  // Check what's missing in the essay

  const essay = data.originalEssay || data.fixedEssay || '';

  const hasContractions = /\b(don't|can't|won't|isn't|aren't|it's|i'm|you're|we're|they're|that's|there's|here's)\b/i.test(essay);

  const hasFirstPerson = /\b(I|my|mine|me|we|our|us)\b/.test(essay);

  const sentences = essay.split(/[.!?]+/).filter(s => s.trim().length > 0);

  const avgSentenceLength = sentences.length > 0 

    ? sentences.reduce((sum, s) => sum + s.trim().length, 0) / sentences.length

    : 0;



  if (!hasContractions) {

    recs.push("Add more contractions (don't, can't, it's)");

  }



  if (!hasFirstPerson) {

    recs.push("Include personal pronouns (I think, in my opinion, we)");

  }



  if (avgSentenceLength > 25) {

    recs.push("Vary sentence length (short. Long ones. Medium.)");

  }



  // Check for repetitive sentence starters

  const sentenceStarters = sentences.map(s => s.trim().split(/\s+/)[0].toLowerCase()).filter(Boolean);

  const uniqueStarters = new Set(sentenceStarters);

  if (sentenceStarters.length > 5 && uniqueStarters.size / sentenceStarters.length < 0.4) {

    recs.push("Vary sentence beginnings to avoid repetition");

  }



  if (recs.length === 0) {

    recs.push("Your writing style looks great!");

    recs.push("Focus on the Text Risk fixes above.");

  }



  return recs;

}



// Navigate back to dashboard

function goBack() {

  console.log('ðŸ”˜ goBack() called - returning to main dashboard');

  // Use the proper function to hide QuickFix flow and show main dashboard

  hideQuickFixFlow();

}



// CRITICAL: Reset function for "Scan Another Essay"

function resetForNewScan() {

  console.log('ðŸ”„ resetForNewScan() called - resetting all scan-related states');



  // Reset all scan-related states using centralized function

  if (window.resetScanButton) {

    window.resetScanButton();

  }



  // Clear any pending promises/requests

  if (window._currentPromise) {

    try { window._currentPromise.cancel?.(); } catch(e) {}

    window._currentPromise = null;

  }



  // Reset UI to input section

  const resultsContainer = document.getElementById('resultsContainer');

  const inputSection = document.getElementById('inputSection');

  if (resultsContainer) resultsContainer.classList.remove('show');

  if (inputSection) {

    inputSection.style.display = 'block';

    inputSection.style.visibility = 'visible';

    inputSection.style.opacity = '1';

  }



  // Clear essay input but keep authorship checkbox

  const essayInput = document.getElementById('essayInput');

  if (essayInput) essayInput.value = '';



  // Update character count

  if (window.updateCounter) window.updateCounter();



  console.log('âœ… resetForNewScan complete');

}



// Make globally accessible

window.resetForNewScan = resetForNewScan;



// Start new scan - shows modal for QuickFix users

function startNewScan() {

  console.log('ðŸ”˜ startNewScan() called');



  // Check if user is coming from QuickFix Step 3 and needs to purchase another QuickFix

  const quickfixStep3 = document.getElementById('quickfixStep3');

  const isInQuickFixFlow = quickfixStep3 && (quickfixStep3.style.display !== 'none' || quickfixStep3.classList.contains('active'));



  if (isInQuickFixFlow && !appState.isProUser) {

    // User is in QuickFix flow and not Pro - show existing modal to purchase another QuickFix

    console.log('ðŸ”˜ QuickFix user trying to scan another essay - showing purchase modal');



    // Use the existing modal function - DON'T reset anything, just show modal

    if (typeof showGetAnotherQuickFixModal === 'function') {

      showGetAnotherQuickFixModal();

      return; // Exit early - don't reset or navigate

    } else {

      console.error('âŒ showGetAnotherQuickFixModal function not found');

    }

  }



  // Use centralized reset function (only if not showing modal)

  resetForNewScan();



    // Scroll to top

    window.scrollTo({ top: 0, behavior: 'smooth' });



  // For QuickFix users, show modal (handled by scanNewText)

  // For free users, just reset and return to input

  if (typeof scanNewText === 'function') {

    scanNewText();

  }

}



// Make globally accessible

window.startNewScan = startNewScan;



// Tooltip functions for score boxes

function showTooltip(event, title, text) {

  let tooltip = document.getElementById('scoreTooltip');

  if (!tooltip) {

    // Create tooltip if it doesn't exist

    tooltip = document.createElement('div');

    tooltip.id = 'scoreTooltip';

    tooltip.style.cssText = 'position: fixed; background: #1f2937; color: white; padding: 12px 16px; border-radius: 8px; font-size: 13px; line-height: 1.5; max-width: 280px; z-index: 10000; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: none;';

    tooltip.innerHTML = '<div style="font-weight: 700; margin-bottom: 4px;"></div><div style="opacity: 0.9;"></div>';

    document.body.appendChild(tooltip);

  }



  const titleEl = tooltip.querySelector('div:first-child');

  const textEl = tooltip.querySelector('div:last-child');



  if (titleEl) titleEl.textContent = title;

  if (textEl) textEl.textContent = text;



  tooltip.style.display = 'block';



  // Position tooltip near the element

  const rect = event.currentTarget.getBoundingClientRect();

  tooltip.style.left = (rect.left + rect.width / 2 - 140) + 'px';

  tooltip.style.top = (rect.bottom + 10) + 'px';

}



function hideTooltip() {

  const tooltip = document.getElementById('scoreTooltip');

  if (tooltip) {

    tooltip.style.display = 'none';

  }

}



// Function to update edit counter

// Helper function to get plain text from textarea or contenteditable div

function getQuickFixText(element) {

  if (!element) return '';

  // Check if it's a textarea

  if (element.tagName === 'TEXTAREA') {

    return element.value || '';

  }

  // Otherwise it's a contenteditable div

  return element.innerText || element.textContent || '';

}



function updateEditCounter() {

  const counter = document.getElementById('quickfixEditCounter');

  if (counter) {

    const editCount = window.quickfixManualEdits || 0;

    const editableElement = document.getElementById('quickfixFixedTextArea');

    const currentText = getQuickFixText(editableElement);

    const hasEdits = editableElement && currentText !== (window.quickfixOriginalFixedText || '');



    if (hasEdits && editCount > 0) {

      counter.style.display = 'block';

      counter.textContent = `ðŸ“ Manual edits detected - your changes will be included when you re-scan`;

    } else {

      counter.style.display = 'none';

    }

  }

}



// Helper function to scroll to a flagged word in the original text

function scrollToFlag(flagId) {

  const flagElement = document.getElementById(flagId);

  if (flagElement) {

    flagElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Highlight briefly

    const originalBg = flagElement.style.backgroundColor;

    flagElement.style.backgroundColor = '#fef3c7';

    flagElement.style.transition = 'background-color 0.3s';

    setTimeout(() => {

      flagElement.style.backgroundColor = originalBg;

    }, 1000);

  } else {

    console.warn('Flag element not found:', flagId);

  }

}



// Helper function to scroll to a change item in "What We Changed" section

function scrollToChangedItem(itemId) {

  const itemElement = document.getElementById(itemId);

  if (itemElement) {

    itemElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Highlight briefly

    const originalBg = itemElement.style.backgroundColor;

    const originalBorder = itemElement.style.borderColor;

    itemElement.style.backgroundColor = '#fef3c7';

    itemElement.style.borderColor = '#f59e0b';

    itemElement.style.transition = 'all 0.3s';

    setTimeout(() => {

      itemElement.style.backgroundColor = originalBg;

      itemElement.style.borderColor = originalBorder;

    }, 1000);

  } else {

    console.warn('Change item not found:', itemId);

  }

}



// Helper function to scroll from flag number in original text to corresponding item in "What We Changed"

function scrollToChangedItemFromFlag(flagNum) {

  if (window.flagToDisplayNumMap && window.flagToDisplayNumMap.has(flagNum)) {

    const displayNum = window.flagToDisplayNumMap.get(flagNum);

    scrollToChangedItem(`change-item-${displayNum}`);

  } else {

    // Flag wasn't replaced, show message

    console.log(`Flag #${flagNum} was not replaced, so it's not in the "What We Changed" list`);

  }

}



// Scroll to Text Risk Card when clicking the Text Risk score box

function scrollToTextRiskCard() {

  const textRiskCard = document.getElementById('textRiskCard');

  if (textRiskCard) {

    textRiskCard.scrollIntoView({ behavior: 'smooth', block: 'start' });

    // Highlight briefly

    const originalBg = textRiskCard.style.backgroundColor;

    const originalBorder = textRiskCard.style.borderColor;

    textRiskCard.style.transition = 'all 0.3s';

    textRiskCard.style.backgroundColor = '#d1fae5';

    textRiskCard.style.borderColor = '#10b981';

    setTimeout(() => {

      textRiskCard.style.backgroundColor = originalBg;

      textRiskCard.style.borderColor = originalBorder;

    }, 1000);

  } else {

    console.warn('Text Risk Card not found');

  }

}



// Scroll to Flag Flow Risk Card when clicking the Flag Flow Risk score box

function scrollToFlagFlowCard() {

  const flagFlowCard = document.getElementById('flagFlowScoreCard');

  if (flagFlowCard) {

    flagFlowCard.scrollIntoView({ behavior: 'smooth', block: 'start' });

    // Highlight briefly

    const originalBg = flagFlowCard.style.backgroundColor;

    const originalBorder = flagFlowCard.style.borderColor;

    flagFlowCard.style.transition = 'all 0.3s';

    flagFlowCard.style.backgroundColor = '#d1fae5';

    flagFlowCard.style.borderColor = '#10b981';

    setTimeout(() => {

      flagFlowCard.style.backgroundColor = originalBg;

      flagFlowCard.style.borderColor = originalBorder;

    }, 1000);

  } else {

    console.warn('Flag Flow Score Card not found');

  }

}



// Helper function to revert a word in the editable textarea

function revertWord(originalWord, replacedWord) {

  const editableElement = document.getElementById('quickfixFixedTextArea');

  if (!editableElement) {

    console.error('Editable element not found');

    return;

  }



  let currentText = getQuickFixText(editableElement);



  // Find and replace the replaced word with the original word

  // Use word boundaries to avoid partial matches

  const escapedReplaced = replacedWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

  const regex = new RegExp(`\\b${escapedReplaced}\\b`, 'gi');



  if (regex.test(currentText)) {

    // Replace with original word, preserving capitalization

    currentText = currentText.replace(regex, (match) => {

      // Preserve capitalization of first letter

      const wasCapitalized = match[0] === match[0].toUpperCase();

      let reverted = originalWord;

      if (wasCapitalized && reverted.length > 0) {

        reverted = reverted.charAt(0).toUpperCase() + reverted.slice(1);

      }

      return reverted;

    });



    // Update the contenteditable div with plain text (highlights will be lost, but that's okay for revert)

    editableElement.textContent = currentText;



    // Note: Can't use selectionStart/End on contenteditable divs, but we can still focus

    editableElement.focus();



    // Trigger input event for real-time visibility

    editableElement.dispatchEvent(new Event('input', { bubbles: true }));



    console.log(`âœ… Reverted "${replacedWord}" to "${originalWord}"`);

  } else {

    console.warn(`Word "${replacedWord}" not found in text`);

  }

}



function showScoreUpsellPopup(score, selectedAllFixes = false) {

  // Make this purely score-based, not dependent on flag counts

  console.log('ðŸŽ¯ showScoreUpsellPopup called with score:', score, 'selectedAllFixes:', selectedAllFixes);



  // Check if user is Pro

  const isPro = appState.isProUser || false;



  // Create modal overlay

  const modal = document.createElement('div');

  modal.id = 'scoreUpsellModal';

  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:10000;';

  document.body.classList.add('modal-open');



  const popup = document.createElement('div');

  popup.style.cssText = 'background:#fff;padding:30px;border-radius:20px;max-width:450px;width:90%;text-align:center;box-shadow:0 20px 40px rgba(0,0,0,0.3);position:relative';



  // Dynamic content based on actual flags AND score

  let headerText, bodyText, remainingText, buttonText, buttonAction;

  let useLilSusAtTop = false; // true for "Sorry bestie, that's it!" modal â€” show Lil Sus at top instead of score emoji

  let useBonusRescanModalLayout = false; // true for "You skipped some fixes" (!bonusUsed) â€” gift image, score headline, bonus rescan CTA



  // For Pro users: Different messaging (no upgrade button)

  if (isPro) {

  if (score <= 30) {

    headerText = `Nice work! You dropped to ${score}% ðŸŽ‰`;

    bodyText = `Your essay is now professor-ready.`;

    remainingText = `Your current score: <strong style="color:#00a8e8;">${score}%</strong> â€” Ready to turn it in!`;

      buttonText = `Got it ðŸ‘`;

      buttonAction = `document.getElementById('scoreUpsellModal').remove(); document.body.classList.remove('modal-open');`;

  } else if (score > 30 && score < 70) {

      if (selectedAllFixes) {

        headerText = `You applied all fixes, but score is still ${score}% ðŸ¤”`;

        bodyText = `The AI detector found more patterns. Try picking different word swaps, or edit manually and rescan to find more triggers.`;

        remainingText = `Your current score: <strong style="color:#f59e0b;">${score}%</strong> â€” Keep fixing to get it under 30%!`;

      } else {

        headerText = `Looks like you didn't use all the suggested fixes ðŸ‘€`;

        bodyText = `Try applying all the fixes, or go back and pick different word swaps. You can rescan as many times as you need with Pro.`;

        remainingText = ``;

      }

      buttonText = `Got it ðŸ‘`;

      buttonAction = `document.getElementById('scoreUpsellModal').remove(); document.body.classList.remove('modal-open');`;

    } else {

      if (selectedAllFixes) {

        headerText = `You applied all fixes, but score is still ${score}% ðŸ˜¬`;

        bodyText = `The AI detector found more patterns. Try picking different word swaps, or edit manually and rescan to find more triggers.`;

        remainingText = `Your current score: <strong style="color:#dc2626;">${score}%</strong> â€” Keep fixing to get it under 30%!`;

      } else {

        headerText = `Low-keyâ€¦ you skipped some of the best fixes ðŸ˜‚`;

        bodyText = `Try applying all the fixes, or go back and pick different word swaps. You can rescan as many times as you need with Pro.`;

        remainingText = ``;

      }

      buttonText = `Got it ðŸ‘`;

      buttonAction = `document.getElementById('scoreUpsellModal').remove(); document.body.classList.remove('modal-open');`;

    }

  } else {

    // QuickFix users: Original messaging with upgrade button

    if (score <= 30) {

      headerText = `Nice work! You dropped to ${score}% ðŸŽ‰`;

      bodyText = `Your essay is now professor-ready.`;

      remainingText = `Your current score: <strong style="color:#00a8e8;">${score}%</strong> â€” Ready to turn it in!`;

      buttonText = `ðŸ’Ž Upgrade to Pro - $9.99/mo`;

      buttonAction = `document.getElementById('scoreUpsellModal').remove(); document.body.classList.remove('modal-open'); window.open('/pro','_blank');`;

    } else if (score > 30 && score < 70) {

    if (selectedAllFixes) {

      headerText = `You applied all fixes, but score is still ${score}% ðŸ¤”`;

      bodyText = `The AI detector found more patterns after your fixes. Pro scans deeper and finds ALL triggers - then you can fix everything in one go.`;

      remainingText = `Your current score: <strong style="color:#f59e0b;">${score}%</strong> â€” Pro can help get it under 30%!`;

    } else {

      // After they used their bonus rescan and chose their own words again â€” "that's it" message

      const bonusUsed = appState.quickfixBonusRescanUsed === true;

      if (bonusUsed) {

        useLilSusAtTop = true;

        headerText = `Sorry bestie, that's it!`;

        bodyText = `That was your one bonus do-over. This is your score â€” get another QuickFix or go Pro if you want to drop it more.`;

      } else {

        useBonusRescanModalLayout = true;

        // Use dynamic score label - will be set after scoreLabel is calculated below

        bodyText = `No worries, I got a little gift for you. Bonus rescan.`;

      }

      remainingText = ``;

    }

      buttonText = `ðŸ’Ž Upgrade to Pro - Unlimited fixes at $9.99/mo`;

      buttonAction = `document.getElementById('scoreUpsellModal').remove(); document.body.classList.remove('modal-open'); window.open('/pro','_blank');`;

  } else {

    if (selectedAllFixes) {

      headerText = `You applied all fixes, but score is still ${score}% ðŸ˜¬`;

      bodyText = `The AI detector found more patterns after your fixes. Pro scans deeper and finds ALL triggers - then you can fix everything in one go.`;

      remainingText = `Your current score: <strong style="color:#dc2626;">${score}%</strong> â€” Pro can help get it under 30%!`;

    } else {

      headerText = `Low-keyâ€¦ you skipped some of the best fixes ðŸ˜‚`;

      bodyText = `QuickFix only scans once, and you didn't pick all the glow-up words - so your score stayed sus.<br><br>Need more tries? More fixes? A real score glow-up?<br><br><strong>Pro's the move â†’ see what detectors see, scan on repeat, fix it, then turn it in like a boss.</strong>`;

      remainingText = ``;

      }

      buttonText = `ðŸ’Ž Upgrade to Pro - $9.99/mo`;

      buttonAction = `document.getElementById('scoreUpsellModal').remove(); document.body.classList.remove('modal-open'); window.open('/pro','_blank');`;

    }

  }



  if (false) { // Disabled flag-based logic

    // Some flags remain for Pro

    const quickfixShown = Math.min(3, flagsFixed);

    const remaining = flagsFixed - 3;



    if (score <= 30) {

      headerText = `Nice work! You fixed ${quickfixShown} flags and dropped to ${score}% ðŸŽ‰`;

      bodyText = `But wait... there are ${remaining} MORE flags hiding! ðŸ‘€`;

      remainingText = `Your current score: <strong style="color:#00a8e8;">${score}%</strong> â€” Ready to turn it in!`;

    } else if (score > 30 && score < 70) {

      headerText = `Oof! Should've applied all fixes... ðŸ˜…`;

      bodyText = `But don't worry! You can get a FULL PRO SCAN for FREE to find ALL the flags! ðŸŽ¯`;

      remainingText = `Your current score: <strong style="color:#f59e0b;">${score}%</strong> â€” Let's get it down to <strong style="color:#00a8e8;">under 20%!</strong>`;

    } else {

      headerText = `Oof! Should've applied all fixes... ðŸ˜…`;

      bodyText = `But don't worry! You can get a FULL PRO SCAN for FREE to find ALL the flags! ðŸŽ¯`;

      remainingText = `Your current score: <strong style="color:#dc2626;">${score}%</strong> â€” Let's get it down to <strong style="color:#00a8e8;">under 20%!</strong>`;

    }

  }



  // Determine emoji and label based on score

  let scoreEmoji, scoreLabel, scoreColor;

  if (score <= 30) {

    scoreEmoji = 'âœ…';

    scoreLabel = 'Low Sus';

    scoreColor = '#2ecc71';

  } else if (score > 30 && score < 70) {

    scoreEmoji = 'ðŸ˜¬';

    scoreLabel = 'Still Mid Sus';

    scoreColor = '#fbbf24';

  } else {

    scoreEmoji = 'ðŸš¨';

    scoreLabel = 'Major Sus';

    scoreColor = '#dc2626';

  }



  // Set headerText for bonus rescan modal layout using dynamic scoreLabel

  if (useBonusRescanModalLayout) {

    // Format: "49% â€” That's Still Mid Sus" or "75% â€” That's Still Major Sus"

    const labelText = scoreLabel.includes('Still') ? scoreLabel : `Still ${scoreLabel}`;

    headerText = `${score}% â€” That's ${labelText}`;

  }



  // Only show remainingText box if it has content

  const remainingTextHtml = remainingText ? `<div style="background:#f8f9fa;border-radius:12px;padding:15px;margin:15px 0;"><p style="color:#6b7280;font-size:14px;margin:0;">${remainingText}</p></div>` : '';



  // Special case: Kinda Sus with skipped fixes - show two buttons

  const isKindaSusSkippedFixes = !isPro && score > 30 && score < 70 && !selectedAllFixes;

  const bonusUsed = appState.quickfixBonusRescanUsed === true;

  let buttonHtml = '';

  if (isKindaSusSkippedFixes && !bonusUsed) {

    buttonHtml = '<button onclick="document.getElementById(\'scoreUpsellModal\').remove(); document.body.classList.remove(\'modal-open\'); goBackToQuickFixStep2FromBonusRescan();" style="margin:8px 0; width: 100%; padding: 14px 28px; font-size: 18px; font-weight: 700; background: #22c55e; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">ðŸ”“ Get Bonus Rescan</button>' +

      '<a href="javascript:void(0)" onclick="document.getElementById(\'scoreUpsellModal\').remove(); document.body.classList.remove(\'modal-open\');" style="display:block;text-align:center;margin-top:15px;color:#6b7280;font-size:14px;text-decoration:underline;cursor:pointer">See Results First</a>';

  } else if (isKindaSusSkippedFixes && bonusUsed) {

    buttonHtml = '<button onclick="showGetAnotherQuickFixModal(); document.getElementById(\'scoreUpsellModal\').remove(); document.body.classList.remove(\'modal-open\');" style="margin:8px 0; width: 100%; padding: 12px 24px; font-size: 14px; font-weight: 700; background: #ff6b00; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">ðŸ”„ Get Another QuickFix - Fix the rest for $1.99</button>' +

      '<button onclick="document.getElementById(\'scoreUpsellModal\').remove(); document.body.classList.remove(\'modal-open\'); window.open(\'/pro\',\'_blank\');" style="margin:8px 0; width: 100%; padding: 12px 24px; font-size: 14px; font-weight: 700; background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s;">ðŸ’Ž Upgrade to Pro - Unlimited fixes at $9.99/mo</button>' +

      '<a href="javascript:void(0)" onclick="document.getElementById(\'scoreUpsellModal\').remove(); document.body.classList.remove(\'modal-open\');" style="display:block;text-align:center;margin-top:12px;color:#9ca3af;font-size:13px;text-decoration:underline;cursor:pointer">No thanks, I\'ll take the risk ðŸŽ²</a>';

  } else {

    buttonHtml = '<button class="btn-success btn-block" onclick="' + buttonAction + '" style="margin:8px 0; background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none;">' + buttonText + '</button>' +

      (isPro ? '<button onclick="editProFixes(); document.getElementById(\'scoreUpsellModal\').remove(); document.body.classList.remove(\'modal-open\');" style="margin:8px 0; background: white; color: #f5a623; border: 2px solid #f5a623; padding: 12px 24px; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; width: 100%;">âœï¸ Go Back & Edit Fixes</button>' : '<a href="javascript:void(0)" onclick="document.getElementById(\'scoreUpsellModal\').remove(); document.body.classList.remove(\'modal-open\');" style="display:block;text-align:center;margin-top:12px;color:#9ca3af;font-size:13px;text-decoration:underline;cursor:pointer">No thanks, I\'ll take the risk ðŸŽ²</a>');

  }



  const topBlock = useBonusRescanModalLayout

    ? '<div style="margin-bottom:20px;"><img src="https://i.postimg.cc/d0FGQ2jS/ls-gift.png" alt="Lil Sus Gift" style="width:120px;height:auto;display:block;margin:0 auto;"></div>'

    : useLilSusAtTop

    ? '<div style="margin-bottom:6px;"><img src="https://i.postimg.cc/Qx1xdpzM/Ls-empty-box.png" alt="Lil Sus" style="width:80px;height:auto;display:block;margin:0 auto;"></div>'

    : `<div style="font-size:36px; margin-bottom:6px;">${scoreEmoji}</div>`;

  const scoreBlockHtml = useBonusRescanModalLayout ? '' : `<div style="font-size:28px; font-weight:700; color:${scoreColor}; margin-bottom:3px;">${score}%</div>` + `<div style="font-size:14px; font-weight:600; color:#6b7280;">${scoreLabel}</div>`;

  popup.innerHTML = '<button onclick="document.getElementById(\'scoreUpsellModal\').remove(); document.body.classList.remove(\'modal-open\');" style="position:absolute;top:10px;right:10px;background:none;border:none;font-size:32px;color:#999;cursor:pointer;padding:10px 15px;line-height:1;border-radius:50%;transition:all 0.3s;margin-bottom:24px;" onmouseover="this.style.color=\'#dc2626\'; this.style.background=\'#fee2e2\';" onmouseout="this.style.color=\'#999\'; this.style.background=\'none\';">Ã—</button>' +

    '<div style="text-align:center; margin-top:24px; margin-bottom:20px;">' +

    topBlock +

    scoreBlockHtml +

    '</div>' +

    '<h2 style="margin-bottom:12px;font-size:1.4em;color:#0b0646;">' + headerText + '</h2>' +

    '<p style="color:#374151;line-height:1.5;margin-bottom:15px;font-size:0.95em;">' + bodyText + '</p>' +

    remainingTextHtml +

    buttonHtml;



  modal.appendChild(popup);

  document.body.appendChild(modal);



  // Add click-outside-to-close functionality

  modal.addEventListener('click', function(e) {

    if (e.target === modal) {

      modal.remove();

      document.body.classList.remove('modal-open');

    }

  });

}



function showQuickFixReminderModal() {

  // DISABLED: Modal removed - replaced with info box above textarea

  return;

}



// REMOVED: Old "READY TO TURN IT IN?" modal - no longer used

// Replaced with: returnToMainDashboard() to go back to input

function showFreeScanModal() {

  // Redirect to input section instead of showing old modal

  returnToMainDashboard();

}



// Show modal after first free scan (only once per day)

// TODO BEFORE LAUNCH: Re-enable once-per-day restriction by uncommenting the checks below

function showFirstScanUpsellModal() {

  // TEST MODE: Disabled once-per-day restriction for testing

  // Check if modal has already been shown today

  // const today = new Date().toDateString();

  // const firstScanModalKey = 'firstScanModalShown_' + today;

  // const firstScanModalShown = localStorage.getItem(firstScanModalKey);

  // console.log('ðŸ” Checking firstScanModalShown for today:', today, 'value:', firstScanModalShown);

  // if (firstScanModalShown === 'true') {

  //   console.log('ðŸ” Modal already shown today, skipping');

  //   return; // Don't show again today

  // }



  console.log('ðŸ” Showing first scan modal');

  // Mark as shown for today

  // localStorage.setItem(firstScanModalKey, 'true');



  const modal = document.createElement('div');

  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100vh;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;';

  document.body.classList.add('modal-open');



  const popup = document.createElement('div');

  popup.style.cssText = 'background:#fff;padding:40px;border-radius:20px;max-width:450px;width:90%;text-align:center;box-shadow:0 20px 40px rgba(0,0,0,0.3);position:relative';



  popup.innerHTML = '<button onclick="this.parentElement.parentElement.remove(); document.body.classList.remove(\'modal-open\');" style="position:absolute;top:10px;right:10px;background:none;border:none;font-size:32px;color:#999;cursor:pointer;padding:10px 15px;line-height:1;border-radius:50%;transition:all 0.3s;" onmouseover="this.style.color=\'#dc2626\'; this.style.background=\'#fee2e2\';" onmouseout="this.style.color=\'#999\'; this.style.background=\'none\';">Ã—</button>' +

    '<img src="https://i.postimg.cc/3J644Rdm/Lil-Sus-3-fingers.jpg" alt="Lil Sus" style="width:200px;height:auto;display:block;margin:0 auto 20px auto;">' +

    '<h2 style="color:#0b0646;margin:0 0 20px;font-size:1.2em;font-weight:800">3 free scans per day â€” that\'s it, fr ðŸ“„</h2>' +

    '<p style="color:#666;margin:0 0 28px;font-size:1em;line-height:1.4">Need a quick Pro-level fix?</p>' +

    '<button class="btn-secondary btn-block" onclick="this.parentElement.parentElement.remove(); document.body.classList.remove(\'modal-open\'); setTimeout(switchToQuickFix, 100);" style="margin:12px 0;font-size:1.1em;background:#ea580c;color:white;border:none;padding:12px 20px;border-radius:8px;font-weight:700;cursor:pointer;"><span style="color: #ffffff !important; display: inline-block; text-shadow: -1px -1px 0px #ffffff, 1px -1px 0px #ffffff, -1px 1px 0px #ffffff, 1px 1px 0px #ffffff, 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.6); filter: brightness(1) !important; font-weight: bold; -webkit- ">âš¡</span> QuickFix - $1.99</button>' +

    '<p style="color:#666;margin:8px 0 16px 0;font-size:0.85em;">Find and fix this essay (one-time)</p>' +

    '<button class="btn-success btn-block" onclick="this.parentElement.parentElement.remove(); document.body.classList.remove(\'modal-open\'); handleProUpgrade();" style="margin:12px 0;font-size:1.1em;background:#00a8e8;color:white;border:none;padding:12px 20px;border-radius:8px;font-weight:700;cursor:pointer;">ðŸ’Ž Pro - $9.99/mo</button>' +

    '<p style="color:#666;margin:8px 0 20px 0;font-size:0.85em;">Get best word suggestions less likely to trigger detectors â€¢ Up to 100 scans and fixes â€¢ Cancel anytime</p>' +

    '<a href="javascript:void(0)" onclick="this.parentElement.parentElement.remove(); document.body.classList.remove(\'modal-open\');" style="display:block;text-align:center;margin-top:20px;color:#9ca3af;font-size:13px;text-decoration:underline;cursor:pointer">Nah, I\'ll risk it with free</a>';



  modal.appendChild(popup);

  document.body.appendChild(modal);

  console.log('ðŸ” Modal appended to body. Modal element:', modal);

  console.log('ðŸ” Modal display style:', modal.style.display);

  console.log('ðŸ” Modal z-index:', modal.style.zIndex);

  console.log('ðŸ” Body has modal-open class:', document.body.classList.contains('modal-open'));



  modal.onclick = function (e) {

    if (e.target === modal) {

      modal.remove();

      document.body.classList.remove('modal-open');

    }

  };

}



// Show authorship confirmation modal (replaces basic alert)

function showAuthorshipConfirmationModal() {

  // Remove any existing modals

  document.querySelectorAll('.authorship-confirmation-modal').forEach(el => el.remove());



  const modal = document.createElement('div');

  modal.className = 'authorship-confirmation-modal';

  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100vh;background:rgba(0,0,0,0.7);z-index:10001;display:flex;align-items:center;justify-content:center;';

  document.body.classList.add('modal-open');



  const popup = document.createElement('div');

  popup.style.cssText = 'background:white;padding:40px;border-radius:20px;max-width:450px;width:90%;text-align:center;box-shadow:0 20px 40px rgba(0,0,0,0.3);position:relative;';



  popup.innerHTML = `

    <button onclick="this.closest('.authorship-confirmation-modal').remove(); document.body.classList.remove('modal-open');" style="position:absolute;top:12px;right:12px;background:#f3f4f6;border:2px solid #e5e7eb;font-size:24px;color:#6b7280;cursor:pointer;width:36px;height:36px;line-height:1;border-radius:50%;transition:all 0.2s;display:flex;align-items:center;justify-content:center;font-weight:300;" onmouseover="this.style.color='#dc2626'; this.style.background='#fee2e2'; this.style.borderColor='#dc2626';" onmouseout="this.style.color='#6b7280'; this.style.background='#f3f4f6'; this.style.borderColor='#e5e7eb';">Ã—</button>

    <div style="margin-bottom:20px;">

      <img src="https://i.postimg.cc/mgJmJ4M9/Lil-sus-your-Essay.png" alt="Lil Sus" style="width:80px;height:auto;display:block;margin:0 auto;">

    </div>

    <h2 style="color:#0b0646;margin:0 0 16px;font-size:24px;font-weight:800;">Ayo, Quick Auth Check</h2>

    <p style="color:#374151;margin:0 0 28px;font-size:16px;line-height:1.5;">Lemme scan this fr. Just confirm it's your original work - no AI, no cap.</p>

    <label style="display:flex;align-items:center;justify-content:center;gap:12px;padding:16px;background:#f9fafb;border:2px solid #e5e7eb;border-radius:12px;cursor:pointer;transition:all 0.2s;" onmouseover="this.style.background='#f3f4f6'; this.style.borderColor='#0b0646';" onmouseout="this.style.background='#f9fafb'; this.style.borderColor='#e5e7eb';">

      <input type="checkbox" id="modalAuthorshipCheckbox" style="width:20px;height:20px;cursor:pointer;accent-color:#0b0646;" onchange="if(this.checked) { const mainCheckbox = document.getElementById('authorshipCheckbox'); if(mainCheckbox) { mainCheckbox.checked = true; } this.closest('.authorship-confirmation-modal').remove(); document.body.classList.remove('modal-open'); }">

      <span style="color:#0b0646;font-size:18px;font-weight:700;">âœ… Yep, It's All Me</span>

    </label>

  `;



  modal.appendChild(popup);

  document.body.appendChild(modal);



  modal.onclick = function(e) {

    if (e.target === modal) {

      modal.remove();

      document.body.classList.remove('modal-open');

    }

  };



  // Escape key to close

  const handleEscape = (e) => {

    if (e.key === 'Escape') {

      modal.remove();

      document.body.classList.remove('modal-open');

      document.removeEventListener('keydown', handleEscape);

    }

  };

  document.addEventListener('keydown', handleEscape);

}



// Show modal on third scan - "almost out" warning

function showThirdScanUpsellModal() {

  console.log('ðŸ” Showing third scan modal');



  // Checkpoint: Modal function called

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'showThirdScanUpsellModal called'

    }));

  } catch (e) {}



  const modal = document.createElement('div');

  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100vh;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;';



  // Checkpoint: Before adding modal to DOM

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'Before adding modal to DOM'

    }));

  } catch (e) {}



  document.body.classList.add('modal-open');



  const popup = document.createElement('div');

  popup.style.cssText = 'background:#fff;padding:40px;border-radius:20px;max-width:450px;width:90%;text-align:center;box-shadow:0 20px 40px rgba(0,0,0,0.3);position:relative';



  popup.innerHTML = '<button onclick="this.parentElement.parentElement.remove(); document.body.classList.remove(\'modal-open\');" style="position:absolute;top:10px;right:10px;background:none;border:none;font-size:32px;color:#999;cursor:pointer;padding:10px 15px;line-height:1;border-radius:50%;transition:all 0.3s;" onmouseover="this.style.color=\'#dc2626\'; this.style.background=\'#fee2e2\';" onmouseout="this.style.color=\'#999\'; this.style.background=\'none\';">Ã—</button>' +

    '<h2 style="color:#0b0646;margin:0 0 20px;font-size:1.2em;font-weight:800">You\'ve got 1 scan left after this one ðŸ‘€</h2>' +

    '<p style="color:#666;margin:0 0 28px;font-size:1em;line-height:1.4">Then it\'s Pro time. But Pro users get 100 scans/month...</p>' +

    '<button class="btn-success btn-block" onclick="this.parentElement.parentElement.remove(); document.body.classList.remove(\'modal-open\'); handleProUpgrade();" style="margin:12px 0;font-size:1.1em;background:#00a8e8;color:white;border:none;padding:12px 20px;border-radius:8px;font-weight:700;cursor:pointer;">ðŸ’Ž Upgrade to Pro</button>' +

    '<a href="javascript:void(0)" onclick="this.parentElement.parentElement.remove(); document.body.classList.remove(\'modal-open\');" style="display:block;text-align:center;margin-top:20px;color:#9ca3af;font-size:13px;text-decoration:underline;cursor:pointer">Keep going free</a>';



  // Checkpoint: Before appendChild

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'Before appendChild modal'

    }));

  } catch (e) {}



  modal.appendChild(popup);

  document.body.appendChild(modal);



  // Checkpoint: After appendChild

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After appendChild modal - modal complete'

    }));

  } catch (e) {}



  modal.onclick = function (e) {

    if (e.target === modal) {

      modal.remove();

      document.body.classList.remove('modal-open');

    }

  };

}



// Show modal on last free scan (scan 3) - Gen Z style

// TODO BEFORE LAUNCH: Re-enable once-per-day restriction by uncommenting the checks below

function showLastScanUpsellModal() {

  // DISABLED: This modal has been removed to avoid too many modals back to back

  console.log('ðŸ” Last scan modal disabled - not showing');

  return;

}



// Show modal for "Get Another QuickFix" button

function showGetAnotherQuickFixModal() {

  const modal = document.createElement('div');

  modal.id = 'getAnotherQuickFixModal';

  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100vh;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;';

  document.body.classList.add('modal-open');



  const popup = document.createElement('div');

  popup.style.cssText = 'background:#fff;padding:30px;border-radius:20px;max-width:450px;width:90%;text-align:center;box-shadow:0 20px 40px rgba(0,0,0,0.3);position:relative';



  popup.innerHTML = '<button onclick="document.getElementById(\'getAnotherQuickFixModal\').remove(); document.body.classList.remove(\'modal-open\');" style="position:absolute;top:10px;right:10px;background:none;border:none;font-size:32px;color:#999;cursor:pointer;padding:10px 15px;line-height:1;border-radius:50%;transition:all 0.3s;" onmouseover="this.style.color=\'#dc2626\'; this.style.background=\'#fee2e2\';" onmouseout="this.style.color=\'#999\'; this.style.background=\'none\';">Ã—</button>' +

    '<div style="text-align:center;margin:0 0 16px;"><img src="https://i.postimg.cc/cLhM6zvp/lil-sus-wrench.jpg" alt="Lil Sus" style="max-width:200px;height:auto;border-radius:8px;"></div>' +

    '<h2 style="color:#0b0646;margin:0 0 12px;font-size:1.4em;font-weight:800">Need Another QuickFix?</h2>' +

    '<p style="color:#666;margin:0 0 20px;font-size:1em;line-height:1.4">Your QuickFix purchase was for one essay only. Want to scan and fix another one?</p>' +

    '<button class="btn-secondary btn-block" onclick="handleGetAnotherQuickFix();" style="margin:8px 0;font-size:1.1em;background:#ea580c;color:white;border:none;padding:12px 20px;border-radius:8px;font-weight:700;cursor:pointer;">Get Another QuickFix - $1.99</button>' +

    '<button class="btn-success btn-block" onclick="document.getElementById(\'getAnotherQuickFixModal\').remove(); document.body.classList.remove(\'modal-open\'); handleProUpgrade();" style="margin:8px 0;font-size:1.1em;background:#00a8e8;color:white;border:none;padding:12px 20px;border-radius:8px;font-weight:700;cursor:pointer;">ðŸ’Ž Go Pro - 500 Scans/Month</button>' +

    '<p style="color:#666;margin:4px 0 8px 0;font-size:0.85em;">Find ALL AI trigger words â€¢ 100 monthly scans â€¢ Cancel anytime</p>' +

    '<a href="javascript:void(0)" onclick="document.getElementById(\'getAnotherQuickFixModal\').remove(); document.body.classList.remove(\'modal-open\'); return false;" style="display:block;text-align:center;margin-top:12px;color:#9ca3af;font-size:13px;text-decoration:underline;cursor:pointer">Cancel</a>';



  modal.appendChild(popup);

  document.body.appendChild(modal);



  modal.onclick = function (e) {

    if (e.target === modal) {

      modal.remove();

      document.body.classList.remove('modal-open');

    }

  };

}





// Show QuickFix confirmation modal when clicking QuickFix from main dashboard

window.showQuickFixConfirmationModal = function showQuickFixConfirmationModal() {

  // Prevent multiple modals - check if modal already exists or is being shown

  const existingModal = document.getElementById('quickfixConfirmationModal');

  if (existingModal) {

    console.log('âš ï¸ Modal already exists, preventing duplicate');

    return;

  }



  // Also check if processing modal is showing

  const processingModal = document.getElementById('quickfixProcessingModal');

  if (processingModal) {

    console.log('âš ï¸ Processing modal is active, preventing confirmation modal');

    return;

  }



  // Prevent rapid clicks

  if (window._quickFixModalOpening) {

    console.log('âš ï¸ Modal is already opening, preventing duplicate');

    return;

  }

  window._quickFixModalOpening = true;



  const modal = document.createElement('div');

  modal.id = 'quickfixConfirmationModal';

  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100vh;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;animation:fadeIn 0.2s ease-in;';

  document.body.classList.add('modal-open');



  // Reset flag after modal is created

  setTimeout(() => {

    window._quickFixModalOpening = false;

  }, 300);



  const popup = document.createElement('div');

  popup.style.cssText = 'background:#fff;padding:30px;border-radius:20px;max-width:450px;width:90%;text-align:center;box-shadow:0 20px 40px rgba(0,0,0,0.3);position:relative';



  function closeModal() {

    const modalEl = document.getElementById('quickfixConfirmationModal');

    if (modalEl) {

      modalEl.remove();

      document.body.classList.remove('modal-open');

    }

  }



  popup.innerHTML = '<button onclick="document.getElementById(\'quickfixConfirmationModal\').remove(); document.body.classList.remove(\'modal-open\');" style="position:absolute;top:10px;right:10px;background:none;border:none;font-size:32px;color:#999;cursor:pointer;padding:10px 15px;line-height:1;border-radius:50%;transition:all 0.3s;" onmouseover="this.style.color=\'#dc2626\'; this.style.background=\'#fee2e2\';" onmouseout="this.style.color=\'#999\'; this.style.background=\'none\';">Ã—</button>' +

    '<div style="text-align:center;margin:0 0 16px;"><img src="https://i.postimg.cc/cLhM6zvp/lil-sus-wrench.jpg" alt="QuickFix" style="max-width:200px;height:auto;border-radius:8px;"></div>' +

    '<h2 style="color:#0b0646;margin:0 0 12px;font-size:1.4em;font-weight:800">Ready For A QuickFix?</h2>' +

    '<p style="color:#666;margin:0 0 20px;font-size:1em;line-height:1.4">Pro-level scan without the commitment â€” catch every AI trigger and get the best swaps to drop your score. 1,500 words, one-time unlock.</p>' +

    '<button class="btn-secondary btn-block" onclick="document.getElementById(\'quickfixConfirmationModal\').remove(); document.body.classList.remove(\'modal-open\'); appState.isQuickFixUser = true; switchToQuickFix();" style="margin:8px 0;font-size:1.1em;background:#ea580c;color:white;border:none;padding:12px 20px;border-radius:8px;font-weight:700;cursor:pointer;"><span style="color: #ffffff !important; display: inline-block; text-shadow: -1px -1px 0px #ffffff, 1px -1px 0px #ffffff, -1px 1px 0px #ffffff, 1px 1px 0px #ffffff, 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.6); filter: brightness(1) !important; font-weight: bold; -webkit- ">âš¡</span> Continue to QuickFix - $1.99</button>' +

    '<p style="color:#666;margin:8px 0 16px 0;font-size:0.85em;">One-time scan & fix</p>' +

    '<button class="btn-success btn-block" onclick="document.getElementById(\'quickfixConfirmationModal\').remove(); document.body.classList.remove(\'modal-open\'); handleProUpgrade();" style="margin:8px 0;font-size:1.1em;background:#00a8e8;color:white;border:none;padding:12px 20px;border-radius:8px;font-weight:700;cursor:pointer;">ðŸ’Ž Go Pro - $9.99/mo</button>' +

    '<p style="color:#666;margin:4px 0 8px 0;font-size:0.85em;">100 monthly scans â€¢ Cancel anytime</p>' +

    '<a href="javascript:void(0)" onclick="document.getElementById(\'quickfixConfirmationModal\').remove(); document.body.classList.remove(\'modal-open\');" style="display:block;text-align:center;margin-top:12px;color:#9ca3af;font-size:13px;text-decoration:underline;cursor:pointer">Nah, I\'ll Risk It With Free</a>';



  modal.appendChild(popup);

  document.body.appendChild(modal);



  modal.onclick = function (e) {

    if (e.target === modal) {

      closeModal();

    }

  };

}



// Handle "Get Another QuickFix" confirmation - clear form and go to QuickFix

function handleGetAnotherQuickFix() {

  // Remove modal

  const modal = document.getElementById('getAnotherQuickFixModal');

  if (modal) {

    modal.remove();

    document.body.classList.remove('modal-open');

  }



  // Clear all form inputs

  const essayInput = document.getElementById('essayInput');

  const quickfixInput = document.getElementById('quickfixEssayInput');

  if (essayInput) essayInput.value = '';

  if (quickfixInput) quickfixInput.value = '';



  // Reset counters

  const charCount = document.getElementById('charCount');

  const quickfixCharCount = document.getElementById('quickfixFlowCharCount');

  if (charCount) charCount.textContent = '0';

  if (quickfixCharCount) quickfixCharCount.textContent = '0';



  // Reset appState

  appState.quickfixOriginalText = '';

  appState.quickfixFlags = [];

  appState.quickfixOriginalScore = 0;



  // Reset authorship checkbox

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (authorshipCheckbox) authorshipCheckbox.checked = false;



  const quickfixAuthorshipCheckbox = document.getElementById('quickfixAuthorshipCheckbox');

  if (quickfixAuthorshipCheckbox) quickfixAuthorshipCheckbox.checked = false;



  // Update counter

  updateCounter();



  // Go to QuickFix step 1

  switchToQuickFix();

}



// FIXED: Simple working copy function

// Share False Flag Fixer - Opens native share dialog (Pro Low Sus Fun Fact graphic)

function shareFalseFlagFixer(event) {

  if (event) event.preventDefault();

  const shareText = "Lowkey your essay might get flagged by AI detectors for no reason ðŸ˜¬ Your friend sent you False Flag Fixer â€” CHECK IT OUT.";

  const shareUrl = window.location.origin + window.location.pathname || window.location.href;

  const shareTitle = "False Flag Fixer";



  if (navigator.share) {

    navigator.share({

      title: shareTitle,

      text: shareText,

      url: shareUrl

    }).then(function() { /* shared */ }).catch(function(err) {

      // Fallback: copy to clipboard

      navigator.clipboard.writeText(shareText + " " + shareUrl).then(function() {

        alert("Link copied to clipboard! Share it with your friends.");

      }).catch(function() {

        prompt("Copy this message to share:", shareText + " " + shareUrl);

      });

    });

  } else {

    // Fallback: copy to clipboard

    navigator.clipboard.writeText(shareText + " " + shareUrl).then(function() {

      alert("Link copied to clipboard! Share it with your friends.");

    }).catch(function() {

      prompt("Copy this message to share:", shareText + " " + shareUrl);

    });

  }

}



// FIXED: Copy QuickFix Result - Works with actual text

function copyQuickFixResult() {

  // For Clean No Sus, if no fixes were applied, use the original text

  // Otherwise use the fixed text (which should be the same as original if no flags)

  let textToCopy = appState.quickfixFixedText || appState.quickfixOriginalText || '';



  // Fallback: try to get text from the essay input or preview

  if (!textToCopy || textToCopy.trim() === '') {

    const essayInput = document.getElementById('essayInput');

    if (essayInput && essayInput.value) {

      textToCopy = essayInput.value;

    } else {

      // Try to get from essay preview content (full text, not condensed)

      // Check new container first, then old container as fallback (if it exists elsewhere)

      const freeCleanEssayContent = document.getElementById('freeCleanNoSusEssayContent');

      if (freeCleanEssayContent) {

        const previewText = freeCleanEssayContent.innerText || freeCleanEssayContent.textContent || '';

        if (previewText && previewText.length > 100) { // Make sure it's substantial text

          textToCopy = previewText.replace(/^YOUR ESSAY PREVIEW:\s*/i, '').trim();

        }

      }

    }

  }



  if (!textToCopy || textToCopy.trim() === '') {

    showSuccessMessage('âŒ No text available to copy. Please scan an essay first.', '#dc2626');

    return;

  }



  navigator.clipboard.writeText(textToCopy).then(() => {

    showSuccessMessage('âœ… Fixed essay copied to clipboard!', '#10b981');

  }).catch(err => {

    console.error('Copy failed:', err);

    showSuccessMessage('âŒ Failed to copy. Try again.', '#dc2626');

  });



  // Copy to clipboard using a more reliable method

  try {

    // Create a temporary textarea element

    const textArea = document.createElement('textarea');

    textArea.value = textToCopy;

    textArea.style.position = 'fixed';

    textArea.style.left = '-999999px';

    textArea.style.top = '-999999px';

    document.body.appendChild(textArea);

    textArea.focus();

    textArea.select();



    // Execute the copy command

    const successful = document.execCommand('copy');

    document.body.removeChild(textArea);



    if (successful) {

      showSuccessMessage('âœ… Text Copied to Clipboard');

      // Change button to green after clicking

      const copyButtons = document.querySelectorAll('button[onclick="copyQuickFixResult()"]');

      copyButtons.forEach(btn => {

        if (btn.textContent.includes('Copy Text')) {

          btn.style.background = '#2ecc71';

          btn.style.color = '#003d7a';

          btn.style.border = '2px solid #2ecc71';

        }

      });

    } else {

      showSuccessMessage('âŒ Failed to Copy');

    }

  } catch (err) {

    showSuccessMessage('âŒ Failed to Copy');

  }

}



// Copy FREE Clean No Sus essay result - Same as QuickFix but for FREE results

function copyFreeCleanNoSusResult() {

  // Get full text from data attribute (we stored it when populating the preview)

  const freeCleanNoSusEssayContent = document.getElementById('freeCleanNoSusEssayContent');

  let textToCopy = '';



  // First, try to get full text from data attribute

  if (freeCleanNoSusEssayContent) {

    textToCopy = freeCleanNoSusEssayContent.getAttribute('data-full-text') || '';

  }



  // Fallback: try to get text from the essay input or appState

  if (!textToCopy || textToCopy.trim() === '') {

    textToCopy = appState.originalText || '';

  }



  // Fallback: try essay input field

  if (!textToCopy || textToCopy.trim() === '') {

    const essayInput = document.getElementById('essayInput');

    if (essayInput && essayInput.value) {

      textToCopy = essayInput.value;

    }

  }



  // Last fallback: try to extract from preview content (remove preview heading)

  if (!textToCopy || textToCopy.trim() === '') {

    if (freeCleanNoSusEssayContent) {

      const previewText = freeCleanNoSusEssayContent.innerText || freeCleanNoSusEssayContent.textContent || '';

      // Remove "YOUR ESSAY PREVIEW:" heading if present

      textToCopy = previewText.replace(/^YOUR ESSAY PREVIEW:\s*/i, '').trim();

    }

  }



  if (!textToCopy || textToCopy.trim() === '') {

    showSuccessMessage('âŒ No essay text available to copy. Please scan an essay first.', '#dc2626');

    return;

  }



  // Get the button element to update its text

  const copyButton = document.getElementById('freeCleanNoSusCopyButton');

  const originalButtonText = copyButton ? copyButton.innerHTML.trim() : 'âœ… Copy & Turn It In';



  // Try modern clipboard API first

  navigator.clipboard.writeText(textToCopy).then(() => {

    showSuccessMessage('âœ… Essay copied to clipboard!', '#2ecc71');



    // Change button text to "Copied!" after successful copy

    if (copyButton) {

      copyButton.innerHTML = 'Copied!';

      copyButton.style.background = '#27ae60';



      // Revert button text and color after 3 seconds

      setTimeout(() => {

        copyButton.innerHTML = originalButtonText;

        copyButton.style.background = '#2ecc71';

      }, 3000);

    }

  }).catch(err => {

    console.error('Clipboard API failed, trying fallback:', err);

    // Fallback: use execCommand for older browsers

    try {

      const textArea = document.createElement('textarea');

      textArea.value = textToCopy;

      textArea.style.position = 'fixed';

      textArea.style.left = '-999999px';

      textArea.style.top = '-999999px';

      document.body.appendChild(textArea);

      textArea.focus();

      textArea.select();



      const successful = document.execCommand('copy');

      document.body.removeChild(textArea);



      if (successful) {

        showSuccessMessage('âœ… Essay Copied to Clipboard!', '#2ecc71');



        // Change button text to "Copied!" after successful copy

        if (copyButton) {

          copyButton.innerHTML = 'Copied!';

          copyButton.style.background = '#27ae60';



          // Revert button text and color after 3 seconds

          setTimeout(() => {

            copyButton.innerHTML = originalButtonText;

            copyButton.style.background = '#2ecc71';

          }, 3000);

        }

      } else {

        showSuccessMessage('âŒ Failed to copy. Please try again.', '#dc2626');

      }

    } catch (fallbackErr) {

      console.error('Fallback copy failed:', fallbackErr);

      showSuccessMessage('âŒ Failed to copy. Please try again.', '#dc2626');

    }

  });

}



// STAGE 3: Re-scan QuickFix text function

function rescanQuickFixText() {

  const editableElement = document.getElementById('quickfixFixedTextArea');

  if (!editableElement) {

    showSuccessMessage('âŒ Text area not found');

    return;

  }



  const editedText = getQuickFixText(editableElement).trim();

  if (!editedText || editedText.length < 50) {

    showSuccessMessage('âŒ Please enter at least 50 characters');

    return;

  }



  // Check if user has already used their one free re-scan (QuickFix only)

  const isPro = appState.isProUser || false;

  const hasUsedRescan = sessionStorage.getItem('quickfixRescanUsed') === 'true';



  if (!isPro && hasUsedRescan) {

    // Show modal: "You've used your one re-scan. Upgrade to Pro for unlimited scans."

    showQuickFixRescanLimitModal();

    return;

  }



  // Mark re-scan as used (for QuickFix users)

  if (!isPro) {

    sessionStorage.setItem('quickfixRescanUsed', 'true');

  }



  // Show processing modal

  showQuickFixProcessingModal();



  // Call analyze API with edited text

  const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

  const BACKEND_URL = window.BACKEND_URL || 'http://localhost:5000';

  const tier = isPro ? 'pro' : 'free';



  fetch(`${BACKEND_URL}/analyze`, {

    method: 'POST',

    headers: { 'Content-Type': 'application/json' },

    body: JSON.stringify({

      essay: editedText,

      tier: tier

    })

  })

  .then(response => response.json())

  .then(data => {

    hideQuickFixProcessingModal();



    // Update appState with new scan results

    appState.quickfixOriginalText = editedText;

    appState.quickfixFlags = data.flags || [];

    appState.quickfixOriginalScore = data.score || 0;

    appState.quickfixOriginalTextPhraseScore = data.textPhraseScore || data.score;

    appState.quickfixOriginalStructuralScore = data.structuralScore || data.score;

    // Store categorized flags from backend

    appState.quickfixTextPhraseFlags = data.textPhraseFlags || [];

    appState.quickfixStructuralFlags = data.structuralFlags || [];



    // Go back to Step 2 to show new flags

    showQuickFixStep(2);

    appState.quickfixResetOriginalText = editedText;

    appState.quickfixResetOriginalScore = data.score || 0;

    appState.quickfixResetFlagsOriginal = JSON.parse(JSON.stringify(data.flags || []));

    displayQuickFixAnalysis(editedText, data.score || 0, data.flags || []);

  })

  .catch(error => {

    console.error('Re-scan error:', error);

    hideQuickFixProcessingModal();

    showSuccessMessage('âŒ Re-scan failed. Please try again.');

  });

}



// STAGE 3: Modal for QuickFix re-scan limit

function showQuickFixRescanLimitModal() {

  const existingModal = document.getElementById('quickfixRescanLimitModal');

  if (existingModal) {

    existingModal.remove();

  }



  const modal = document.createElement('div');

  modal.id = 'quickfixRescanLimitModal';

  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:10000;';

  document.body.classList.add('modal-open');



  modal.innerHTML = `

    <div style="background:white;padding:32px;border-radius:16px;text-align:center;max-width:400px;width:90%;box-shadow:0 20px 40px rgba(0,0,0,0.3);">

      <h2 style="color:#0b0646;margin-bottom:12px;font-size:24px;font-weight:700;">One Re-scan Used</h2>

      <p style="color:#6b7280;margin-bottom:20px;font-size:16px;line-height:1.5;">

        You've used your one free re-scan. Upgrade to Pro for unlimited scans and deeper fixes.

      </p>

      <button onclick="showProUpsell(); document.getElementById('quickfixRescanLimitModal')?.remove(); document.body.classList.remove('modal-open');" style="background:#00a8e8;color:white;border:none;border-radius:8px;padding:12px 24px;font-size:16px;font-weight:700;cursor:pointer;width:100%;margin-bottom:12px;">

        â†’ Get Pro - $9.99/mo

      </button>

      <button onclick="document.getElementById('quickfixRescanLimitModal')?.remove(); document.body.classList.remove('modal-open');" style="background:white;color:#6b7280;border:1px solid #e5e7eb;border-radius:8px;padding:12px 24px;font-size:14px;font-weight:600;cursor:pointer;width:100%;">

        Cancel

      </button>

    </div>

  `;



  document.body.appendChild(modal);

}



// NEW: Send As Is function

function sendAsIs() {

  const textToCopy = appState.quickfixFixedText || appState.quickfixOriginalText || '';



  if (!textToCopy || textToCopy.trim() === '') {

    showSuccessMessage('âŒ No text to send.', '#dc2626');

    return;

  }



  navigator.clipboard.writeText(textToCopy).then(() => {

    showSuccessMessage('âœ… Text copied! You can now paste it into your assignment.', '#10b981');

  }).catch(err => {

    showSuccessMessage('âŒ Copy failed. Try again.', '#dc2626');

  });



  if (!textToCopy) {

    showSuccessMessage('âŒ No text to copy');

    return;

  }



  // Copy to clipboard

  navigator.clipboard.writeText(textToCopy).then(() => {

    showSuccessMessage('âœ… Text Copied to Clipboard');

  }).catch(() => {

    showSuccessMessage('âŒ Failed to Copy');

  });

}



function showProUpsell() {

  handleProUpgrade();

}

// Modern Gen Z-friendly authorship reminder

function showAuthorshipReminder() {

  const checkboxContainer = document.querySelector('#authorshipCheckbox').closest('div');

  if (!checkboxContainer) return;



  // Remove any existing reminder

  const existingReminder = document.getElementById('authorshipReminder');

  if (existingReminder) {

    existingReminder.remove();

  }



  // Create the reminder tooltip

  const reminder = document.createElement('div');

  reminder.id = 'authorshipReminder';

  reminder.innerHTML = `

    <div style="

      position: absolute;

      top: -50px;

      left: 0;

      right: 0;

      background: #dc2626;

      color: white;

      padding: 12px 16px;

      border-radius: 12px;

      font-size: 14px;

      font-weight: 600;

      text-align: center;

      box-shadow: 0 8px 25px rgba(220, 38, 38, 0.3);

      z-index: 1000;

      animation: slideDown 0.3s ease-out;

    ">

      <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">

        <span style="font-size: 18px;">ðŸ‘‡</span>

        <span>Hey! Check this first</span>

      </div>

      <div style="

        position: absolute;

        bottom: -8px;

        left: 50%;

        transform: translateX(-50%);

        width: 0;

        height: 0;

        border-left: 8px solid transparent;

        border-right: 8px solid transparent;

        border-top: 8px solid #dc2626;

      "></div>

    </div>

  `;



  // Add CSS animation

  if (!document.getElementById('authorshipReminderStyles')) {

    const style = document.createElement('style');

    style.id = 'authorshipReminderStyles';

    style.textContent = `

      @keyframes slideDown {

        from {

          opacity: 0;

          transform: translateY(-10px);

        }

        to {

          opacity: 1;

          transform: translateY(0);

        }

      }

      @keyframes pulse {

        0%, 100% { transform: scale(1); }

        50% { transform: scale(1.05); }

      }

    `;

    document.head.appendChild(style);

  }



  // Add pulse animation to checkbox container

  checkboxContainer.style.position = 'relative';

  checkboxContainer.style.animation = 'pulse 0.6s ease-in-out 2';

  checkboxContainer.style.transformOrigin = 'center';



  // Insert the reminder

  checkboxContainer.appendChild(reminder);



  // Auto-remove after 4 seconds

  setTimeout(() => {

    if (reminder.parentNode) {

      reminder.style.animation = 'slideDown 0.3s ease-out reverse';

      setTimeout(() => {

        if (reminder.parentNode) {

          reminder.remove();

        }

      }, 300);

    }

    checkboxContainer.style.animation = '';

  }, 4000);

}



function getDynamicMessage(score) {

  // Kinda Sus messages (30-69)

  const kindaSusMessages = [

    "Close, but let's make this chef's kiss ðŸ‘Œ",

    "You're almost there, just needs a lil finesse âœ¨",

    "Few tweaks and this goes hard ðŸ”¥",

    "One more pass and you're untouchable ðŸ’¯",

    "Nearly there, let's polish this up âš¡"

  ];



  // You're Good messages (0-29)

  const youreGoodMessages = [

    "Your writing is literally immaculate âœ¨",

    "This essay just hits different ðŸ”¥",

    "You cooked with this one fr fr ðŸ‘Œ",

    "No notes, this is pure ðŸ§¬",

    "This is giving main character energy ðŸ’…"

  ];



  // Hella Sus messages (70-100)

  const hellaSusMessages = [

    "Nah this is giving ChatGPT energy ðŸ˜¬",

    "Yeah nah, your prof's gonna catch this one ðŸš©",

    "This is sus as hell, we gotta fix it ðŸ’€",

    "Not the vibe, let's start over bestie ðŸ˜­",

    "Yo this is cooked, big yikes energy ðŸ“‰"

  ];



  let messages;

  if (score >= 70) {

    messages = hellaSusMessages;

  } else if (score >= 30) {

    messages = kindaSusMessages;

  } else {

    messages = youreGoodMessages;

  }



  // Return random message from the appropriate array

  return messages[Math.floor(Math.random() * messages.length)];

}



function getDynamicPhrase(score) {

  // You're Good phrases (0-29)

  const youreGoodPhrases = [

    "Slay",

    "Ate",

    "Bussin",

    "Unmatched",

    "Immaculate"

  ];



  // Kinda Sus phrases (30-69)

  const kindaSusPhrases = [

    "Close",

    "Almost",

    "Nearly",

    "Halfway",

    "Getting there"

  ];



  // Hella Sus phrases (70-100)

  const hellaSusPhrases = [

    "Yikes",

    "Nope",

    "Yikes",

    "Cooked",

    "Oof"

  ];



  let phrases;

  if (score >= 70) {

    phrases = hellaSusPhrases;

  } else if (score >= 30) {

    phrases = kindaSusPhrases;

  } else {

    phrases = youreGoodPhrases;

  }



  // Return random phrase from the appropriate array

  return phrases[Math.floor(Math.random() * phrases.length)];

}



// Get emoji for dynamic phrase

function getPhraseEmoji(phrase) {

  const emojiMap = {

    // You're Good phrases

    "Slay": "âœ¨",

    "Ate": "ðŸ½ï¸",

    "Bussin": "ðŸ”¥",

    "Unmatched": "ðŸ‘‘",

    "Immaculate": "ðŸ’Ž",

    // Kinda Sus phrases

    "Close": "ðŸŽ¯",

    "Almost": "ðŸ“ˆ",

    "Nearly": "âš¡",

    "Halfway": "â³",

    "Getting there": "ðŸš€",

    // Hella Sus phrases

    "Yikes": "ðŸ˜¬",

    "Nope": "ðŸš«",

    "Cooked": "ðŸ’€",

    "Oof": "ðŸ˜…"

  };

  return emojiMap[phrase] || "âœ¨";

}



function updateSusBar(score, cardType) {

  // Clamp score between 0 and 100

  const clamped = Math.max(0, Math.min(score, 100));



  // Determine which indicator to update based on card type

  let indicatorId;

  if (cardType === 'youreGood') {

    indicatorId = 'youreGoodProgressIndicator';

  } else if (cardType === 'kinda') {

    indicatorId = 'kindaSusProgressIndicator';

  } else if (cardType === 'hella') {

    indicatorId = 'hellaSusProgressIndicator';

  } else {

    // Try all indicators if cardType not specified

    indicatorId = null;

  }



  // Use the unified updateProgressIndicator function

  if (indicatorId) {

    updateProgressIndicator(clamped, indicatorId);

  } else {

    // Update all indicators

    ['youreGoodProgressIndicator', 'kindaSusProgressIndicator', 'hellaSusProgressIndicator'].forEach(id => {

      updateProgressIndicator(clamped, id);

    });

  }

}



// FIX FOR FREE RESULTS PROGRESS BAR - Uses same logic as QuickFix

function updateFreeProgressBar(score) {

  const scoreNum = Math.round(score);



  // Determine which FREE card is visible

  const hellaSusCard = document.getElementById('hellaSusCard');

  const kindaSusCard = document.getElementById('kindaSusCard');

  const youreGoodCard = document.getElementById('youreGoodCard');



  let scoreEl, fillEl, indicatorEl;



  if (hellaSusCard && hellaSusCard.style.display !== 'none') {

    scoreEl = document.getElementById('hellaSusScoreNumber');

    fillEl = document.getElementById('hellaSusProgressFill');

    indicatorEl = document.getElementById('hellaSusProgressIndicator');

  } else if (kindaSusCard && kindaSusCard.style.display !== 'none') {

    scoreEl = document.getElementById('kindaSusScoreNumber');

    fillEl = document.getElementById('kindaSusProgressFill');

    indicatorEl = document.getElementById('kindaSusProgressIndicator');

  } else if (youreGoodCard && youreGoodCard.style.display !== 'none') {

    scoreEl = document.getElementById('youreGoodScoreNumber');

    fillEl = document.getElementById('youreGoodProgressFill');

    indicatorEl = document.getElementById('youreGoodProgressIndicator');

  }



  // Update score display - USE getScoreFontColor (same as QuickFix)

  if (scoreEl) {

    scoreEl.textContent = scoreNum + '%';

    scoreEl.style.color = typeof getScoreFontColor === 'function' ? getScoreFontColor(score) : (scoreNum >= 70 ? '#dc2626' : scoreNum >= 30 ? '#f5a623' : '#2ecc71');

  }



  // Update progress fill - USE getProgressFillGradient (same as QuickFix)

  if (fillEl) {

    fillEl.style.width = scoreNum + '%';

    fillEl.style.transition = 'width 3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';

    fillEl.style.background = typeof getProgressFillGradient === 'function' ? getProgressFillGradient(score) : '#10b981';

  }



  // Update progress indicator - USE updateProgressIndicator (same as QuickFix)

  if (indicatorEl) {

    if (typeof updateProgressIndicator === 'function') {

      updateProgressIndicator(score, indicatorEl.id);

    } else {

      // Fallback positioning

      const progressBar = indicatorEl.parentElement;

      if (progressBar) {

        const barWidth = progressBar.offsetWidth || progressBar.clientWidth;

        const indicatorPosition = (scoreNum / 100) * barWidth;

        indicatorEl.style.left = indicatorPosition + 'px';



        // Set indicator color based on score

        indicatorEl.classList.remove('high-sus', 'medium-sus', 'low-sus');

        if (scoreNum >= 70) {

          indicatorEl.style.borderColor = '#dc2626';

          indicatorEl.classList.add('high-sus');

        } else if (scoreNum >= 30) {

          indicatorEl.style.borderColor = '#FFF000';

          indicatorEl.classList.add('medium-sus');

        } else {

          indicatorEl.style.borderColor = '#2ecc71';

          indicatorEl.classList.add('low-sus');

        }

      }

    }

  }



  console.log('âœ… Free progress bar updated: ' + scoreNum + '%');

}



// Animate free results progress bars (You're Good / Kinda Sus / Hella Sus)

function startProgressAnimations(score) {

  // Decide which card is currently shown

  const isYoureGood = document.getElementById('youreGoodCard')?.style.display !== 'none';

  const isKinda = document.getElementById('kindaSusCard')?.style.display !== 'none';

  const isHella = document.getElementById('hellaSusCard')?.style.display !== 'none';



  // Map to the correct elements

  let scoreEl, fillEl, indicatorId;

  if (isYoureGood) {

    scoreEl = document.getElementById('youreGoodScoreNumber');

    fillEl = document.getElementById('youreGoodProgressFill');

    indicatorId = 'youreGoodProgressIndicator';

  } else if (isKinda) {

    scoreEl = document.getElementById('kindaSusScoreNumber');

    fillEl = document.getElementById('kindaSusProgressFill');

    indicatorId = 'kindaSusProgressIndicator';

  } else if (isHella) {

    scoreEl = document.getElementById('hellaSusScoreNumber');

    fillEl = document.getElementById('hellaSusProgressFill');

    indicatorId = 'hellaSusProgressIndicator';

  }



  // Clear prior animation gate so repeat runs work

  if (scoreEl && fillEl && typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

    animatedBars.delete(scoreEl.id + fillEl.id);

  }



  // Run the shared animator (same as QuickFix) - this is the CORRECT way

  if (typeof animateProgressBar === 'function' && scoreEl && fillEl) {

    console.log('ðŸŽ¬ [FREE] Calling animateProgressBar for', scoreEl.id, 'score:', score);

    // Clear animation gate first

    if (typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

      animatedBars.delete(scoreEl.id + fillEl.id);

    }

    animateProgressBar(scoreEl, fillEl, Math.round(score));

  } else {

    // Fallback: Use updateFreeProgressBar if animateProgressBar not available

    console.log('âš ï¸ [FREE] animateProgressBar not available, using updateFreeProgressBar fallback');

    if (typeof updateFreeProgressBar === 'function') {

      updateFreeProgressBar(score);

    } else if (fillEl) {

      fillEl.style.transition = 'width 3s ease-out';

      const clampedScore = Math.max(0, Math.min(100, score));

      fillEl.style.width = clampedScore + '%';

      fillEl.style.background = typeof getProgressFillGradient === 'function' ? getProgressFillGradient(clampedScore) : '#10b981';



      // Update progress indicator

      if (indicatorId && typeof updateProgressIndicator === 'function') {

        const indicator = document.getElementById(indicatorId);

        if (indicator) {

          indicator.style.left = '0%';

          indicator.style.transition = 'left 3s ease-out';

          setTimeout(() => {

            updateProgressIndicator(clampedScore, indicatorId);

          }, 50);

        }

      }

    }

  }

}



function updateScoreLabelColor(score, labelElementId) {

  const label = document.getElementById(labelElementId);

  if (!label) return;



  // Find the corresponding score number element

  const scoreNumber = label.parentElement.querySelector('.score-number');



  label.classList.remove('sus-af', 'kinda-sus', 'sus-free');



  // Unified thresholds: 0-29 = "Low Sus", 30-69 = "Mid Sus", 70-100 = "Major Sus"

  if (score >= 70) {

    label.textContent = 'Major Sus';

    label.classList.add('sus-af');

    if (scoreNumber) scoreNumber.style.color = '#dc2626'; // Dark orange/red

  } else if (score >= 30) {

    label.textContent = 'Mid Sus';

    label.classList.add('kinda-sus');

    if (scoreNumber) scoreNumber.style.color = '#f59e0b'; // Orange to match top box border

  } else {

    label.textContent = "Low Sus";

    label.classList.add('sus-free');

    label.style.color = '#6b7280'; // GRAY

    label.style.fontSize = '14px'; // SMALLER FONT

    if (scoreNumber) scoreNumber.style.color = '#2ecc71'; // GREEN

  }

}



// Helper: progress bar fill gradient - only colors passed (green 0-30%, yellow 30-70%, red 70-100%)

function getProgressFillGradient(score) {
  const s = Math.max(0, Math.min(100, score));
  
  if (s < 30) {
    // Low Sus: Solid green
    return '#10b981';
  }
  
  if (s < 70) {
    // Mid Sus: Green -> Yellow gradient (green portion + yellow portion)
    const pctGreen = (30 / s) * 100;
    return `linear-gradient(to right, #10b981 0%, #10b981 ${pctGreen}%, #FFF000 ${pctGreen}%, #FFF000 100%)`;
  }
  
  // Major Sus (70+): Green -> Yellow -> Red gradient
  const pctGreen = (30 / s) * 100;
  const pctYellow = (70 / s) * 100;
  return `linear-gradient(to right, #10b981 0%, #10b981 ${pctGreen}%, #FFF000 ${pctGreen}%, #FFF000 ${pctYellow}%, #ef4444 ${pctYellow}%, #ef4444 100%)`;
}



// Font color for score - Kinda Sus uses #FFF000 (correct QuickFix yellow)

function getScoreFontColor(score) {

  if (score >= 70) return '#dc2626';

  if (score >= 30) return '#f5a623'; // Darker yellow for Mid Sus (matches rest of page)

  return '#2ecc71';

}



// Animate progress bar and score number

let animatedBars = new Set();



function animateProgressBar(scoreElement, fillElement, score) {

  if (!scoreElement || !fillElement) {

    console.error('âŒ animateProgressBar: Missing elements', { scoreElement, fillElement });

    return;

  }



  // Prevent duplicate animations

  const key = scoreElement.id + fillElement.id;

  if (animatedBars.has(key)) {

    console.log('â­ï¸ Progress bar already animated, skipping:', key);

    return;

  }

  animatedBars.add(key);



  console.log('ðŸŽ¬ Starting progress bar animation:', { score, key });



  // Clamp score between 0 and 100

  const clampedScore = Math.max(0, Math.min(100, score));



  // Set initial state - fill should go from 0% to score%

  fillElement.style.width = '0%';

  fillElement.style.transition = 'none'; // Remove CSS transition - we'll animate with JS



  fillElement.style.position = 'absolute';

  fillElement.style.top = '0';

  fillElement.style.left = '0%';

  fillElement.style.height = '100%';

  fillElement.style.borderRadius = '4px';



  // Animate score number and progress bar fill together from 0 to target

  let currentScore = 0;

  const targetScore = clampedScore;

  const duration = 5000; // 5 seconds (slowed down from 3s)

  const startTime = Date.now();



  function animateScore() {

    const elapsed = Date.now() - startTime;

    const progress = Math.min(elapsed / duration, 1);



    // Ease-out function

    const easeOut = 1 - Math.pow(1 - progress, 3);

    currentScore = easeOut * targetScore; // Use exact value for fill, round for display



    // Fill gradient: only colors passed (green then yellow then red)

    fillElement.style.background = getProgressFillGradient(currentScore);



    // Update percentage display - ONLY the number (no label/emoji to avoid duplication)

    if (scoreElement) {

      const roundedScore = Math.round(currentScore);

      scoreElement.style.color = getScoreFontColor(targetScore);

      scoreElement.textContent = roundedScore + '%';

      // Only update separate label element if it exists and is NOT the same element (QuickFix has quickfixScoreLabel; Free has separate label/emoji spans)

      const labelId = scoreElement.id.replace('OriginalScore', 'ScoreLabel');

      const labelEl = document.getElementById(labelId);

      if (labelEl && labelEl !== scoreElement) {

        let emoji = '';

        let label = '';

        if (targetScore >= 70) {

          emoji = 'ðŸš¨';

          label = 'Major Sus';

        } else if (targetScore >= 30) {

          emoji = 'âš ï¸';

          label = 'Mid Sus';

        } else {

          emoji = 'âœ…';

          label = 'Low Sus';

        }

        labelEl.textContent = label + ' ' + emoji;

        labelEl.style.display = 'block';

        labelEl.style.color = getScoreFontColor(targetScore);

      }

    }



    // Update progress bar fill width (exact same value and rate as percentage)

    fillElement.style.width = currentScore + '%';



    // White bobble glued to end of fill - position at end of filled portion

    const indicatorId = fillElement.id.replace('ProgressFill', 'ProgressIndicator');

    const indicator = document.getElementById(indicatorId);

    if (indicator) {

      const progressBar = fillElement.parentElement;

      if (progressBar) {

        const barWidth = progressBar.offsetWidth || progressBar.clientWidth;

        const indicatorPosition = (currentScore / 100) * barWidth;

        indicator.style.left = indicatorPosition + 'px';

        indicator.style.display = 'block';

        indicator.style.visibility = 'visible';

        indicator.style.opacity = '1';

        indicator.style.zIndex = '10';

      }

    }



    if (progress < 1) {

      requestAnimationFrame(animateScore);

    } else {

      // Ensure final values match exactly - score element ONLY the number

      fillElement.style.background = getProgressFillGradient(targetScore);

      if (scoreElement) {

        const roundedScore = Math.round(targetScore);

        scoreElement.style.color = getScoreFontColor(targetScore);

        scoreElement.textContent = roundedScore + '%';

        const labelId = scoreElement.id.replace('OriginalScore', 'ScoreLabel');

        const labelEl = document.getElementById(labelId);

        if (labelEl && labelEl !== scoreElement) {

          let emoji = '';

          let label = '';

          if (targetScore >= 70) {

            emoji = 'ðŸš¨';

            label = 'Major Sus';

          } else if (targetScore >= 30) {

            emoji = 'âš ï¸';

            label = 'Mid Sus';

          } else {

            emoji = 'âœ…';

            label = 'Low Sus';

          }

          labelEl.textContent = label + ' ' + emoji;

          labelEl.style.display = 'block';

          labelEl.style.color = getScoreFontColor(targetScore);

        }

      }

      fillElement.style.width = targetScore + '%';

      console.log('âœ… Progress bar animated to:', targetScore + '%', 'fill width:', targetScore + '%');

    }

  }



  // Start animations

  requestAnimationFrame(animateScore);



  // Update progress indicator - ensure it's visible and positioned correctly

  const indicatorId = fillElement.id.replace('ProgressFill', 'ProgressIndicator');

  const indicator = document.getElementById(indicatorId);

  if (indicator) {

    // Make sure indicator is visible

    indicator.style.display = 'block';

    indicator.style.visibility = 'visible';

    indicator.style.opacity = '1';

    indicator.style.zIndex = '10';



    // Reset indicator to 0 first, then animate to score

    indicator.style.left = '0px';



    // Update border color based on score

    indicator.classList.remove('high-sus', 'medium-sus', 'low-sus');

    if (clampedScore >= 70) {

      indicator.classList.add('high-sus');

      indicator.style.borderColor = '#dc2626';

    } else if (clampedScore >= 30) {

      indicator.classList.add('medium-sus');

      indicator.style.borderColor = '#FFF000';

    } else {

      indicator.classList.add('low-sus');

      indicator.style.borderColor = '#2ecc71';

    }



    // Animate indicator position

    setTimeout(() => {

      updateProgressIndicator(clampedScore, indicatorId);

    }, 100);

  }

}



function updateProgressIndicator(score, indicatorId) {

  // Default to Step 2 indicator if no ID specified (for backward compatibility)

  const id = indicatorId || 'quickfixProgressIndicator';

  const indicator = document.getElementById(id);

  if (!indicator) {

    console.log('âš ï¸ Progress indicator not found:', id);

    return;

  }



  // Reset classes

  indicator.classList.remove('high-sus', 'medium-sus', 'low-sus');



  // CRITICAL: Make sure indicator is visible and animates

  indicator.style.display = 'block';

  indicator.style.opacity = '1';

  indicator.style.visibility = 'visible';

  indicator.style.zIndex = '10';

  indicator.style.transition = 'left 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';



  // Update border color based on score

  if (score >= 70) {

    indicator.classList.add('high-sus');

    indicator.style.borderColor = '#dc2626';

  } else if (score >= 30) {

    indicator.classList.add('medium-sus');

    indicator.style.borderColor = '#FFF000';

  } else {

    indicator.classList.add('low-sus');

    indicator.style.borderColor = '#2ecc71';

  }



  // Set position based on score - use pixels for accurate positioning

  const progressBar = indicator.parentElement;

  if (progressBar) {

    const barWidth = progressBar.offsetWidth || progressBar.clientWidth;

    const indicatorPosition = (score / 100) * barWidth;

    indicator.style.left = indicatorPosition + 'px';

    console.log('âœ… Progress indicator updated:', id, 'to', indicatorPosition, 'px (score:', score + '%, barWidth:', barWidth + ')');

  } else {

    // Fallback to percentage if parent not found

    indicator.style.left = score + '%';

    console.log('âš ï¸ Progress bar parent not found, using percentage:', score + '%');

  }



  // Set color based on score tier

  if (score >= 71) {

    indicator.classList.add('high-sus');

  } else if (score >= 31) {

    indicator.classList.add('medium-sus');

  } else {

    indicator.classList.add('low-sus');

  }

}



function updateWarningMessage(score, containerId, titleId, subtitleId) {

  const container = document.getElementById(containerId);

  const title = document.getElementById(titleId);

  const subtitle = document.getElementById(subtitleId);



  if (!container || !title || !subtitle) return;



  // Always show the container

  container.style.display = 'block';



  if (score <= 30) {

    // You're Good - Ready To Turn In

    title.textContent = 'âœ… Ready To Turn In';

    title.style.color = '#00a8e8'; // Green

    subtitle.textContent = 'But if you want your score even lower, consider fixing the trigger words below';

    subtitle.style.display = 'block';

  } else if (score >= 31 && score < 60) {

    // Kinda Sus - Almost there

    title.textContent = 'âš ï¸ Almost There';

    title.style.color = '#eed202'; // Warning yellow

    subtitle.textContent = 'A few more fixes and you\'ll be in the clear. Let\'s make it perfect!';

    subtitle.style.display = 'block';

  } else {

    // Hella Sus - Don't turn it in yet

    title.textContent = 'âœ‹ Don\'t Turn It In Yet';

    title.style.color = '#00a8e8'; // Blue

    subtitle.textContent = 'Your essay needs some fixes before it\'s safe to submit';

    subtitle.style.display = 'block';

  }

}



// Display Essay Preview with Dynamic Borders and Highlighting

// flagsToHighlight: MAX 5 flags to highlight in the essay (should match trigger chips)

// allFlagsForNumbering: All flags used to determine numbering (should be previewFlags, max 5)

function displayEssayPreview(essayText, score, flagsToHighlight) {

  // Determine which essay container to use based on score

  let essayPreviewId, essayTextId;

  if (score >= 70) {

    essayPreviewId = 'hellaSusEssayPreview';

    essayTextId = 'hellaSusEssayText';

  } else if (score >= 30) {

    essayPreviewId = 'kindaSusEssayPreview';

    essayTextId = 'kindaSusEssayText';

  } else {

    return; // No essay preview for Clean/No Sus

  }



  console.log('displayEssayPreview called with score:', score);

  console.log('Looking for essayPreviewId:', essayPreviewId, 'essayTextId:', essayTextId);

  const testEl = document.getElementById(essayPreviewId);

  console.log('Found element:', testEl);

  if (!testEl) {

    console.log('Element NOT found. Available elements with "essay":', 

      Array.from(document.querySelectorAll('[id*="essay"]')).map(el => el.id));

  }



  // Now use essayPreviewId and essayTextId instead of hardcoded 'essayPreview' and 'essayPreviewText'

  const essayPreview = document.getElementById(essayPreviewId);

  const essayPreviewText = document.getElementById(essayTextId);



  if (!essayPreview || !essayPreviewText) {

    console.warn('âš ï¸ Essay preview elements not found for score:', score, 'IDs:', essayPreviewId, essayTextId);

    return;

  }



  // Show the appropriate essay preview container and hide the other

  if (score >= 70) {

    // Show Hella Sus, hide Kinda Sus

    const kindaSusPreview = document.getElementById('kindaSusEssayPreview');

    if (kindaSusPreview) kindaSusPreview.style.display = 'none';

    essayPreview.style.display = 'block';

  } else if (score >= 30) {

    // Show Kinda Sus, hide Hella Sus

    const hellaSusPreview = document.getElementById('hellaSusEssayPreview');

    if (hellaSusPreview) hellaSusPreview.style.display = 'none';

    essayPreview.style.display = 'block';

  }



  // Determine border color based on score

  let borderColor = '#2ecc71'; // Green for Clean (0-29%)

  if (score >= 70) {

    borderColor = '#dc2626'; // Red for Hella Sus (70%+)

  } else if (score >= 30) {

    borderColor = '#eed202'; // Yellow for Kinda Sus (30-69%)

  }



  // Update border colors

  essayPreview.style.borderLeftColor = borderColor;

  essayPreview.style.borderRightColor = borderColor;



  // Get first 5-8 lines (~300-400 chars) for display

  const lines = essayText.split('\n');

  const firstLines = lines.slice(0, 8).join('\n');

  let previewText = firstLines.length > 400 ? firstLines.substring(0, 400) + '...' : firstLines;



  // LIMIT TO MAX 5 FLAGS

  const MAX_FLAGS = 5;

  const limitedFlags = (flagsToHighlight || []).slice(0, MAX_FLAGS);



  // CRITICAL: Find positions in FULL TEXT (not preview) to match trigger chip numbering

  // Then only highlight what appears in the preview

  const allOccurrences = [];

  limitedFlags.forEach((flag) => {

    const phrase = (flag.phrase || flag.text || '').trim();

    if (!phrase) return;



    const escapedPhrase = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    const regex = new RegExp(escapedPhrase, 'gi');

    let match;

    regex.lastIndex = 0;



    // Find FIRST occurrence in FULL TEXT (to match trigger chip logic)

    const fullTextMatch = regex.exec(essayText);

    if (fullTextMatch) {

      allOccurrences.push({

        phrase: phrase,

        phraseLower: phrase.toLowerCase(),

        position: fullTextMatch.index, // Position in full text

        length: fullTextMatch[0].length

      });

    }

  });



  // Sort by position (ORDER OF APPEARANCE IN TEXT)

  allOccurrences.sort((a, b) => a.position - b.position);



  // Remove overlapping (keep first)

  const nonOverlapping = [];

  const usedPositions = new Set();

  allOccurrences.forEach(occ => {

    let overlaps = false;

    for (let i = occ.position; i < occ.position + occ.length; i++) {

      if (usedPositions.has(i)) {

        overlaps = true;

        break;

      }

    }

    if (!overlaps) {

      nonOverlapping.push(occ);

      for (let i = occ.position; i < occ.position + occ.length; i++) {

        usedPositions.add(i);

      }

    }

  });



  // Limit to MAX 5 and number 1, 2, 3, 4, 5 in order

  const finalOccurrences = nonOverlapping.slice(0, 5);

  const phraseToNumber = new Map();

  const phraseFirstOccurrence = new Map(); // Track first occurrence of each phrase

  let currentNumber = 1;



  // Assign numbers to first occurrence of each unique phrase

  finalOccurrences.forEach((occ, index) => {

    if (!phraseFirstOccurrence.has(occ.phraseLower)) {

      phraseFirstOccurrence.set(occ.phraseLower, index);

      phraseToNumber.set(occ.phraseLower, currentNumber);

      currentNumber++;

    }

  });



  // Highlight phrases with numbers 1-5 in ORDER OF APPEARANCE

  // Only first occurrence gets a number, duplicates get yellow highlight only

  if (finalOccurrences.length > 0) {

    // Sort by length (longest first) to avoid partial matches when highlighting

    const sortedByLength = [...finalOccurrences].sort((a, b) => b.length - a.length);



    let highlightedHTML = previewText;



    // Track occurrence count for each phrase

    const occurrenceCount = {};



    sortedByLength.forEach((occ) => {

      const phrase = occ.phrase;

      const phraseLower = occ.phraseLower;

      const flagNumber = phraseToNumber.get(phraseLower) || null;



      // Initialize occurrence count for this phrase

      if (!occurrenceCount[phraseLower]) {

        occurrenceCount[phraseLower] = 0;

      }



      const escapedPhrase = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

      const regex = new RegExp(escapedPhrase, 'gi');



      // Replace all occurrences, tracking which one it is

      highlightedHTML = highlightedHTML.replace(regex, (match) => {

        // Skip if already wrapped in a span (already highlighted)

        if (match.includes('<span')) return match;



        // Increment occurrence count for this phrase

        occurrenceCount[phraseLower]++;

        const isFirstOccurrence = occurrenceCount[phraseLower] === 1;



        // First occurrence = bright yellow (#FFF000), duplicates = light yellow (#FFFACD)

        const highlightBg = isFirstOccurrence ? '#FFF000' : '#FFFACD';



        // Only add number badge for first occurrence

        const numberBadge = (isFirstOccurrence && flagNumber !== null) 

          ? `<span style="background: #FFFACD; color: #dc2626; border-radius: 50%; width: 14px; height: 14px; display: inline-flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; margin-right: 2px; vertical-align: middle;">${flagNumber}</span>`

          : '';



        const highlightStyle = `background: ${highlightBg}; border: none; padding: 2px 5px; margin: 0; border-radius: 4px; font-weight: 600; font-size: 11px; color: #0b0646; display: inline-block; line-height: 1.2;`;



        return `<span style="${highlightStyle}">${numberBadge}${match}</span>`;

      });

    });



    essayPreviewText.innerHTML = highlightedHTML;

  } else {

    essayPreviewText.textContent = previewText;

  }



  console.log('âœ… Essay preview: MAX 5 flags, numbered 1-' + finalOccurrences.length + ' in order of appearance');

}



// Make displayEssayPreview globally accessible

window.displayEssayPreview = displayEssayPreview;



// FIXED TOOLTIP FUNCTIONS - WORKING PROPERLY

function showTooltip(event, message) {

  let tooltip = document.getElementById('tooltip');

  if (!tooltip) {

    tooltip = document.createElement('div');

    tooltip.id = 'tooltip';

    tooltip.className = 'tooltip';

    document.body.appendChild(tooltip);

  }



  tooltip.innerHTML = message;

  tooltip.classList.add('show');



  // Position tooltip near cursor

  const x = event.clientX + 15;

  const y = event.clientY + 15;



  tooltip.style.left = x + 'px';

  tooltip.style.top = y + 'px';

}



function hideTooltip() {

  // Hide tooltip using the global variable (if it exists)

  if (typeof tooltip !== 'undefined' && tooltip) {

    tooltip.classList.remove('show');

    tooltip.style.display = 'none';

  }



  // Hide tooltip by ID

  const tooltipById = document.getElementById('tooltip');

  if (tooltipById) {

    tooltipById.classList.remove('show');

    tooltipById.style.display = 'none';

  }



  // Also hide any tooltips with the .tooltip class that are showing

  const allTooltips = document.querySelectorAll('.tooltip.show');

  allTooltips.forEach(tt => {

    tt.classList.remove('show');

    tt.style.display = 'none';

  });

}



// NEW: Better tooltip system using data attributes

function initTooltips() {

  const tooltipElements = document.querySelectorAll('[data-tooltip]');



  tooltipElements.forEach(element => {

    element.addEventListener('mouseenter', function(e) {

      // Check if authorship checkbox is checked before showing tooltip

      const authorshipCheckbox = document.getElementById('authorshipCheckbox');

      if (authorshipCheckbox && !authorshipCheckbox.checked) {

        return; // Hide tooltip if checkbox is not checked

      }



      const message = this.getAttribute('data-tooltip');

      showTooltip(e, message);

    });



    element.addEventListener('mouseleave', hideTooltip);

    element.addEventListener('mousemove', function(e) {

      const tooltip = document.getElementById('tooltip');

      if (tooltip && tooltip.classList.contains('show')) {

        tooltip.style.left = (e.clientX + 15) + 'px';

        tooltip.style.top = (e.clientY + 15) + 'px';

      }

    });

  });



  // FIX 5: Add progress bar tooltips

  const progressLabels = document.querySelectorAll('.progress-labels span');

  progressLabels.forEach((label, index) => {

    let tooltipText = '';

    if (index === 0) tooltipText = "Low Sus = Human AF";

    if (index === 1) tooltipText = 'Mid Sus = Might pass, might not';

    if (index === 2) tooltipText = 'Major Sus = Robot vibes detected';



    label.setAttribute('data-tooltip', tooltipText);

    label.style.cursor = 'help';



    label.addEventListener('mouseenter', function(e) {

      showTooltip(e, tooltipText);

    });



    label.addEventListener('mouseleave', hideTooltip);

  });

}



// Canvas confetti burst for Low Sus celebration (QuickFix Step 3 / QF Low Sus Step 1)

// originElement: optional DOM element or selector - confetti bursts from this element's center (e.g. the Low Sus card)

function showCanvasConfetti(originElement) {

  const canvas = document.createElement('canvas');

  canvas.style.position = 'fixed';

  canvas.style.top = '0';

  canvas.style.left = '0';

  canvas.style.width = '100%';

  canvas.style.height = '100%';

  canvas.style.pointerEvents = 'none';

  canvas.style.zIndex = '9999';

  document.body.appendChild(canvas);



  canvas.width = window.innerWidth;

  canvas.height = window.innerHeight;

  const ctx = canvas.getContext('2d');



  let originX = canvas.width / 2;

  let originY = canvas.height / 2;

  const el = typeof originElement === 'string' ? document.querySelector(originElement) : originElement;

  if (el) {

    const rect = el.getBoundingClientRect();

    originX = rect.left + rect.width / 2;

    originY = rect.top + rect.height / 2;

  }



  const particles = [];

  const colors = ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];



  for (let i = 0; i < 150; i++) {

    const angle = (Math.PI * 2 * i) / 150;

    const velocity = 3 + Math.random() * 5;

    particles.push({

      x: originX,

      y: originY,

      vx: Math.cos(angle) * velocity,

      vy: Math.sin(angle) * velocity - 2,

      color: colors[Math.floor(Math.random() * colors.length)],

      size: 4 + Math.random() * 4,

      rotation: Math.random() * 360,

      rotationSpeed: (Math.random() - 0.5) * 10

    });

  }



  function runAnimation() {

    ctx.clearRect(0, 0, canvas.width, canvas.height);



    particles.forEach(function(p) {

      p.x += p.vx;

      p.y += p.vy;

      p.vy += 0.15;

      p.rotation += p.rotationSpeed;



      ctx.save();

      ctx.translate(p.x, p.y);

      ctx.rotate((p.rotation * Math.PI) / 180);

      ctx.fillStyle = p.color;

      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);

      ctx.restore();

    });



    for (let i = particles.length - 1; i >= 0; i--) {

      if (particles[i].y > canvas.height + 50) particles.splice(i, 1);

    }



    if (particles.length > 0) {

      requestAnimationFrame(runAnimation);

    } else {

      canvas.remove();

    }

  }



  runAnimation();

}



// Share False Flag Fixer - opens native share dialog (Pro Low Sus Fun Fact graphic)

function shareFalseFlagFixer(event) {

  const shareText = 'Lowkey your essay might get flagged by AI detectors for no reason ðŸ˜¬ Your friend sent you False Flag Fixer â€” CHECK IT OUT.';

  const shareUrl = window.location.origin + window.location.pathname || window.location.href;



  if (navigator.share) {

    navigator.share({

      title: 'False Flag Fixer',

      text: shareText,

      url: shareUrl

    }).then(function() {

      console.log('Share successful');

    }).catch(function(err) {

      console.log('Share cancelled or failed:', err);

      copyShareTextFallback(shareText + ' ' + shareUrl);

    });

  } else {

    copyShareTextFallback(shareText + ' ' + shareUrl);

  }

  if (event) event.preventDefault();

  return false;

}

function copyShareTextFallback(text) {

  navigator.clipboard.writeText(text).then(function() {

    if (typeof showStyledAlert === 'function') {

      showStyledAlert('Copied to clipboard! Share it with your friends.');

    } else {

      alert('Copied to clipboard! Share it with your friends.');

    }

  }).catch(function() {

    if (typeof showStyledAlert === 'function') {

      showStyledAlert('Share link: ' + text);

    } else {

      prompt('Copy this to share:', text);

    }

  });

}



// FIXED: Success Message with Dynamic Color Theming

function showSuccessMessage(message, color = '#00a8e8') {

  return; // Disabled - no longer showing popups

}



// Styled Alert Modal - Replaces browser alert() with styled modal

function showStyledAlert(message) {

  // Remove any existing styled alert

  const existing = document.getElementById('styledAlertModal');

  if (existing) existing.remove();



  // Determine if this is QuickFix or Pro based on context

  // Check if we're in QuickFix flow (Step 2 or Step 4) vs Pro flow

  const isQuickFix = document.getElementById('quickfixStep2') || 

                     document.getElementById('quickfixStep4') ||

                     (window.location.hash && window.location.hash.includes('quickfix')) ||

                     !appState.isProUser;



  // Set colors: Orange for QuickFix, Blue for Pro

  const headerGradient = isQuickFix 

    ? 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)'  // Orange

    : 'linear-gradient(135deg, #00a8e8 0%, #0087c4 100%)';  // Blue

  const buttonGradient = isQuickFix

    ? 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)'  // Orange

    : 'linear-gradient(135deg, #00a8e8 0%, #0087c4 100%)';  // Blue

  const buttonShadow = isQuickFix

    ? '0 4px 12px rgba(249, 115, 22, 0.25)'  // Orange shadow

    : '0 4px 12px rgba(0, 168, 232, 0.25)';  // Blue shadow

  const buttonHoverShadow = isQuickFix

    ? '0 6px 16px rgba(249, 115, 22, 0.4)'  // Orange hover shadow

    : '0 6px 16px rgba(0, 168, 232, 0.4)';  // Blue hover shadow



  // Create modal overlay

  const modalOverlay = document.createElement('div');

  modalOverlay.id = 'styledAlertModal';

  modalOverlay.style.cssText = `

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background: rgba(0, 0, 0, 0.6);

    z-index: 10002;

    display: flex;

    align-items: center;

    justify-content: center;

    padding: 20px;

    animation: fadeIn 0.3s ease;

  `;



  // Create modal content

  const modalContent = document.createElement('div');

  modalContent.style.cssText = `

    background: white;

    border-radius: 20px;

    max-width: 400px;

    width: 100%;

    padding: 0;

    position: relative;

    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);

    animation: slideUp 0.3s ease;

  `;



  // Create modal header

  const modalHeader = document.createElement('div');

  modalHeader.style.cssText = `

    background: ${headerGradient};

    color: white;

    padding: 24px 30px;

    text-align: center;

    border-radius: 20px 20px 0 0;

    font-size: 20px;

    font-weight: 700;

  `;

  modalHeader.textContent = 'âš ï¸ Select a Fix';



  // Create modal body

  const modalBody = document.createElement('div');

  modalBody.style.cssText = `

    padding: 30px;

    text-align: center;

    color: #374151;

    font-size: 16px;

    line-height: 1.6;

  `;

  modalBody.textContent = message;



  // Create OK button

  const okButton = document.createElement('button');

  okButton.style.cssText = `

    background: ${buttonGradient};

    color: white;

    border: none;

    border-radius: 8px;

    padding: 12px 32px;

    font-size: 16px;

    font-weight: 700;

    cursor: pointer;

    margin: 0 auto 20px;

    display: block;

    transition: transform 0.2s, box-shadow 0.2s;

    box-shadow: ${buttonShadow};

  `;

  okButton.textContent = 'OK';

  okButton.onmouseover = function() {

    this.style.transform = 'translateY(-2px)';

    this.style.boxShadow = buttonHoverShadow;

  };

  okButton.onmouseout = function() {

    this.style.transform = 'translateY(0)';

    this.style.boxShadow = buttonShadow;

  };

  okButton.onclick = function() {

    modalOverlay.style.animation = 'fadeOut 0.3s ease';

    modalContent.style.animation = 'slideDown 0.3s ease';

    setTimeout(() => {

      if (modalOverlay.parentNode) {

        modalOverlay.remove();

      }

    }, 300);

  };



  // Close on overlay click

  modalOverlay.onclick = function(e) {

    if (e.target === modalOverlay) {

      okButton.click();

    }

  };



  // Assemble modal

  modalContent.appendChild(modalHeader);

  modalContent.appendChild(modalBody);

  modalContent.appendChild(okButton);

  modalOverlay.appendChild(modalContent);

  document.body.appendChild(modalOverlay);



  // Focus the button for keyboard accessibility

  okButton.focus();

}



// Display urgent trigger warning card with actual flag words

function displayUrgentTriggerWarning(flagCount, flagList) {

  const warningCard = document.getElementById('urgentTriggerWarningCard');

  if (!warningCard) {

    console.warn('âš ï¸ urgentTriggerWarningCard not found');

    return;

  }



  // Build the flag pill list - show up to 3 flags

  const flagsToShow = flagList.slice(0, 3);

  const flagPills = flagsToShow

    .map((flag, idx) => {

      const phrase = flag.phrase || flag.text || flag.word || '';

      if (!phrase) return '';

      return `<span style="

        background: #fee2e2;

        border: 1px solid #dc2626;

        color: #991b1b;

        padding: 4px 10px;

        border-radius: 20px;

        font-size: 12px;

        font-weight: 600;

        display: inline-block;

        margin: 4px 4px 4px 0;

      ">${idx + 1}. ${phrase}</span>`;

    })

    .filter(pill => pill !== '')

    .join('');



  // Show "+X more" if there are more than 3 flags

  const moreCount = flagCount > 3 ? flagCount - 3 : 0;

  const moreText = moreCount > 0 ? `<span style="font-size: 12px; color: #991b1b; font-weight: 600; margin-left: 8px;">+${moreCount} more</span>` : '';



  warningCard.innerHTML = `

    <div style="

      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);

      border: 2px solid #dc2626;

      border-radius: 12px;

      padding: 20px;

      text-align: center;

      margin: 20px 0;

      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.2);

    ">

      <div style="

        font-size: 24px;

        font-weight: 800;

        color: #dc2626;

        margin-bottom: 8px;

      ">ðŸš¨ ${flagCount} AI RED FLAGS DETECTED</div>



      <div style="

        font-size: 14px;

        color: #991b1b;

        margin-bottom: 12px;

        font-weight: 600;

      ">These words will get you caught</div>



      <div style="margin: 12px 0; line-height: 1.8;">

        ${flagPills}${moreText}

      </div>



      <div style="

        font-size: 12px;

        color: #991b1b;

        margin-top: 12px;

        font-style: italic;

      ">â†“ Unlock QuickFix or Pro to see all locations â†“</div>

    </div>

  `;



  warningCard.style.display = 'block';

  warningCard.style.visibility = 'visible';

  warningCard.style.opacity = '1';

  console.log('âœ… Urgent trigger warning displayed with', flagsToShow.length, 'flags');

}



// FIX 6: Updated Scan New Text Function with Pro Upsell

// FIXED: Scan New Text Function - PROPERLY RESETS AND RETURNS TO INPUT

// FIXED: Scan New Text Function - PROPERLY RESETS AND RETURNS TO INPUT (Free + QuickFix)

// CRITICAL: Cleanup function to clear all background processes

function cleanupBackgroundProcesses() {

  // CRITICAL: Abort local detection if in progress

  if (window._localDetectionAbortController) {

    try {

      window._localDetectionAbortController.abort();

      console.log('âœ… Aborted local detection in cleanupBackgroundProcesses');

    } catch (e) {

      console.warn('âš ï¸ Error aborting local detection:', e);

    }

    window._localDetectionAbortController = null;

  }



  // CRITICAL: Clear local detection timeout

  if (window._localDetectionTimeout) {

    clearTimeout(window._localDetectionTimeout);

    window._localDetectionTimeout = null;

  }



  // Clear all stored intervals

  if (window.messageRotationInterval) {

    clearInterval(window.messageRotationInterval);

    window.messageRotationInterval = null;

  }

  if (window.cleanMessageRotationInterval) {

    clearInterval(window.cleanMessageRotationInterval);

    window.cleanMessageRotationInterval = null;

  }

  if (window.headerRotationInterval) {

    clearInterval(window.headerRotationInterval);

    window.headerRotationInterval = null;

  }

  if (window._rotationInterval) {

    clearInterval(window._rotationInterval);

    window._rotationInterval = null;

  }

  if (window.scanTimerInterval) {

    clearInterval(window.scanTimerInterval);

    window.scanTimerInterval = null;

  }

  if (window._headingInterval) {

    clearInterval(window._headingInterval);

    window._headingInterval = null;

  }

  if (window._cleanHeadingInterval) {

    clearInterval(window._cleanHeadingInterval);

    window._cleanHeadingInterval = null;

  }

  if (window._zeroBoxInterval) {

    clearInterval(window._zeroBoxInterval);

    window._zeroBoxInterval = null;

  }

  if (window._extraFlagsInterval) {

    clearInterval(window._extraFlagsInterval);

    window._extraFlagsInterval = null;

  }

  if (window._chipsHintInterval) {

    clearInterval(window._chipsHintInterval);

    window._chipsHintInterval = null;

  }



  console.log('âœ… Cleaned up all background processes');

}



function scanNewText() {

  console.log('ðŸ”„ scanNewText() called - DISCONNECTING ALL OBSERVERS AND INTERVALS');



  // CRITICAL: Kill all MutationObservers from previous scan

  // Store observers in a global array for cleanup

  if (!window._activeObservers) {

    window._activeObservers = [];

  }



  // Disconnect all stored observers

  window._activeObservers.forEach(observer => {

    try {

      observer.disconnect();

      console.log('âœ… Disconnected observer');

    } catch (e) {

      console.warn('âš ï¸ Error disconnecting observer:', e);

    }

  });

  window._activeObservers = []; // Clear the array



  // Also try to disconnect observers stored on elements

  try {

    const allElements = document.querySelectorAll('*');

    for (let i = 0; i < Math.min(allElements.length, 100); i++) { // Limit to 100 to prevent blocking

      const el = allElements[i];

      if (el._observer) {

        try {

          el._observer.disconnect();

          el._observer = null;

        } catch (e) {}

      }

    }

  } catch (e) {

    console.warn('âš ï¸ Error disconnecting element observers:', e);

  }



  // CRITICAL: Kill all interval-based observers

  if (window._headingInterval) {

    clearInterval(window._headingInterval);

    window._headingInterval = null;

  }

  if (window._cleanHeadingInterval) {

    clearInterval(window._cleanHeadingInterval);

    window._cleanHeadingInterval = null;

  }

  if (window._chipsHintInterval) {

    clearInterval(window._chipsHintInterval);

    window._chipsHintInterval = null;

  }

  if (window._extraFlagsInterval) {

    clearInterval(window._extraFlagsInterval);

    window._extraFlagsInterval = null;

  }

  if (window._cleanMessageInterval) {

    clearInterval(window._cleanMessageInterval);

    window._cleanMessageInterval = null;

  }

  if (window.messageRotationInterval) {

    clearInterval(window.messageRotationInterval);

    window.messageRotationInterval = null;

  }

  if (window.cleanMessageRotationInterval) {

    clearInterval(window.cleanMessageRotationInterval);

    window.cleanMessageRotationInterval = null;

  }



  console.log('âœ… All observers and intervals killed');



  // CRITICAL: Clear animatedBars Set so progress bars can re-animate on next scan

  if (typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

    animatedBars.clear();

    console.log('âœ… Cleared animatedBars Set for fresh animations');

  }



  // CRITICAL: Clean up background processes

  cleanupBackgroundProcesses();



  // CRITICAL: Clear ALL retry timeouts that might be running in background

  if (window._essayRetryTimeouts && Array.isArray(window._essayRetryTimeouts)) {

    window._essayRetryTimeouts.forEach(timeoutId => {

      clearTimeout(timeoutId);

    });

    window._essayRetryTimeouts = [];

    console.log('âœ… Cleared all essay retry timeouts');

  }



  // CRITICAL: Abort any ongoing API requests

  if (window._currentAbortController) {

    window._currentAbortController.abort();

    window._currentAbortController = null;

    console.log('âœ… Aborted ongoing API request');

  }



  // CRITICAL: Clear ALL intervals that might be running

  if (window.scanTimerInterval) {

    clearInterval(window.scanTimerInterval);

    window.scanTimerInterval = null;

    console.log('âœ… Cleared scan timer interval');

  }



  // Clear all other intervals that might be running

  if (window._headingInterval) {

    clearInterval(window._headingInterval);

    window._headingInterval = null;

  }

  if (window._cleanHeadingInterval) {

    clearInterval(window._cleanHeadingInterval);

    window._cleanHeadingInterval = null;

  }

  if (window._zeroBoxInterval) {

    clearInterval(window._zeroBoxInterval);

    window._zeroBoxInterval = null;

  }

  if (window._extraFlagsInterval) {

    clearInterval(window._extraFlagsInterval);

    window._extraFlagsInterval = null;

  }

  if (window._chipsHintInterval) {

    clearInterval(window._chipsHintInterval);

    window._chipsHintInterval = null;

  }

  if (window._rotationInterval) {

    clearInterval(window._rotationInterval);

    window._rotationInterval = null;

  }



  console.log('âœ… Cleared all intervals');



  // CRITICAL: Reset all button states IMMEDIATELY - before anything else

  const scanButton = document.getElementById('scanButton');

  if (scanButton) {

    // Stop any timer updates by setting a flag FIRST

    scanButton.dataset.scanning = 'false';



    // FORCE clear the button text immediately - use multiple methods

    scanButton.textContent = '';

    scanButton.innerHTML = '';



    // Reset all properties

    scanButton.disabled = false;

    scanButton.classList.remove('scanning-button');

    scanButton.style.background = '';

    scanButton.style.color = '';

    scanButton.style.cursor = '';

    scanButton.style.pointerEvents = '';



    // Set new button text - force it (show current scans used, not +1)

    const scansUsed = window.getScansUsed ? window.getScansUsed() : 0;

    scanButton.innerHTML = `ðŸ” Free Scan (<span id="scanCounter">${scansUsed}/50</span>)`;



    // Double-check it's not "Scanning..." - if it is, force reset again

    setTimeout(() => {

      if (scanButton && (scanButton.innerHTML.includes('Scanning...') || scanButton.textContent.includes('Scanning...'))) {

        console.log('âš ï¸ Button still shows Scanning after reset, forcing again...');

        scanButton.dataset.scanning = 'false';

        scanButton.textContent = '';

        scanButton.innerHTML = `ðŸ” Free Scan (<span id="scanCounter">${scansUsed}/50</span>)`;

      }

    }, 100);



    console.log('âœ… Reset scanButton to:', scanButton.innerHTML);

  }



  // Reset "Scan Another Essay" button - check ALL instances

  const scanAnotherBtn = document.getElementById('scanAnotherEssayBtn');

  if (scanAnotherBtn) {

    scanAnotherBtn.disabled = false;

    scanAnotherBtn.innerHTML = 'ðŸ“ Scan Another Essay';

    scanAnotherBtn.style.opacity = '1';

    scanAnotherBtn.style.cursor = 'pointer';

    scanAnotherBtn.style.background = '';

    scanAnotherBtn.style.color = '';

    scanAnotherBtn.classList.remove('scanning-button');

    console.log('âœ… Reset scanAnotherEssayBtn');

  }



  // Also reset any other buttons that might have "Scanning..." text

  const allButtons = document.querySelectorAll('button');

  allButtons.forEach(btn => {

    const btnText = btn.innerHTML || btn.textContent || '';

    if (btnText.includes('Scanning...') || btnText.includes('Scanning your essay')) {

      console.log('âš ï¸ Found button with Scanning text:', btn.id || btn.className, btnText.substring(0, 30));

      btn.disabled = false;

      btn.classList.remove('scanning-button');

      btn.style.background = '';

      btn.style.color = '';

      btn.style.cursor = '';

      btn.style.pointerEvents = '';

      // Reset to default based on button type

      if (btn.id === 'scanButton') {

        const scansUsed = window.getScansUsed ? window.getScansUsed() : 0;

        btn.innerHTML = `ðŸ” Free Scan (<span id="scanCounter">${scansUsed + 1}/50</span>)`;

      } else if (btn.id === 'scanAnotherEssayBtn' || btnText.includes('Scan Another Essay')) {

        btn.innerHTML = 'ðŸ“ Scan Another Essay';

  } else {

        // Generic reset for any other button

        btn.innerHTML = btn.innerHTML.replace(/ðŸ” Scanning[^<]*/g, 'ðŸ” Scan');

      }

    }

  });



  // CRITICAL: Close all modals and remove modal-open class FIRST

  document.body.classList.remove('modal-open');



  // Remove any open modals

  const allModals = document.querySelectorAll('[style*="position:fixed"], .modal, [id*="Modal"], [id*="modal"]');

  allModals.forEach(modal => {

    if (modal.style && (modal.style.position === 'fixed' || modal.style.zIndex > 1000)) {

      modal.remove();

    }

  });



  // Reset QuickFix state

  appState.quickfixOriginalText = '';

  appState.quickfixFlags = [];

  appState.quickfixOriginalScore = 0;

  appState.quickfixFixedText = '';

  appState.quickfixNewScore = 0;

  appState.isQuickFixUser = false;



  // Reset Free scan state

  appState.flagData = [];

  appState.currentScore = 0;

  appState.originalText = '';

  appState.apiResponse = null;



  // CRITICAL: Clear any pending API abort controller

  if (window._currentAbortController) {

    try {

      window._currentAbortController.abort();

    } catch (e) {}

    window._currentAbortController = null;

  }



  // CRITICAL FIX: Disable all transitions to prevent blocking when switching from Hella Sus â†’ Clean

  // This prevents CSS transitions from blocking the UI thread during view switching

  const resultsContainer = document.getElementById('resultsContainer');

  const inputSection = document.getElementById('inputSection');

  const lockbox = document.getElementById('lockbox');



  // Disable transitions on all elements that might have them

  if (resultsContainer) {

    resultsContainer.style.transition = 'none';

    resultsContainer.style.display = 'none';

    resultsContainer.classList.remove('show');

  }



  if (inputSection) {

    inputSection.style.transition = 'none';

    inputSection.style.display = 'block';

  }



  if (lockbox) {

    lockbox.style.transition = 'none';

  }



  // Hide QuickFix flow

  const quickfixFlow = document.getElementById('quickfixFlow');

  if (quickfixFlow) {

    quickfixFlow.style.transition = 'none';

    quickfixFlow.style.display = 'none';

  }



  // Re-enable transitions after a short delay to allow instant view switch

  setTimeout(() => {

    if (resultsContainer) resultsContainer.style.transition = '';

    if (inputSection) inputSection.style.transition = '';

    if (lockbox) lockbox.style.transition = '';

    if (quickfixFlow) quickfixFlow.style.transition = '';

  }, 100);



  // Clear all inputs

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    essayInput.value = '';

    if (typeof updateCounter === 'function') {

      updateCounter();

    }

  }



  const quickfixInput = document.getElementById('quickfixEssayInput');

  if (quickfixInput) {

    quickfixInput.value = '';

  }



  // Reset authorship checkbox

      const authorshipCheckbox = document.getElementById('authorshipCheckbox');

      if (authorshipCheckbox) {

        authorshipCheckbox.checked = false;

  }



  // Reset QuickFix step

  if (typeof showQuickFixStep === 'function') {

    showQuickFixStep(1);

  }



  // Scroll to input

  if (inputSection) {

    inputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

  }



  // Final cleanup - ensure body is not stuck

  setTimeout(() => {

    document.body.classList.remove('modal-open');

  }, 100);

}



// NEW: Clear form and return to top function

function clearFormAndReturnToTop() {

  switchToInput();



  const panicBanner = document.getElementById('panicBanner');

  if (panicBanner) panicBanner.style.display = 'none';



  // Clear all form inputs

  const essayInput = document.getElementById('essayInput');

  if (essayInput) essayInput.value = '';

  const quickfixInput = document.getElementById('quickfixEssayInput');

  if (quickfixInput) quickfixInput.value = '';



  // Reset counters

  const charCount = document.getElementById('charCount');

  if (charCount) charCount.textContent = '0';

  const quickfixCharCount = document.getElementById('quickfixFlowCharCount');

  if (quickfixCharCount) quickfixCharCount.textContent = '0';



  // Uncheck authorship checkbox

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (authorshipCheckbox) {

    authorshipCheckbox.checked = false;

  }



  // CRITICAL FIX: Reset scanning button state before calling updateCounter()

  const scanButton = document.getElementById('scanButton');

  if (scanButton) {

    // Clear any scanning timer interval

    if (window.scanTimerInterval) {

      clearInterval(window.scanTimerInterval);

      window.scanTimerInterval = null;

    }



    // CRITICAL: Set data-scanning to false FIRST

    scanButton.dataset.scanning = 'false';



    // Remove scanning class/styles

    scanButton.classList.remove('scanning-button');

    scanButton.disabled = false;

    scanButton.style.background = '';

    scanButton.style.color = '';

    scanButton.style.cursor = '';

    scanButton.style.pointerEvents = 'auto';

    scanButton.style.opacity = '1';



    // Force reset button text - set it immediately so it's never blank

    const scansUsed = getScansUsed();

    const TEST_SCAN_LIMIT = 50;

    scanButton.innerHTML = `ðŸ” Free Scan (<span id="scanCounter">${scansUsed}/${TEST_SCAN_LIMIT}</span>)`;

    scanButton.setAttribute('onclick', 'handleScanClick(event);');



    console.log('âœ… scanNewText: Button reset - data-scanning:', scanButton.dataset.scanning, 'disabled:', scanButton.disabled);

  }



  // Hide scanning modal if it exists

  hideScanningModal();



  // Update counter and scans display to ensure everything is synced

  updateCounter();

  updateScansDisplay();



  // Scroll to top of form

  const inputSection = document.getElementById('inputSection');

  if (inputSection) inputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });



  // Form cleared - no message needed

}





// Character limit popup functions

function showCharacterLimitModal() {

  const essayInputEl = document.getElementById('essayInput');

  const charCount = essayInputEl ? essayInputEl.value.length : 0;



  // Use the existing essayTooLongModal instead of creating a new one

  const modal = document.getElementById('essayTooLongModal');

  if (!modal) {

    console.error('âŒ essayTooLongModal not found');

    return;

  }



  // Update the character count in the modal

  const charCountEl = document.getElementById('essayTooLongCharCount');

  if (charCountEl) {

    charCountEl.textContent = charCount.toLocaleString();

  }



  // Show the modal

  modal.style.display = 'flex';

  document.body.classList.add('modal-open');



  // Add click-outside-to-close functionality (only add listener once)

  const existingListener = modal.getAttribute('data-listener-added');

  if (!existingListener) {

  modal.addEventListener('click', function(e) {

    // Close if clicking on the backdrop (not on the modal content)

    if (e.target === modal) {

        modal.style.display = 'none';

        document.body.classList.remove('modal-open');

      }

    });

    modal.setAttribute('data-listener-added', 'true');

  }

}



function hideCharacterLimitModal() {

  // Try the old modal first (for backward compatibility)

  const oldModal = document.getElementById('characterLimitModal');

  if (oldModal) {

    oldModal.remove();

    document.body.classList.remove('modal-open');

    return;

  }



  // Otherwise, hide the essayTooLongModal

  const modal = document.getElementById('essayTooLongModal');

  if (modal) {

    modal.style.display = 'none';

    document.body.classList.remove('modal-open');

  }

}



// Handle Free Scan button click

function handleFreeScan() {

  const essayInput = document.getElementById('essayInput');

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');



  if (!essayInput || !authorshipCheckbox) return;



  const text = essayInput.value.trim();

  const len = text.length;



  // Check authorship (should already be checked due to button state, but double-check)

  if (!authorshipCheckbox.checked) {

    showAuthorshipReminder();

    return;

  }



  // Check minimum length (should already be valid, but double-check)

  if (len < appState.minChars) {

    showSuccessMessage('Please paste at least 50 characters to continue.');

    return;

  }



  // Free Scan logic: â‰¤ 500 chars â†’ scan directly, > 500 chars â†’ show upgrade modal

  if (len <= 500) {

    // Scan directly - no modal needed

    scanEssay();

  } else {

    // Show upgrade modal

    showCharacterLimitModal();

  }

}



function trimTextAndScanFree() {

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    // CRITICAL: Reset scan state before trimming

    window._scanInProgress = false;

    console.log('âœ… Reset _scanInProgress flag before trimming');



    // Reset scan button state

    const scanButton = document.getElementById('scanButton');

    if (scanButton) {

      scanButton.disabled = false;

      scanButton.setAttribute('data-scanning', 'false');

      scanButton.textContent = scanButton.getAttribute('data-original-text') || 'Free Scan';

    }



    // Trim text to 500 characters

    const trimmedText = essayInput.value.substring(0, 500);

    essayInput.value = trimmedText;

    // Update counter immediately to reflect trimmed length

    const charCount = document.getElementById('charCount');

    if (charCount) {

      charCount.textContent = trimmedText.length;

    }

    // Update counter function to sync everything

    updateCounter();

    // Hide modal

    hideCharacterLimitModal();

    // Scroll back to input section

    const inputSection = document.getElementById('inputSection');

    if (inputSection) {

      inputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

    }

    // Show success message

    showSuccessMessage('Text trimmed to 500 characters. Click "Free Scan" to continue! ðŸ“');

    // DO NOT automatically scan - let user click Free Scan button manually

  }

}



// Handle QuickFix button click from upgrade modal

function handleModalQuickFix() {

  // Authorship already confirmed (shown in modal)

  hideCharacterLimitModal();

  // Preserve text and redirect to QuickFix page

  appState.isQuickFixUser = true;

  switchToQuickFix();

}



// Handle Pro button click from upgrade modal

function handleModalPro() {

  // Authorship already confirmed (shown in modal)

  hideCharacterLimitModal();

  // Preserve text and redirect to Pro dashboard

  switchToPro();

}



// ===== WORKING DRAG & DROP FUNCTIONALITY =====

function handleDragOver(event) {

  event.preventDefault();

  event.stopPropagation();

  event.dataTransfer.dropEffect = 'copy';

  const uploadArea = event.currentTarget;

  uploadArea.style.backgroundColor = '#f0f9ff';

  uploadArea.style.borderColor = '#2ecc71';

  uploadArea.style.borderWidth = '3px';

}



function handleDragEnter(event) {

  event.preventDefault();

  event.stopPropagation();

  const uploadArea = event.currentTarget;

  uploadArea.style.backgroundColor = '#f0f9ff';

  uploadArea.style.borderColor = '#2ecc71';

  uploadArea.style.borderWidth = '3px';

}



function handleDragLeave(event) {

  event.preventDefault();

  event.stopPropagation();

  // Only reset if leaving the upload area itself, not its children

  if (event.currentTarget === event.target) {

    const uploadArea = event.currentTarget;

    uploadArea.style.backgroundColor = '';

    uploadArea.style.borderColor = '';

    uploadArea.style.borderWidth = '';

  }

}

function handleFileDrop(event) {

  event.preventDefault();

  event.stopPropagation();



  const uploadArea = event.currentTarget;

  uploadArea.style.backgroundColor = '';

  uploadArea.style.borderColor = '';

  uploadArea.style.borderWidth = '';



  const files = event.dataTransfer.files;



  if (files.length === 0) {

    showSuccessMessage('No files found');

    return;

  }



  const file = files[0];



  // Accept text files and documents

  const acceptedTypes = [

    'text/plain',

    'application/msword',

    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',

    'text/html',

    'application/rtf'

  ];



  const acceptedExtensions = ['.txt', '.doc', '.docx', '.pdf', '.rtf'];



  const isAcceptedType = acceptedTypes.includes(file.type) || 

    acceptedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));



  if (!isAcceptedType) {

    showSuccessMessage('Please upload a text file (.txt) or Word document (.doc/.docx)');

    return;

  }



  const reader = new FileReader();



  reader.onload = function(e) {

    try {

      const text = e.target.result;

      const essayInput = document.getElementById('essayInput');



      if (essayInput) {

        essayInput.value = text;

        updateCounter();

        showSuccessMessage('âœ… File uploaded successfully! ' + Math.round(text.length) + ' characters');

      }

    } catch (error) {

      console.error('Error processing file:', error);

      showSuccessMessage('âŒ Error reading file');

    }

  };



  reader.onerror = function() {

    showSuccessMessage('âŒ Error reading file. Please try again.');

  };



  // Handle PDF files specially

  if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {

    showSuccessMessage('PDF files require special processing. Please convert to .txt or .docx first.');

    return;

  }



  reader.readAsText(file);

}



// Handle file selection from file input

function handleFileSelect(event) {

  const file = event.target.files[0];

  if (!file) return;



  console.log('File selected:', file.name, file.type);



  // Accept text files and documents

  const acceptedTypes = [

    'text/plain',

    'application/msword',

    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',

    'text/html',

    'application/rtf'

  ];



  const acceptedExtensions = ['.txt', '.doc', '.docx', '.pdf', '.rtf'];



  const isAcceptedType = acceptedTypes.includes(file.type) || 

    acceptedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));



  if (!isAcceptedType) {

    showSuccessMessage('Please upload a text file (.txt) or Word document (.doc/.docx)');

    return;

  }



  const reader = new FileReader();



  reader.onload = function(e) {

    try {

      const text = e.target.result;

      const essayInput = document.getElementById('essayInput');



      if (essayInput) {

        essayInput.value = text;

        updateCounter();

        showSuccessMessage('âœ… File uploaded successfully! ' + Math.round(text.length) + ' characters');

      }

    } catch (error) {

      console.error('Error processing file:', error);

      showSuccessMessage('âŒ Error reading file');

    }

  };



  reader.onerror = function() {

    showSuccessMessage('âŒ Error reading file. Please try again.');

  };



  // Handle PDF files specially

  if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {

    showSuccessMessage('PDF files require special processing. Please convert to .txt or .docx first.');

    return;

  }



  reader.readAsText(file);

}



// Handle file selection for Pro dashboard

function handleProFileSelect(event) {

  const file = event.target.files[0];

  if (!file) return;



  console.log('Pro file selected:', file.name, file.type);



  // Accept text files and documents

  const acceptedTypes = [

    'text/plain',

    'application/msword',

    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',

    'text/html',

    'application/rtf'

  ];



  const acceptedExtensions = ['.txt', '.doc', '.docx', '.pdf', '.rtf'];



  const isAcceptedType = acceptedTypes.includes(file.type) || 

    acceptedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));



  if (!isAcceptedType) {

    showSuccessMessage('Please upload a text file (.txt) or Word document (.doc/.docx)');

    return;

  }



  const reader = new FileReader();



  reader.onload = function(e) {

    try {

      const text = e.target.result;

      const proInput = document.getElementById('proScanInput');



      if (proInput) {

        // Limit to 1,500 words for Pro

        const limitedText = text.substring(0, 50000);

        proInput.value = limitedText;



        // Update character counter

        const charCount = document.getElementById('proCharCount');

        if (charCount) {

          charCount.textContent = `${limitedText.length.toLocaleString()} / 1,500`;

        }



        // Update button state

        if (typeof updateProScanButtonState === 'function') {

          updateProScanButtonState();

        }



        const message = limitedText.length < text.length 

          ? `âœ… File uploaded! (${limitedText.length.toLocaleString()} characters - truncated to 1,500 word limit)`

          : `âœ… File uploaded successfully! ${limitedText.length.toLocaleString()} characters`;

        showSuccessMessage(message);

      }

    } catch (error) {

      console.error('Error processing file:', error);

      showSuccessMessage('âŒ Error reading file');

    }

  };



  reader.onerror = function() {

    showSuccessMessage('âŒ Error reading file. Please try again.');

  };



  // Handle PDF files specially

  if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {

    showSuccessMessage('PDF files require special processing. Please convert to .txt or .docx first.');

    return;

  }



  reader.readAsText(file);

}



// Expose to window

window.handleProFileSelect = handleProFileSelect;



// FIXED: Initialize everything when page loads

// Toggle score info box

function initScoreInfoToggle() {

  const toggle = document.getElementById('scoreInfoToggle');

  const content = document.getElementById('scoreInfoContent');

  const arrow = document.getElementById('scoreInfoArrow');



  if (toggle && content && arrow) {

    toggle.addEventListener('click', function() {

      const isOpen = content.style.display !== 'none';



      if (isOpen) {

        // Close

        content.style.animation = 'slideUpInfo 0.3s ease';

        setTimeout(() => {

          content.style.display = 'none';

          arrow.style.transform = 'rotate(0deg)';

        }, 300);

      } else {

        // Open

        content.style.display = 'block';

        content.style.animation = 'slideDownInfo 0.3s ease';

        arrow.style.transform = 'rotate(180deg)';

      }

    });

  }

}



document.addEventListener('DOMContentLoaded', function() {

  // EMERGENCY: Unblock clicks immediately if page is stuck

  console.log('ðŸš¨ Checking for stuck modals/overlays...');

  document.body.classList.remove('modal-open');

  document.body.style.overflow = '';

  document.body.style.pointerEvents = 'auto';

  document.querySelectorAll('[id*="modal"], [class*="overlay"]').forEach(el => {

    const style = window.getComputedStyle(el);

    if ((style.position === 'fixed' || parseInt(style.zIndex) > 1000) && style.display !== 'none') {

      el.style.display = 'none';

      el.remove();

      console.log('âœ… Removed blocking element:', el.id || el.className);

    }

  });



  // CRITICAL: Clear ALL textareas to remove any placeholder/default text

  const allTextareas = document.querySelectorAll('textarea');

  allTextareas.forEach(ta => {

    if (ta && ta.value && ta.value.trim().length > 0) {

      // Only clear if it contains actual text (not just whitespace)

      // Check if it's placeholder text or default text

      const value = ta.value.trim();

      const isPlaceholderText = value.includes("In today's rapidly evolving") || 

                                value.includes("organizations must leverage") ||

                                value.includes("cutting-edge technologies") ||

                                value.includes("cutting-edge technology landscape");

      if (isPlaceholderText) {

        console.log('ðŸ—‘ï¸ Removing placeholder/default text from textarea:', ta.id);

        ta.value = '';

      }

    }

  });



  // Also clear any contenteditable divs that might have default text

  const contentEditableDivs = document.querySelectorAll('[contenteditable="true"]');

  contentEditableDivs.forEach(div => {

    if (div && (div.textContent || div.innerHTML)) {

      const text = (div.textContent || div.innerText || '').trim();

      const isPlaceholderText = text.includes("In today's rapidly evolving") || 

                                text.includes("organizations must leverage") ||

                                text.includes("cutting-edge technologies");

      if (isPlaceholderText) {

        console.log('ðŸ—‘ï¸ Removing placeholder/default text from contenteditable div:', div.id);

        div.textContent = '';

        div.innerHTML = '';

      }

    }

  });



  // CRITICAL: Force hide ALL tooltips immediately on page load

  const allTooltipSelectors = [

    '#tooltip',

    '.tooltip',

    '.tooltip.show',

    '[id*="tooltip"]',

    '[class*="tooltip"]',

    '#scoreTooltip',

    '#triggerTooltip',

    '#falseFlowTooltip',

    '.tooltip-text-desktop'

  ];



  allTooltipSelectors.forEach(selector => {

    try {

      const elements = document.querySelectorAll(selector);

      elements.forEach(el => {

        if (el) {

          el.classList.remove('show');

          el.style.display = 'none';

          el.style.visibility = 'hidden';

          el.style.opacity = '0';

          el.style.pointerEvents = 'none';

        }

      });

    } catch (e) {}

  });



  // Initialize score info toggle

  initScoreInfoToggle();

  console.log('=== DOM LOADED - INITIALIZING EVENT LISTENERS ===');



  // CRITICAL: Handle Pro user CTAs on page load

  // Use setTimeout to ensure appState is initialized

  setTimeout(() => {

    if (typeof handleProUserCTAs === 'function') {

      handleProUserCTAs();

    }

    // Update test mode toggle button

    if (typeof updateTestModeToggle === 'function') {

      updateTestModeToggle();

    }

  }, 100);



  // AUTO-RECOVERY: Periodic check for stuck scan button (every 3 seconds)

  // This ensures users never get stuck - button auto-resets if stuck for too long

  let stuckButtonCheckCount = 0;

  let lastButtonState = null;

  setInterval(() => {

    const btn = document.getElementById('scanButton');

    if (!btn) return;



    // Check multiple indicators of "stuck" state

    const isStuck = (

      btn.innerHTML.includes('Scanning...') || 

      btn.textContent.includes('Scanning...') ||

      (btn.disabled && btn.dataset.scanning === 'true') ||

      (btn.disabled && btn.style.cursor === 'wait')

    );



    if (isStuck) {

      // Check if button state has changed (if it changed, reset counter)

      const currentState = btn.innerHTML + btn.disabled;

      if (currentState !== lastButtonState) {

        stuckButtonCheckCount = 0; // Reset if state changed

        lastButtonState = currentState;

      } else {

        stuckButtonCheckCount++;

      }



      // If button has been stuck for 2 consecutive checks (6 seconds), auto-reset

      if (stuckButtonCheckCount >= 2) {

        console.error('ðŸ”§ AUTO-RECOVERY: Scan button stuck for 6+ seconds, FORCE RESETTING...');

        // Abort any pending API requests

        if (window._currentAbortController) {

          try { 

            window._currentAbortController.abort(); 

            console.log('âœ… Aborted pending API request');

          } catch (e) {

            console.error('Error aborting request:', e);

          }

          window._currentAbortController = null;

        }

        // Clear timer

        if (window.scanTimerInterval) {

          clearInterval(window.scanTimerInterval);

          window.scanTimerInterval = null;

          console.log('âœ… Cleared scan timer interval');

        }

        // Clear animatedBars

        if (typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

          animatedBars.clear();

        }

        // FORCE reset button

        btn.dataset.scanning = 'false';

        btn.disabled = false;

        btn.classList.remove('scanning-button');

        btn.style.background = '#2ecc71';

        btn.style.color = 'white';

        btn.style.cursor = 'pointer';

        btn.style.pointerEvents = 'auto';

        btn.style.opacity = '1';

        const scansUsed = window.getScansUsed ? window.getScansUsed() : 0;

        btn.innerHTML = `ðŸ” Free Scan (<span id="scanCounter">${scansUsed}/50</span>)`;

        stuckButtonCheckCount = 0;

        lastButtonState = null;

        // Show error message to user

        if (typeof showSuccessMessage === 'function') {

          showSuccessMessage('Scan timed out. Please try again.', '#dc2626');

        }

        console.log('âœ… Button force reset complete');

      }

    } else {

      // Button is not stuck, reset counter

      stuckButtonCheckCount = 0;

      lastButtonState = null;

    }

  }, 3000); // Check every 3 seconds (faster detection)



  // CRITICAL: Clear any stuck messages and tooltips from previous sessions

  if (typeof clearAllMessages === 'function') {

    clearAllMessages();

  } else {

    // Fallback if function not loaded yet

    const stuckMessages = document.querySelectorAll('#successMessage, .success-message, [id*="Message"]');

    stuckMessages.forEach(msg => {

      // Don't remove rotatingCleanMessage or the main free warning box/text -

      // these are part of the results UI (not "stuck" messages)

      if (

        msg.id !== 'rotatingCleanMessage' && msg.id !== 'chatMessages' &&

        msg.id !== 'freeWarningMessageBox' &&

        msg.id !== 'freeWarningMessageText' &&

        msg.id !== 'urgencyWarningMessage' &&

        msg.id !== 'cantDecideMessage' &&

        msg.id !== 'quickfixCleanNoSusLilSusMessage' &&

        msg.id !== 'quickfixCleanNoSusCtaUndertext' &&

        msg.id !== 'qfLowSusFyiBestieBlock'

      ) {

      console.log('ðŸ—‘ï¸ Removing stuck message:', msg.id || msg.className);

      msg.remove();

      }

    });



    // Also clear any messages that might be in the body

    const allMessages = document.body.querySelectorAll('div[id*="message"], div[class*="message"], div[id*="Message"], div[class*="Message"]');

    allMessages.forEach(msg => {

      // Don't remove rotatingCleanMessage or the main free warning box/text

      if (

        msg.id !== 'rotatingCleanMessage' && msg.id !== 'chatMessages' &&

        msg.id !== 'freeWarningMessageBox' &&

        msg.id !== 'freeWarningMessageText' &&

        msg.id !== 'urgencyWarningMessage' &&

        msg.id !== 'cantDecideMessage' &&

        msg.id !== 'quickfixCleanNoSusLilSusMessage' &&

        msg.id !== 'quickfixCleanNoSusCtaUndertext' &&

        msg.id !== 'qfLowSusFyiBestieBlock' &&

        (msg.id === 'successMessage' || msg.classList.contains('tooltip') || msg.style.position === 'fixed')

      ) {

        console.log('ðŸ—‘ï¸ Removing stuck message element:', msg.id || msg.className);

        msg.remove();

      }

    });

  }



  // CRITICAL: Clear stuck tooltips (but only if they're clearly stuck, not active ones)

  // Delay slightly to avoid interfering with active tooltips

  setTimeout(() => {

    if (typeof clearAllTooltips === 'function') {

      clearAllTooltips();

    } else {

      // Fallback: only remove tooltips that are clearly stuck (have show class but no hover)

      const stuckTooltips = document.querySelectorAll('#tooltip.show, .tooltip.show');

      stuckTooltips.forEach(tt => {

        const hovered = document.querySelector(':hover');

        if (!hovered || !hovered.hasAttribute('data-tooltip')) {

          tt.classList.remove('show');

          tt.style.display = 'none';

        }

      });

    }

  }, 200);



  // CRITICAL: Ensure only one QuickFix step is visible on page load

  // Hide all steps first, then show only Step 1 (if QuickFix flow is active)

  document.querySelectorAll('.quickfix-step').forEach(step => {

    if (!step.classList.contains('active') || step.id !== 'quickfixStep1') {

      step.style.setProperty('display', 'none', 'important');

      step.style.setProperty('opacity', '0', 'important');

      step.style.setProperty('visibility', 'hidden', 'important');

    }

  });



  // Always show main dashboard (input section) by default

  // Only show Pro Dashboard if user is actually a Pro subscriber (production)

    const inputSection = document.getElementById('inputSection');

  const step6 = document.getElementById('quickfixStep6');

  const resultsContainer = document.getElementById('resultsContainer');



  // Force show input section and hide Pro dashboard by default

    if (inputSection) {

      inputSection.style.display = 'block';

    inputSection.style.setProperty('display', 'block', 'important');

    inputSection.style.visibility = 'visible';

    inputSection.style.opacity = '1';

    console.log('âœ… Showing main dashboard (input section)');

    }



    if (step6) {

      step6.style.display = 'none';

    step6.style.setProperty('display', 'none', 'important');

  }



  // Hide results container by default (it shows after scanning)

  if (resultsContainer) {

    resultsContainer.style.display = 'none';

  }



  // Only show Pro Dashboard if user is actually a Pro subscriber (production)

  // This should only be true if user has completed payment and has active subscription

  if (appState.isProUser && appState.proSubscription && appState.proSubscription.active) {

    // For production: if user is already Pro, show dashboard

    console.log('âœ… Pro user detected - showing Pro Dashboard');

    showProDashboard();

  } else {

    // Ensure we're showing the main form

    appState.isProUser = false;

    if (appState.proSubscription) {

      appState.proSubscription.active = false;

    }

  }



  // Double-check form is visible after a short delay (in case other scripts hide it)

  setTimeout(function() {

    const inputSectionCheck = document.getElementById('inputSection');

    if (inputSectionCheck && inputSectionCheck.style.display === 'none') {

      console.warn('âš ï¸ Input section was hidden - forcing it visible');

      inputSectionCheck.style.display = 'block';

      inputSectionCheck.style.setProperty('display', 'block', 'important');

      inputSectionCheck.style.visibility = 'visible';

      inputSectionCheck.style.opacity = '1';

    }

  }, 100);



  // DON'T reset scan count on page load - it should persist across refreshes

  // Only reset at the start of a new day (handled by getScansUsed() which uses date-based keys)

  // Sync scan count from storage to get actual count from today

  appState.scansUsed = getScansUsed();

  console.log('ðŸ”„ Page loaded - scan count from storage:', appState.scansUsed);



  // Initialize free version functionality

  // Force update counter after a short delay to ensure DOM is ready

  setTimeout(function() {

    console.log('ðŸ”„ Initial updateCounter call');

    updateCounter();

    updateScansDisplay(); // Also update scan display to ensure button shows correct count



    // Also check if essayInput has text and update if needed

    const essayInput = document.getElementById('essayInput');

    if (essayInput) {

      // CRITICAL: Clear any default/placeholder text that might be in the textarea

      const currentValue = essayInput.value || '';

      const isPlaceholderText = currentValue.includes("In today's rapidly evolving") || 

                                currentValue.includes("organizations must leverage") ||

                                currentValue.includes("cutting-edge technologies") ||

                                currentValue.includes("cutting-edge technology landscape");

      if (isPlaceholderText || currentValue.trim().length > 0) {

        console.log('ðŸ—‘ï¸ Clearing default/placeholder text from essayInput');

        essayInput.value = '';

      }

      const textLength = essayInput.value ? essayInput.value.length : 0;

      console.log('ðŸ“ Initial text check - length:', textLength);



      if (textLength > 0) {

      const charCount = document.getElementById('charCount');

      if (charCount) {

          const wordCount = textValue ? textValue.trim().split(/\s+/).filter(w => w.length > 0).length : 0; let wc = (textValue || "").trim().split(/\s+/).filter(w => w.length > 0).length; charCount.textContent = wc.toLocaleString();

          console.log('âœ… Updated charCount to:', textLength);

      }

        // Force update counter to enable buttons

        updateCounter();

      }

    } else {

      console.error('âŒ essayInput not found during initialization');

    }

  }, 100);



  // Also check again after a longer delay to catch any late-loading content

  setTimeout(function() {

    const essayInput = document.getElementById('essayInput');

    if (essayInput && essayInput.value && essayInput.value.length > 0) {

      console.log('ðŸ”„ Late updateCounter call - text length:', essayInput.value.length);

      updateCounter();

    }

  }, 500);

  updateScanButton();

  initTooltips();



  // Character limit detection is handled by updateCounter() function



  // ===== WORKING DRAG-DROP EVENT LISTENERS =====

  const uploadArea = document.getElementById('uploadArea');

  if (uploadArea) {

    uploadArea.addEventListener('dragover', handleDragOver, false);

    uploadArea.addEventListener('dragenter', handleDragEnter, false);

    uploadArea.addEventListener('dragleave', handleDragLeave, false);

    uploadArea.addEventListener('drop', handleFileDrop, false);

    console.log('âœ… Drag-drop listeners attached');

  } else {

    console.error('âŒ Upload area not found');

  }



  // REMOVED: Duplicate event listeners - using inline onclick handlers instead

  // The buttons have onclick="handleScanClick(event)" etc. which are defined earlier

  console.log('âœ… Button handlers are using inline onclick handlers');



  // QuickFix flow buttons

  const startBtn = document.getElementById('startQuickFix');

  if (startBtn) {

    startBtn.addEventListener('click', startQuickFixAnalysis);

    console.log('âœ… Start QuickFix button listener added');

  }



  const applySelectedBtn = document.getElementById('applySelectedFixes');

  if (applySelectedBtn) {

    applySelectedBtn.addEventListener('click', applySelectedFixes);

    console.log('âœ… Apply QuickFixes button listener added');

  }



  const applyAllBtn = document.getElementById('applyAllFixes');

  if (applyAllBtn) {

    applyAllBtn.addEventListener('click', applyAllFixes);

    console.log('âœ… Apply All Fixes button listener added');

  }



  // NEW: Complete rewrite button

  const completeRewriteBtn = document.getElementById('completeRewrite');

  if (completeRewriteBtn) {

    completeRewriteBtn.addEventListener('click', completeRewrite);

    console.log('âœ… Complete Rewrite button listener added');

  }



  // Character counter

  const quickfixInput = document.getElementById('quickfixEssayInput');

  if (quickfixInput) {

    quickfixInput.addEventListener('input', function() {

      const count = this.value.length;

      var qfWords2 = (document.getElementById('quickfixEssayInput').value || '').trim().split(/\s+/).filter(function(w){return w.length>0}); document.getElementById('quickfixFlowCharCount').textContent = qfWords2.length;

    });

  }



  // FIXED: Add event listener for main essay input

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    console.log('âœ… Essay input found, attaching listeners');



    // Handle typing

    essayInput.addEventListener('input', function(e) {

      console.log('ðŸ“ Input event fired, length:', this.value.length);

      updateCounter();

    });



    // Handle paste events

    essayInput.addEventListener('paste', function(e) {

      console.log('ðŸ“‹ Paste event fired');

      // Use setTimeout to ensure paste content is in the textarea before counting

      setTimeout(function() {

        const text = essayInput.value ? essayInput.value.trim() : ''; const wordCount = text ? text.split(/\s+/).filter(w => w.length > 0).length : 0; const len = wordCount;

        console.log('ðŸ“‹ Paste processed, length:', len);

        updateCounter();

      }, 10);

    });



    // Handle change events (for programmatic changes)

    essayInput.addEventListener('change', function(e) {

      console.log('ðŸ”„ Change event fired, length:', this.value.length);

      updateCounter();

    });



    // Also trigger updateCounter on any existing text

    if (essayInput.value && essayInput.value.length > 0) {

      setTimeout(function() {

        console.log('ðŸ”„ Initial text detected, updating counter');

        updateCounter();

      }, 50);

    }



    // Force update counter periodically to catch any missed updates

    setInterval(function() {

      if (essayInput.value && essayInput.value.length > 0) {

        const currentCount = document.getElementById('charCount');

        const actualLength = essayInput.value.length;

        if (currentCount && parseInt(currentCount.textContent.replace(/,/g, '')) !== actualLength) {

          console.log('ðŸ”§ Counter mismatch detected, fixing:', currentCount.textContent, 'vs', actualLength);

          updateCounter();

        }

      }

    }, 500);



    console.log('âœ… Essay input listeners attached successfully');



    // Watch for value changes

    let lastValue = essayInput.value;

    setInterval(function() {

      if (essayInput.value !== lastValue) {

        lastValue = essayInput.value;

        updateCounter();

      }

    }, 500);

  } else {

    console.error('âŒ essayInput element not found!');

  }



  // Add event listener for authorship checkbox

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (authorshipCheckbox) {

    authorshipCheckbox.addEventListener('change', updateCounter);

  }



  // Add responsive behavior for Step 4

  // window.addEventListener('resize', initStep4Responsive);



  console.log('=== ALL EVENT LISTENERS INITIALIZED ===');

});



// ... (rest of your existing functions remain exactly the same)

// getScansUsed, incrementScans, updateScansDisplay, updateCounter, analyzeTextLocally, getExplanation, scanEssay, showFreeUserModal, showFreeUserResult, minimizeResults, handleProUpgrade, getRandomPhrase, analyzeTextWithAPI, updateScanButton

// ALL THESE FUNCTIONS REMAIN EXACTLY AS THEY WERE IN YOUR ORIGINAL CODE



function getScansUsed() {

  try {

    const today = new Date().toDateString();

    const key = 'scans_' + today;

    const lastResetDate = localStorage.getItem('lastScanResetDate');



    // If it's a new day, reset the count

    if (lastResetDate !== today) {

      // Clear old scan counts (clean up any old keys)

      const keysToRemove = [];

      for (let i = 0; i < localStorage.length; i++) {

        const key = localStorage.key(i);

        if (key && key.startsWith('scans_')) {

          keysToRemove.push(key);

        }

      }

      keysToRemove.forEach(k => localStorage.removeItem(k));



      // Set new reset date

      localStorage.setItem('lastScanResetDate', today);

      return 0;

    }



    // Use localStorage so it persists across browser sessions but resets daily

    return parseInt(localStorage.getItem(key) || '0', 10);

  } catch (e) {

    console.error('Error getting scan count:', e);

    return 0;

  }

}



// Guard to prevent double-incrementing

let isIncrementing = false;



function incrementScans() {

  // Prevent double-incrementing if already in progress

  if (isIncrementing) {

    console.warn('âš ï¸ incrementScans already in progress, skipping');

    return;

  }



  try {

    isIncrementing = true;

    const today = new Date().toDateString();

    const key = 'scans_' + today;



    // Ensure we're using the current day's count (handles daily reset)

    const currentScans = getScansUsed();

    appState.scansUsed = currentScans + 1;



    // Use localStorage so it persists across browser sessions but resets daily

    localStorage.setItem(key, appState.scansUsed.toString());

    lastDisplayedScansUsed = -1; // Reset cache to force update

    console.log('ðŸ“Š incrementScans - incremented from', currentScans, 'to:', appState.scansUsed, 'key:', key);

    updateScansDisplay();

  } catch (e) {

    console.error('Error saving scan count:', e);

  } finally {

    // Reset flag after a short delay to allow the increment to complete

    setTimeout(() => {

      isIncrementing = false;

    }, 100);

  }

}



// TESTING FUNCTION: Reset or set scan count for testing

function resetScanCount(count = 0) {

  if (count < 0) count = 0;

  // Use TEST_SCAN_LIMIT (50) instead of FREE_SCAN_LIMIT (3) for testing

  const TEST_SCAN_LIMIT = 50;

  if (count > TEST_SCAN_LIMIT) count = TEST_SCAN_LIMIT;



  const today = new Date().toDateString();

  const key = 'scans_' + today;

  localStorage.setItem(key, count.toString());

  localStorage.setItem('lastScanResetDate', today); // Ensure reset date is set



  // Sync appState

  appState.scansUsed = count;

  lastDisplayedScansUsed = -1; // Reset cache to force update



  // Update all displays

  updateScansDisplay();

  updateCounter();



  const remaining = TEST_SCAN_LIMIT - count;

  console.log('âœ… Scan count reset to:', count, '| Remaining:', remaining, '| Next scan will be:', Math.min(count + 1, TEST_SCAN_LIMIT));

  return `âœ… Scan count: ${count}/${TEST_SCAN_LIMIT} | Remaining: ${remaining} | Next: ${Math.min(count + 1, TEST_SCAN_LIMIT)}`;

}



// TESTING FUNCTION: Clear modal flags so modals can show again

function clearModalFlags() {

  const today = new Date().toDateString();

  localStorage.removeItem('firstScanModalShown_' + today);

  localStorage.removeItem('lastScanModalShown_' + today);

  console.log('âœ… Modal flags cleared for today. Modals will show again.');

  return 'Modal flags cleared. Modals will show again on next scan.';

}



// Make functions available globally for console testing

window.resetScanCount = resetScanCount;

window.clearModalFlags = clearModalFlags;



// Cache last displayed scan count to prevent unnecessary updates

let lastDisplayedScansUsed = -1;



function updateScansDisplay() {

  // Always sync from storage first to ensure accuracy

  const scansFromStorage = getScansUsed();



  // Only update if the count actually changed

  if (scansFromStorage === lastDisplayedScansUsed && lastDisplayedScansUsed !== -1) {

    return; // No change, skip update

  }



  appState.scansUsed = scansFromStorage;

  lastDisplayedScansUsed = scansFromStorage;



  // TEMPORARY: Use test limit for testing (revert to FREE_SCAN_LIMIT before launch)

  const TEST_SCAN_LIMIT = 50;

  const remaining = Math.max(0, TEST_SCAN_LIMIT - appState.scansUsed);

  const scansLeftEl = document.getElementById('scansLeft');

  const panicScansLeft = document.getElementById('panicScansLeft');

  const scanCounter = document.getElementById('scanCounter');



  if (!scansLeftEl) return;



  // Update button counter - show actual scans used (not next scan number)

  // If they've used 0 scans, show 0/50. If they've used 50 scans, show 50/50

  if (scanCounter) {

    const scansUsed = Math.min(appState.scansUsed, TEST_SCAN_LIMIT);

    scanCounter.textContent = scansUsed + '/' + TEST_SCAN_LIMIT;

  }



  // Update button text and state

  const scanButton = document.getElementById('scanButton');

  if (scanButton) {

    // Don't update button if it's currently showing "Scanning..."

    if (scanButton.innerHTML.includes('Scanning...') || scanButton.textContent.includes('Scanning...')) {

      return; // Keep the "Scanning..." text

    }



    const scansUsed = Math.min(appState.scansUsed, TEST_SCAN_LIMIT);

    const isExhausted = remaining === 0 && !appState.isProUser;



    // Update button text based on state

    if (isExhausted) {

      // Calculate time until reset (next midnight)

      const now = new Date();

      const tomorrow = new Date(now);

      tomorrow.setDate(tomorrow.getDate() + 1);

      tomorrow.setHours(0, 0, 0, 0);

      const msUntilReset = tomorrow - now;

      const hoursUntilReset = Math.ceil(msUntilReset / (1000 * 60 * 60));

      const minutesUntilReset = Math.ceil(msUntilReset / (1000 * 60));



      // Show hours if more than 1 hour, otherwise show minutes

      let resetText = '';

      if (hoursUntilReset >= 24) {

        resetText = 'Resets tomorrow';

      } else if (hoursUntilReset > 1) {

        resetText = 'Resets in ' + hoursUntilReset + 'h';

      } else if (minutesUntilReset > 1) {

        resetText = 'Resets in ' + minutesUntilReset + 'm';

      } else {

        resetText = 'Resets soon';

      }



      scanButton.innerHTML = 'ðŸ”’ Free Scans Used (' + scansUsed + '/' + TEST_SCAN_LIMIT + ') - ' + resetText;

      scanButton.disabled = true;

      scanButton.style.background = '#2ecc71';

      scanButton.style.opacity = '0.6';

      scanButton.style.cursor = 'not-allowed';

      scanButton.style.pointerEvents = 'none';

      scanButton.title = 'Daily limit reached. Scans reset at midnight. Upgrade to Pro for unlimited scans.';

    } else {

      // Update only the counter span, not the entire innerHTML (preserves onclick handler)

      const scanCounter = document.getElementById('scanCounter');

      if (scanCounter) {

        scanCounter.textContent = scansUsed + '/' + TEST_SCAN_LIMIT;

      } else {

        // Fallback: update innerHTML if counter doesn't exist

        scanButton.innerHTML = 'ðŸ” Free Scan (<span id="scanCounter">' + scansUsed + '/' + TEST_SCAN_LIMIT + '</span>)';

        // Re-attach onclick handler if it was lost

        scanButton.setAttribute('onclick', 'handleScanClick(event);');

      }



      // Let updateCounter() handle final styling (enabled/disabled based on form validity)

      // But ensure it's not disabled here if scans are available

      scanButton.style.pointerEvents = 'auto';

      scanButton.style.cursor = 'pointer';

    }

  }



  scansLeftEl.classList.remove('warning', 'danger');

  if (remaining === 0 && !appState.isProUser) {

    scansLeftEl.classList.add('danger');

    scansLeftEl.textContent = '0 free scans remaining today - Resets at midnight';

  } else if (remaining === 1) {

    scansLeftEl.classList.add('warning');

    scansLeftEl.textContent = remaining + ' free scan remaining today';

  } else {

    scansLeftEl.textContent = remaining + ' free scans remaining today';

  }



  if (panicScansLeft) {

    panicScansLeft.textContent = remaining;

  }



  console.log('ðŸ“Š updateScansDisplay - scansUsed:', appState.scansUsed, 'remaining:', remaining, 'button shows:', Math.min(appState.scansUsed, FREE_SCAN_LIMIT));

}



// Make updateCounter globally accessible

window.updateCounter = function updateCounter() {

  // Always sync scan count from localStorage first

  appState.scansUsed = getScansUsed();



  const essayInput = document.getElementById('essayInput');

  const charCount = document.getElementById('charCount');

  const scanButton = document.getElementById('scanButton');

  const quickFixButton = document.getElementById('emergencyButton');

  const proButton = document.getElementById('proButton');

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');



  if (!essayInput) {

    console.warn('âš ï¸ updateCounter: essayInput not found');

    return;

  }



  if (!charCount) {

    console.warn('âš ï¸ updateCounter: charCount element not found');

    return;

  }



  if (!scanButton || !authorshipCheckbox) {

    console.warn('âš ï¸ updateCounter: scanButton or authorshipCheckbox not found');

    return;

  }



  // Get text value directly from textarea

  let textValue = essayInput.value || '';

  let words = (textValue || "").trim().split(/\s+/).filter(w => w.length > 0); let wordCount = words.length; let len = wordCount;



  // Debug logging

  if (len > 0) {

    console.log('ðŸ“Š updateCounter - word count:', len, 'words, preview:', textValue.substring(0, 50) + '...');

  }



  // Enforce 5000 character maximum

  if (len > 1500) {
    words = words.slice(0, 1500);
    essayInput.value = words.join(' ');
    len = 1500;
  }



  // Show count with proper formatting (e.g., 5,000 instead of 5000)

  if (charCount) {

  let wc = (textValue || "").trim().split(/\s+/).filter(w => w.length > 0).length; charCount.textContent = wc.toLocaleString();

  }



  // REMOVED: Auto-popup when exceeding 500 characters (only show when clicking Free Scan)



  const counter = document.querySelector('.char-counter');

  if (counter) {

    counter.classList.remove('warning', 'danger');

    if (len >= appState.maxChars) {

      counter.classList.add('danger');

    } else if (len > 450) {

      counter.classList.add('warning');

    }

  }



  // Form validation: essay â‰¥ 50 chars AND authorship confirmed

  const isValidLength = len >= appState.minChars;

  const isAuthorshipConfirmed = authorshipCheckbox.checked;

  const isFormValid = isValidLength && isAuthorshipConfirmed;



  // TEMPORARY: Use test limit for testing (revert to FREE_SCAN_LIMIT before launch)

  const TEST_SCAN_LIMIT = 50;

  const hasScansLeft = appState.scansUsed < TEST_SCAN_LIMIT || appState.isProUser;

  const isExhausted = !hasScansLeft && !appState.isProUser;



  // Add/remove pulsing red animation on authorship section

  const authorshipSection = document.getElementById('authorshipSection');

  if (authorshipSection) {

    if (!isAuthorshipConfirmed) {

      authorshipSection.classList.add('authorship-section-pulse');

    } else {

      authorshipSection.classList.remove('authorship-section-pulse');

    }

  }



  // If exhausted, don't override the disabled state set by updateScansDisplay

  if (isExhausted) {

    // Button is already disabled by updateScansDisplay, don't change it

    return;

  }



  // Don't update button if it's currently showing "Scanning..."

  if (scanButton && (scanButton.innerHTML.includes('Scanning...') || scanButton.textContent.includes('Scanning...'))) {

    return; // Keep the "Scanning..." text and state

  }



  // Otherwise, update button based on form validity

  if (isFormValid && hasScansLeft) {

    scanButton.disabled = false;

    scanButton.style.background = '#2ecc71';

    scanButton.style.cursor = 'pointer';

    scanButton.style.pointerEvents = 'auto';

    scanButton.style.opacity = '1';

    scanButton.title = '';

  } else {

    // Keep button enabled but styled as disabled - mousedown handler will show message

    scanButton.disabled = false; // DON'T disable - let handler show message

    scanButton.style.background = '#2ecc71';

    scanButton.style.cursor = 'pointer'; // Still clickable

    scanButton.style.pointerEvents = 'auto';

    scanButton.style.opacity = '0.6';

    if (!isAuthorshipConfirmed) {

      scanButton.title = 'Please confirm you\'re the original author to continue.';

    } else if (!isValidLength) {

      scanButton.title = 'Please paste at least 50 characters to continue.';

    } else {

      scanButton.title = 'Daily scan limit reached. Upgrade to Pro for 100 monthly scans.';

    }

  }



  // Update QuickFix button - DON'T disable, just style it

  if (quickFixButton) {

    if (isFormValid) {

      quickFixButton.disabled = false;

      quickFixButton.style.opacity = '1';

      quickFixButton.style.cursor = 'pointer';

      quickFixButton.style.pointerEvents = 'auto';

      quickFixButton.title = '';

    } else {

      // Keep button enabled but styled as disabled - handler will show message

      quickFixButton.disabled = false; // DON'T disable

      quickFixButton.style.opacity = '0.6';

      quickFixButton.style.cursor = 'pointer'; // Still clickable

      quickFixButton.style.pointerEvents = 'auto';

      if (!isAuthorshipConfirmed) {

        quickFixButton.title = 'Please confirm you\'re the original author to continue.';

      } else {

        quickFixButton.title = 'Please paste at least 50 characters to continue.';

      }

    }

  }



  // Update Pro button - DON'T disable, just style it

  if (proButton) {

    if (isFormValid) {

      proButton.disabled = false;

      proButton.style.opacity = '1';

      proButton.style.cursor = 'pointer';

      proButton.style.pointerEvents = 'auto';

      proButton.title = '';

    } else {

      // Keep button enabled but styled as disabled - handler will show message

      proButton.disabled = false; // DON'T disable

      proButton.style.opacity = '0.6';

      proButton.style.cursor = 'pointer'; // Still clickable

      proButton.style.pointerEvents = 'auto';

      if (!isAuthorshipConfirmed) {

        proButton.title = 'Please confirm you\'re the original author to continue.';

      } else {

        proButton.title = 'Please paste at least 50 characters to continue.';

      }

    }

  }



  // Always update scan display to ensure front page shows correct count

  // This will update the button text, remaining count, and all scan-related displays

  updateScansDisplay();

};



function analyzeTextLocally(text, abortSignal = null) {

  console.log('ðŸ” [START] analyzeTextLocally() - text length:', text.length);

  const startTime = performance.now();



    // CRITICAL: Check if aborted before starting

  if (abortSignal && abortSignal.aborted) {

    console.log('âš ï¸ Local analysis aborted before start');

    throw new Error('Analysis aborted');

  }



  // CRITICAL: For very long text, limit processing to prevent freeze

  const MAX_TEXT_LENGTH = 10000;

  const processedText = text.length > MAX_TEXT_LENGTH ? text.substring(0, MAX_TEXT_LENGTH) : text;



  const issues = [];

  const textLower = processedText.toLowerCase();



  // Simple pattern matching - optimized to prevent blocking

  const patterns = {

    transitions: ['furthermore', 'moreover', 'additionally', 'consequently', 'nevertheless', 'therefore', 'thus', 'hence'],

    formal: ['cutting-edge', 'state-of-the-art', 'comprehensive analysis', 'paradigm shift', 'multifaceted approach', 'synergistic', 'leverage'],

    generic: ['various', 'numerous', 'extensive', 'comprehensive', 'significant', 'substantial', 'considerable', 'multiple'],

    passive: ['was done', 'is seen', 'can be found', 'it is believed', 'it is known', 'has been shown', 'was observed']

  };



  // CRITICAL: Limit iterations and use faster matching

  let patternCount = 0;

  const MAX_PATTERNS = 30; // Reduced limit for speed

  const MAX_PROCESSING_TIME = 100; // Max 100ms processing time



  // Use faster indexOf instead of regex where possible

  for (const category of Object.keys(patterns)) {

    // CRITICAL: Check abort signal

    if (abortSignal && abortSignal.aborted) {

      console.log('âš ï¸ Local analysis aborted during pattern matching');

      throw new Error('Analysis aborted');

    }



    if (patternCount >= MAX_PATTERNS) break;



    for (const word of patterns[category]) {

      // CRITICAL: Check abort signal in inner loop

      if (abortSignal && abortSignal.aborted) {

        console.log('âš ï¸ Local analysis aborted during word matching');

        throw new Error('Analysis aborted');

      }



      if (patternCount >= MAX_PATTERNS) break;



      // Performance check - break if taking too long

      if (performance.now() - startTime > MAX_PROCESSING_TIME) {

        console.warn('âš ï¸ Local analysis timeout - stopping early');

        break;

      }



      patternCount++;



      // Use faster indexOf check first, then regex only if found

      const lowerWord = word.toLowerCase();

      if (textLower.indexOf(lowerWord) !== -1) {

        // Only use regex if word found (faster)

      const regex = new RegExp('\\b' + word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');

        const matches = processedText.match(regex);

      if (matches && matches.length > 0) {

        const severity = category === 'formal' ? 'high' : 'medium';

        issues.push({

          phrase: matches[0],

          severity,

          explanation: getExplanation(category),

          type: category

        });

      }

      }

    }



    // Break outer loop if timeout

    if (performance.now() - startTime > MAX_PROCESSING_TIME) break;

  }



  let baseScore = 15;

  for (const issue of issues) {

    if (issue.severity === 'high') baseScore += 25;

    else if (issue.severity === 'medium') baseScore += 15;

    else baseScore += 8;

  }



  const result = {

    score: Math.min(95, Math.max(20, baseScore)),

    issues: issues.slice(0, 3),

    flagCount: issues.length

  };



  const processingTime = performance.now() - startTime;

  console.log('ðŸ” [END] analyzeTextLocally() - score:', result.score, 'flags:', result.issues.length, 'time:', processingTime.toFixed(2), 'ms');



  if (processingTime > 50) {

    console.warn('âš ï¸ Local analysis took', processingTime.toFixed(2), 'ms - consider optimizing');

  }



  return result;

}



function getExplanation(category) {

  const explanations = {

    transitions: 'Try varying your transitions for more natural flow. Consider alternatives like "Also," "Next," or "In addition."',

    formal: 'This formal language might trigger AI detectors. Try more conversational alternatives.',

    generic: 'Be more specific instead of using generic terms. Give concrete examples or numbers.',

    passive: 'Try active voice for stronger writing. "Researchers found" instead of "it was found."'

  };

  return explanations[category] || 'This phrase might trigger AI detection tools.';

}



// Make functions globally accessible

// Function to scan only the first 500 characters

function scanFirst500Chars() {

  const essayInput = document.getElementById('essayInput');

  const modal = document.getElementById('essayTooLongModal');



  if (!essayInput) {

    console.error('âŒ Essay input not found');

    return;

  }



  // CRITICAL: Reset scan state before trimming and scanning

  window._scanInProgress = false;

  console.log('âœ… Reset _scanInProgress flag before trimming and scanning');



  // Reset scan button state

  const scanButton = document.getElementById('scanButton');

  if (scanButton) {

    scanButton.disabled = false;

    scanButton.setAttribute('data-scanning', 'false');

    scanButton.textContent = scanButton.getAttribute('data-original-text') || 'Free Scan';

  }



  // Trim to first 500 characters

  const originalText = essayInput.value;

  const trimmedText = originalText.substring(0, 500);



  // Update the input value

  essayInput.value = trimmedText;



  // Update character counter

  if (typeof updateCounter === 'function') {

    updateCounter();

  }



  // Close the modal

  if (modal) {

    modal.style.display = 'none';

    document.body.classList.remove('modal-open');

  }



  // Now scan the trimmed text

  if (window.scanEssay) {

    console.log('âœ… Scanning first 500 characters');

    window.scanEssay();

  } else {

    console.error('âŒ scanEssay function not found');

  }

}



window.scanEssay = async function scanEssay() {

  console.log('ðŸ” [START] scanEssay() function called');

  const scanStartTime = performance.now();



  // CRITICAL: Prevent duplicate scans

  if (window._scanInProgress) {

    console.warn('âš ï¸ Scan already in progress - ignoring duplicate request');

    return;

  }



  // CRITICAL: Set flag to prevent duplicate scans

  window._scanInProgress = true;



  // CRITICAL: Abort any previous local detection

  if (window._localDetectionAbortController) {

    try {

      window._localDetectionAbortController.abort();

      console.log('âœ… Aborted previous local detection');

    } catch (e) {

      console.warn('âš ï¸ Error aborting previous local detection:', e);

    }

    window._localDetectionAbortController = null;

  }



  // CRITICAL: Clear any previous local detection timeout

  if (window._localDetectionTimeout) {

    clearTimeout(window._localDetectionTimeout);

    window._localDetectionTimeout = null;

  }



  // CRITICAL: HARD RESET - Kill everything from previous scan (NON-BLOCKING)

  cleanupBackgroundProcesses(); // Already exists



  // CRITICAL: Remove any blocking modals FIRST

  document.body.classList.remove('modal-open');

  document.body.style.overflow = '';



  // NON-BLOCKING: Only check visible modals, not all elements

  const visibleModals = document.querySelectorAll('[id*="modal"][style*="display"][style*="block"], [class*="overlay"][style*="display"][style*="block"]');

  for (let i = 0; i < Math.min(visibleModals.length, 10); i++) { // Limit to 10 modals max

    const modal = visibleModals[i];

    const style = window.getComputedStyle(modal);

    if (style.position === 'fixed' && parseInt(style.zIndex) > 1000) {

      modal.style.display = 'none';

    }

  }



  // REMOVED: Blocking loop that freezes the page

  // The for loop clearing 0-10000 intervals was BLOCKING THE MAIN THREAD

  // Instead, only clear known interval IDs stored in window



  // NON-BLOCKING: Only clear stored interval IDs (not all possible IDs)

  const knownIntervals = [

    window.scanTimerInterval,

    window.messageRotationInterval,

    window.cleanMessageRotationInterval,

    window.headerRotationInterval,

    window._rotationInterval,

    window._headingInterval,

    window._cleanHeadingInterval,

    window._zeroBoxInterval,

    window._extraFlagsInterval,

    window._chipsHintInterval

  ];



  for (const intervalId of knownIntervals) {

    if (intervalId) {

      try { clearInterval(intervalId); } catch(e) {}

      try { clearTimeout(intervalId); } catch(e) {}

    }

  }



  // REMOVED: Blocking querySelectorAll('*') that freezes on large pages

  // The forEach over ALL elements was BLOCKING THE MAIN THREAD

  // Instead, only disconnect observers we know about



  // Reset appState completely (fast, non-blocking)

  appState.flagData = [];

  appState.currentScore = 0;

  appState.originalText = '';

  appState.apiResponse = null;



  // CRITICAL: Yield to UI thread IMMEDIATELY after cleanup

  await new Promise(resolve => setTimeout(resolve, 10));

  console.log('âœ… Yielded to UI thread after cleanup');



  const essayInput = document.getElementById('essayInput');

  const scanButton = document.getElementById('scanButton');

  const text = essayInput.value.trim();



  // CRITICAL: Yield AGAIN before processing

  await new Promise(resolve => setTimeout(resolve, 10));

  console.log('âœ… Yielded to UI thread before processing');



  // CRITICAL: Check character limit for free scans - show modal if > 500 chars

  if (text.length > 500) {

    console.log('âš ï¸ Text exceeds 500 character limit:', text.length);

    showCharacterLimitModal();

    return;

  }



  // ============================

  // DEV-ONLY TEST OVERRIDES (DISABLED BY DEFAULT - Use ?dev=true in URL to enable)

  // ============================

  // Only use presets if explicitly enabled via URL parameter ?dev=true

  const useDevPresets = new URLSearchParams(window.location.search).get('dev') === 'true' && 

                        (location.hostname === 'localhost' || location.hostname === '127.0.0.1');



  if (useDevPresets) {

    console.log('ðŸ§ª DEV MODE: Checking for test presets. Hostname:', location.hostname);



    // Normalize function to handle whitespace and case

    const normalize = (str) => str.trim().replace(/\s+/g, ' ').toLowerCase();

    const trimmed = normalize(text);



    const devPresets = [

      // 1) LOW RISK â€“ "Low Sus" (0â€“29)

      {

        text: "Yesterday I went to the park after class, read a book on a bench, and talked with my friend about our weekend plans.",

        score: 18,

        flags: []

      },

      // 2) MEDIUM RISK â€“ "Mid Sus" (30â€“69)

      {

        text: "In today's world, technology is becoming more important in education, helping students access information faster and collaborate in new ways.",

        score: 55,

        flags: [

          { phrase: "more important", severity: "medium" },

          { phrase: "in new ways", severity: "medium" }

        ]

      },

      // 3) HIGH RISK â€“ "Major Sus" (70â€“100)

      {

        text: "In today's rapidly evolving digital landscape, organizations must leverage cutting-edge solutions to achieve unprecedented levels of efficiency and innovation.",

        score: 92,

        flags: [

          { phrase: "rapidly evolving digital landscape", severity: "high" },

          { phrase: "leverage", severity: "high" },

          { phrase: "cutting-edge", severity: "high" },

          { phrase: "unprecedented levels", severity: "high" }

        ]

      }

    ];



    // Find matching preset using normalized comparison

    const preset = devPresets.find(p => normalize(p.text) === trimmed);



    console.log('ðŸ§ª DEV MODE: Input text length:', trimmed.length);

    console.log('ðŸ§ª DEV MODE: Input text (first 100 chars):', trimmed.substring(0, 100));

    console.log('ðŸ§ª DEV MODE: Preset match found:', !!preset);

    if (preset) {

      console.log('ðŸ§ª DEV MODE: Matched preset score:', preset.score);

    }



    if (preset) {

      console.log("ðŸ§ª DEV OVERRIDE ACTIVE â€“ using preset for test paragraph, score:", preset.score);



      // Make sure appState gets the expected values for the FREE view

      appState.originalText   = text;

      appState.currentScore   = preset.score;

      appState.originalScore  = preset.score;

      appState.quickfixFlags  = preset.flags; // reuse for free previews

      appState.freeFlags      = preset.flags; // if you have a separate freeFlags, set it too



      // IMPORTANT: skip the real AI/detector logic when a preset matches

      // Increment scans BEFORE showing results

      incrementScans();

      console.log('ðŸ” Dev mode - After incrementScans, appState.scansUsed:', appState.scansUsed);



      // Skip the old modal, go straight to results

      showFreeUserResult();



      // Show upsell modals based on scan count

      // Show modal on 3rd scan (after results overlay) to avoid competing with results

      const remaining = Math.max(0, FREE_SCAN_LIMIT - appState.scansUsed);

      console.log('ðŸ” Modal check - scansUsed:', appState.scansUsed, 'remaining:', remaining);

      if (appState.scansUsed === 3) {

        // Third scan - show free scan limit modal (delayed to allow results overlay to show first)

        console.log('ðŸ” Triggering free scan limit modal on 3rd scan');

        setTimeout(() => showFirstScanUpsellModal(), 2500); // Longer delay to ensure results overlay completes

      }



      // Reset scan button - sync from localStorage first

      appState.scansUsed = getScansUsed();

      updateScansDisplay(); // Update scan counter display (this will update button text correctly)

      scanButton.disabled = false;



      // IMPORTANT: return early to prevent double-increment

      return;

    } else {

      console.log('ðŸ§ª DEV MODE: No preset match. Will use real API. Text was:', trimmed.substring(0, 100));

    }

  }



  // PRODUCTION MODE: Always use real Haiku API (default behavior)

  console.log('ðŸŒ Using real Haiku API for analysis');

  // ============================

  // EXISTING REAL LOGIC BELOW

  // ============================



  console.log('Text length:', text.length);

  console.log('Min chars required:', appState.minChars);



  if (text.length < appState.minChars) {

    showSuccessMessage('Please enter at least ' + appState.minChars + ' characters');

    return;

  }



  // TEMPORARY: Use test limit for testing (revert to FREE_SCAN_LIMIT before launch)

  const TEST_SCAN_LIMIT = 50;

  if (appState.scansUsed >= TEST_SCAN_LIMIT && !appState.isProUser) {

    handleProUpgrade();

    return;

  }



  // Store the original text for later use in results (including essay preview box)

  appState.originalText = text;



  // CRITICAL: Clear any existing timer FIRST before starting a new one

  if (window.scanTimerInterval) {

    clearInterval(window.scanTimerInterval);

    window.scanTimerInterval = null;

  }



  // Show scanning feedback immediately with timer - use innerHTML since button has span inside

  if (scanButton) {

    // Set flag to indicate scanning is active

    scanButton.dataset.scanning = 'true';

    scanButton.innerHTML = 'ðŸ” Scanning... (0s)';

  scanButton.disabled = true;

    scanButton.style.background = '#2ecc71';

  scanButton.style.color = 'white';

    scanButton.style.cursor = 'wait';

    scanButton.style.pointerEvents = 'none';



    // Start timer to show elapsed time

    let secondsElapsed = 0;

    const timerInterval = setInterval(() => {

      secondsElapsed++;

      // CRITICAL: Check if button still exists and hasn't been reset

      if (!scanButton || !document.body.contains(scanButton)) {

        clearInterval(timerInterval);

        window.scanTimerInterval = null;

        return;

      }

      // CRITICAL: Check if scanning flag was set to false (button was reset)

      if (scanButton.dataset.scanning === 'false') {

        clearInterval(timerInterval);

        window.scanTimerInterval = null;

        return;

      }

      // Only update if button still shows "Scanning..."

      const currentText = scanButton.innerHTML || scanButton.textContent || '';

      if (currentText.includes('Scanning...')) {

        scanButton.innerHTML = 'ðŸ” Scanning... (' + secondsElapsed + 's)';

      } else {

        // Button was reset, stop timer

        clearInterval(timerInterval);

        window.scanTimerInterval = null;

      }

    }, 1000);



    // Store interval ID so we can clear it later

    window.scanTimerInterval = timerInterval;

  }



  // CRITICAL FIX: Yield to UI thread IMMEDIATELY after button update

  // This allows the "Scanning..." button to render before any blocking operations

  await new Promise(resolve => setTimeout(resolve, 100));



  try {

    // Always increment free scans, regardless of Pro status

    // This ensures the "Scan Another Essay" button shows correct count

    // FIX: Defer incrementScans slightly to allow button to fully render

    await new Promise(resolve => setTimeout(resolve, 50));

      incrementScans();



    // FIX: Add another delay after incrementScans to allow DOM updates to complete

    // This prevents the UI from feeling "frozen" while the synchronous analysis runs

    await new Promise(resolve => setTimeout(resolve, 100));



    console.log('ðŸ” After incrementScans, appState.scansUsed:', appState.scansUsed, 'isProUser:', appState.isProUser);



    // CRITICAL: FREE users use LOCAL detection (no API retries = no freezing)

    // Pro/QuickFix users use API

    let analysis;

    if (appState.isProUser) {

      // Pro users: Use API

      console.log('ðŸŒ Pro user - using API analysis');

      analysis = await analyzeTextWithAPI(text);

    } else {

      // FREE users: Use LOCAL detection (no API calls, no retries, no freezing)

      // CRITICAL: Wrap in Promise with setTimeout to yield to UI thread and prevent blocking

      console.log('âœ… FREE user - using LOCAL detection (no API, no retries)');



      // Yield to UI thread first to prevent freeze - increased delay for better responsiveness

      await new Promise(resolve => setTimeout(resolve, 100));



      // CRITICAL: Create AbortController for local detection

      window._localDetectionAbortController = new AbortController();

      const abortSignal = window._localDetectionAbortController.signal;



      // Now process in background with longer delay to ensure button state is visible

      analysis = await new Promise((resolve) => {

        // Store timeout ID so we can clear it if aborted

        const timeoutId = setTimeout(() => {

          // Check if aborted before processing

          if (abortSignal.aborted) {

            console.log('âš ï¸ Local detection aborted before processing');

            window._localDetectionAbortController = null;

            window._localDetectionTimeout = null;

            resolve({ score: 0, issues: [], flagCount: 0, aborted: true });

            return;

          }



          try {

            const result = analyzeTextLocally(text, abortSignal);



            // Check if result was aborted

            if (result.aborted) {

              console.log('âš ï¸ Local detection was aborted during processing');

              window._localDetectionAbortController = null;

              window._localDetectionTimeout = null;

              resolve({ score: 0, issues: [], flagCount: 0, aborted: true });

              return;

            }



            // Ensure analysis has the expected format

            if (!result.issues) result.issues = [];

            if (!result.score) result.score = result.score || 50;

            resolve(result);

          } catch (error) {

            console.error('âŒ Local analysis error:', error);

            // Check if error is due to abort

            if (error.message === 'Analysis aborted' || abortSignal.aborted) {

              console.log('âš ï¸ Local detection aborted - returning aborted result');

              window._localDetectionAbortController = null;

              window._localDetectionTimeout = null;

              resolve({ score: 0, issues: [], flagCount: 0, aborted: true });

            } else {

              // Return default result on other errors

              resolve({

                score: 50,

                issues: [],

                flagCount: 0

              });

            }

          }

        }, 100); // Increased delay to keep UI responsive and allow button to render



        // Store timeout ID for cleanup

        window._localDetectionTimeout = timeoutId;



        // Listen for abort signal

        abortSignal.addEventListener('abort', () => {

          clearTimeout(timeoutId);

          window._localDetectionTimeout = null;

          window._localDetectionAbortController = null;

          console.log('âœ… Local detection timeout cleared due to abort');

          resolve({ score: 0, issues: [], flagCount: 0, aborted: true });

        });

      });



      // Clean up abort controller after completion

      if (!abortSignal.aborted) {

        window._localDetectionAbortController = null;

        window._localDetectionTimeout = null;

      }

    }



    // CRITICAL: Check if analysis was aborted - if so, don't process results

    if (analysis.aborted) {

      console.log('âš ï¸ Analysis was aborted - not processing results');

      window._scanInProgress = false;

      if (window.resetScanButton) {

        window.resetScanButton();

      }

      return; // Exit early, don't show results

    }



    appState.flagData = analysis.issues || [];

    appState.currentScore = analysis.score;

    // Store full API response for Step 3 (only if from API)

    if (appState.isProUser) {

    appState.apiResponse = analysis;

    // Store categorized flags from backend

    appState.quickfixTextPhraseFlags = analysis.textPhraseFlags || [];

    appState.quickfixStructuralFlags = analysis.structuralFlags || [];

    } else {

      // FREE users: Set empty arrays

      appState.apiResponse = null;

      appState.quickfixTextPhraseFlags = [];

      appState.quickfixStructuralFlags = [];

    }



    // DEBUG: Log what we received from API

    console.log('ðŸ” API Analysis Result:', {

      score: analysis.score,

      issuesCount: analysis.issues?.length || 0,

      flagCount: analysis.flagCount,

      issues: analysis.issues,

      flagData: appState.flagData,

      issuesArray: Array.isArray(analysis.issues) ? 'YES' : 'NO',

      firstIssue: analysis.issues?.[0] || 'NONE'

    });



    // CRITICAL: If API returned score >= 30 but 0 flags, log warning

    if (analysis.score >= 30 && (!analysis.issues || analysis.issues.length === 0)) {

      console.error('âŒ API returned score', analysis.score, 'but 0 flags!');

      console.error('This means the API detected AI patterns but found no specific phrases to flag.');

      console.error('The API should return at least 1-3 flags for scores >= 30.');

    }



    console.log('ðŸ” Before showFreeUserResult, appState.scansUsed:', appState.scansUsed);



    // CRITICAL FIX: Make showFreeUserResult non-blocking to prevent UI freeze

    // The button will be reset INSIDE showFreeUserResult() right after results view becomes visible

    // This ensures the button doesn't appear stuck while heavy DOM operations run

    await new Promise((resolve) => {

      // Add timeout safeguard - if showFreeUserResult takes > 10 seconds, show error

      const safeguardTimeout = setTimeout(() => {

        console.error('âš ï¸ showFreeUserResult took too long (>10s)');

        // Reset button as safety net

        if (window.resetScanButton) {

          window.resetScanButton();

        }

        showSuccessMessage('Results are taking longer than expected. Please refresh if needed.', '#f59e0b');

        resolve();

      }, 10000);



      // Use requestAnimationFrame to ensure UI can update between operations

      requestAnimationFrame(() => {

        setTimeout(() => {

          try {

            showFreeUserResult(); // Button reset happens inside this function

            clearTimeout(safeguardTimeout);

            resolve();

          } catch (error) {

            console.error('âŒ Error in showFreeUserResult:', error);

            clearTimeout(safeguardTimeout);

            // Reset button on error

            if (window.resetScanButton) {

              window.resetScanButton();

            }

            showSuccessMessage('Error displaying results. Please try again.', '#dc2626');

            resolve();

          }

        }, 10); // Minimal delay to yield to UI

      });

    });



    // Show upsell modals based on scan count

    // Show modal on 3rd scan (after results overlay) to avoid competing with results

    const remaining = Math.max(0, FREE_SCAN_LIMIT - appState.scansUsed);

    console.log('ðŸ” Modal check - scansUsed:', appState.scansUsed, 'remaining:', remaining);

    if (appState.scansUsed === 3) {

      // Third scan - show free scan limit modal (delayed to allow results overlay to show first)

      console.log('ðŸ” Triggering free scan limit modal on 3rd scan');

      setTimeout(() => showFirstScanUpsellModal(), 2500); // Longer delay to ensure results overlay completes

    }



  } catch (error) {

    console.error('âŒ Analysis failed:', error);



    // CRITICAL: Abort local detection if still running

    if (window._localDetectionAbortController) {

      try {

        window._localDetectionAbortController.abort();

      } catch (e) {}

      window._localDetectionAbortController = null;

    }

    if (window._localDetectionTimeout) {

      clearTimeout(window._localDetectionTimeout);

      window._localDetectionTimeout = null;

    }



    // CRITICAL: Reset button immediately on error using centralized function

    if (window.resetScanButton) {

      window.resetScanButton();

    } else {

      // Fallback

    if (scanButton) {

      scanButton.dataset.scanning = 'false';

      scanButton.disabled = false;

      }

    if (window.scanTimerInterval) {

      clearInterval(window.scanTimerInterval);

      window.scanTimerInterval = null;

      }

    }



    // Show user-friendly error message

    const errorMsg = error.message?.includes('timeout') || error.message?.includes('aborted') 

      ? 'Scan timed out. Please try again.' 

      : 'Analysis failed. Please try again.';

    showSuccessMessage(errorMsg, '#dc2626');

  } finally {

    // CRITICAL: Clear scan in progress flag

    window._scanInProgress = false;

    console.log('âœ… scanEssay finally: Cleared _scanInProgress flag');



    // CRITICAL: Clean up local detection abort controller if still exists

    if (window._localDetectionAbortController && !window._localDetectionAbortController.signal.aborted) {

      // Only clean up if not already aborted (aborted ones are cleaned up in abort handler)

      window._localDetectionAbortController = null;

    }

    if (window._localDetectionTimeout) {

      clearTimeout(window._localDetectionTimeout);

      window._localDetectionTimeout = null;

    }



    // CRITICAL: Always reset button state using centralized function

    // Note: Button reset is now handled inside the showFreeUserResult promise,

    // but we keep this as a safety net in case of errors

    // Use setTimeout to ensure this runs even if showFreeUserResult is blocking

    setTimeout(() => {

    if (window.resetScanButton) {

        console.log('âœ… scanEssay finally: Calling resetScanButton() (safety net)');

      window.resetScanButton();

    } else {

      // Fallback if function doesn't exist yet

    if (scanButton) {

      scanButton.dataset.scanning = 'false';

        scanButton.disabled = false;

    }

    if (window.scanTimerInterval) {

      clearInterval(window.scanTimerInterval);

      window.scanTimerInterval = null;

      }

    }



    // Always sync from localStorage to ensure front page shows correct count

    appState.scansUsed = getScansUsed();

    updateScansDisplay(); // Update scan counter display

    updateCounter(); // Update button enabled state

    }, 100); // Small delay to ensure it runs even if main thread is blocked



    // Clear timeout safeguard if it exists

    if (window._scanTimeoutSafeguard) {

      clearTimeout(window._scanTimeoutSafeguard);

      window._scanTimeoutSafeguard = null;

    }

  }

}

// REMOVED: Old "READY TO TURN IT IN?" modal - no longer used

// function showFreeUserModal(score) { ... }



// Dynamic message function based on score

function getDynamicMessage(score) {

  // Kinda Sus messages (30-69)

  const kindaSusMessages = [

    "Close, but let's make this chef's kiss ðŸ‘Œ",

    "You're almost there, just needs a lil finesse âœ¨",

    "Few tweaks and this goes hard ðŸ”¥",

    "One more pass and you're untouchable ðŸ’¯",

    "Nearly there, let's polish this up âš¡"

  ];



  // You're Good messages (0-29)

  const youreGoodMessages = [

    "Your writing is literally immaculate âœ¨",

    "This essay just hits different ðŸ”¥",

    "You cooked with this one fr fr ðŸ‘Œ",

    "No notes, this is pure ðŸ§¬",

    "This is giving main character energy ðŸ’…"

  ];



  // Hella Sus messages (70-100)

  const hellaSusMessages = [

    "Nah this is giving ChatGPT energy ðŸ˜¬",

    "Yeah nah, your prof's gonna catch this one ðŸš©",

    "This is sus as hell, we gotta fix it ðŸ’€",

    "Not the vibe, let's start over bestie ðŸ˜­",

    "Yo this is cooked, big yikes energy ðŸ“‰"

  ];



  // Select random message based on score range

  if (score >= 70) {

    return hellaSusMessages[Math.floor(Math.random() * hellaSusMessages.length)];

  } else if (score >= 30) {

    return kindaSusMessages[Math.floor(Math.random() * kindaSusMessages.length)];

  } else {

    return youreGoodMessages[Math.floor(Math.random() * youreGoodMessages.length)];

  }

}



function showFreeUserResult() {

  console.log('ðŸš€ showFreeUserResult START');



  // Clean up any existing rotating message intervals

  if (window.hellaSusRotationInterval) {

    clearInterval(window.hellaSusRotationInterval);

    window.hellaSusRotationInterval = null;

  }

  if (window.kindaSusRotationInterval) {

    clearInterval(window.kindaSusRotationInterval);

    window.kindaSusRotationInterval = null;

  }



  // CRITICAL: Declare score, analysisFlags, and previewFlags at function scope so they're accessible throughout

  // Initialize with fallback values

  let score = typeof appState.currentScore === 'number' ? appState.currentScore : 0;

  let analysisFlags = [];

  let previewFlags = []; // DEFINE previewFlags at function scope to prevent "undefined" errors

  let cardToShow = '';



  // CRITICAL: Get text from appState or textarea

  const text = (document.getElementById('essayInput')?.value || appState.originalText || '').trim();



  // DEBUG: Log what we have

  console.log('ðŸ” showFreeUserResult - Initial values:', {

    score: score,

    scoreType: typeof score,

    hasAppStateScore: typeof appState.currentScore !== 'undefined',

    appStateScore: appState.currentScore,

    textLength: text.length,

    hasFlagData: !!appState.flagData,

    flagDataLength: appState.flagData ? appState.flagData.length : 0

  });



  // CRITICAL: Hide all stuck tooltips immediately

  if (typeof clearAllTooltips === 'function') {

    clearAllTooltips();

  } else if (typeof hideTooltip === 'function') {

    hideTooltip();

  }

  // Force hide all tooltip elements

  const allTooltips = document.querySelectorAll('#tooltip, .tooltip, [id*="tooltip"], [class*="tooltip"]');

  allTooltips.forEach(tt => {

    tt.classList.remove('show');

    tt.style.display = 'none';

    tt.style.visibility = 'hidden';

    tt.style.opacity = '0';

  });



  // CRITICAL: Clean up any existing background processes first

  cleanupBackgroundProcesses();



  const startTime = performance.now();



  // Save checkpoint to localStorage (survives browser hang)

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'showFreeUserResult START',

      scansUsed: appState.scansUsed

    }));

  } catch (e) {}



  try {

  // Always sync from localStorage to ensure we have the latest value

  appState.scansUsed = getScansUsed();

  console.log('ðŸ” showFreeUserResult - appState.scansUsed synced from localStorage:', appState.scansUsed);



    // Checkpoint: After getScansUsed

    try {

      localStorage.setItem('fff_last_checkpoint', JSON.stringify({

        time: new Date().toISOString(),

        checkpoint: 'After getScansUsed',

        scansUsed: appState.scansUsed

      }));

    } catch (e) {}



  // Close free modal if it exists

  const modal = document.getElementById('freeModal');

  if (modal) {

    modal.remove();

  }

  document.body.classList.remove('modal-open');



  // CRITICAL FIX: Disable transitions when switching views to prevent blocking

  const resultsContainer = document.getElementById('resultsContainer');

  const inputSection = document.getElementById('inputSection');



  if (resultsContainer) {

    resultsContainer.style.transition = 'none';

  }

  if (inputSection) {

    inputSection.style.transition = 'none';

  }



  // Ensure results view is visible

  if (typeof FreePageViewManager !== 'undefined') {

    FreePageViewManager.show('results');

  } else if (typeof switchToResults === 'function') {

    switchToResults();

  } else {

    if (resultsContainer) resultsContainer.classList.add('show');

    if (inputSection) inputSection.style.display = 'none';

  }



  // Re-enable transitions after view switch completes

  setTimeout(() => {

    if (resultsContainer) resultsContainer.style.transition = '';

    if (inputSection) inputSection.style.transition = '';

  }, 50);



  // CRITICAL FIX: Reset button IMMEDIATELY when results view becomes visible

  // User can now see results are appearing, so "Scanning..." state is no longer needed

  // This prevents the button from appearing stuck while heavy DOM operations continue

  if (window.resetScanButton) {

    window.resetScanButton();

  }



  // Checkpoint: After view switching

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After view switching',

      scansUsed: appState.scansUsed

    }));

  } catch (e) {}



  // Get text directly from textarea input (most reliable source)

  const essayInput = document.getElementById('essayInput');

  const text = (essayInput && essayInput.value && essayInput.value.trim()) || appState.originalText || '';



  console.log('ðŸ” Essay text source check:', {

    fromTextarea: essayInput ? essayInput.value.substring(0, 50) + '...' : 'NO TEXTAREA FOUND',

    fromAppState: appState.originalText ? appState.originalText.substring(0, 50) + '...' : 'NO APPSTATE TEXT',

    finalText: text ? text.substring(0, 50) + '...' : 'NO TEXT',

    textareaLength: essayInput ? essayInput.value.length : 0,

    appStateLength: appState.originalText ? appState.originalText.length : 0,

    finalLength: text.length

  });



  // Checkpoint: After getting text

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After getting text',

      textLength: text.length,

      scansUsed: appState.scansUsed

    }));

  } catch (e) {}



  // IMMEDIATE PREVIEW: Set essay text right away for clean scores (before any other logic)

  if (text && text.trim().length > 0) {

    const previewScore = typeof appState.currentScore === 'number' ? appState.currentScore : 0;

  }

  console.log('ðŸ” showFreeUserResult - Text check:', {

    textLength: text.length,

    textPreview: text.substring(0, 50) + '...',

    hasOriginalText: !!appState.originalText

  });



  // Checkpoint: Before getting flags/score

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'Before getting flags/score',

      hasFlagData: !!appState.flagData,

      flagDataLength: appState.flagData ? appState.flagData.length : 0,

      hasCurrentScore: typeof appState.currentScore === 'number'

    }));

  } catch (e) {}



  // Use API response flags (stored in appState.flagData) instead of fallback detection



  // Remove phrases that overlap with other phrases (deduplicate overlapping flags)

  // Smarter logic: Sort by length (longest first), then filter out phrases that overlap significantly

  function deduplicateFlags(flags) {

    // Sort by length (longest first) to prioritize longer/more specific phrases

    const sorted = [...flags].sort((a, b) => {

      const aPhrase = (a.phrase || a.text || a.word || '').length;

      const bPhrase = (b.phrase || b.text || b.word || '').length;

      return bPhrase - aPhrase; // Longest first

    });



    // Keep only phrases that don't overlap significantly with longer phrases already kept

    return sorted.filter((flag, index) => {

      const phrase = (flag.phrase || flag.text || flag.word || '').toLowerCase().trim();

      if (!phrase) return false;



      // Check if this phrase overlaps with any phrase already in the result (longer phrases checked first)

      return !sorted.slice(0, index).some(other => {

        const otherPhrase = (other.phrase || other.text || other.word || '').toLowerCase().trim();

        if (!otherPhrase) return false;



        // Check for substring overlap (one contains the other)

        if (otherPhrase.includes(phrase) || phrase.includes(otherPhrase)) {

          return true; // Overlapping - skip this one

        }



        // Check for word overlap (if they share 50% or more of words, consider them overlapping)

        const phraseWords = phrase.split(/\s+/).filter(w => w.length > 0);

        const otherWords = otherPhrase.split(/\s+/).filter(w => w.length > 0);

        if (phraseWords.length === 0 || otherWords.length === 0) return false;



        const commonWords = phraseWords.filter(w => otherWords.includes(w)).length;

        const maxLength = Math.max(phraseWords.length, otherWords.length);

        const overlapRatio = commonWords / maxLength;



        // More than 40% word overlap = skip it (keep the longer one)

        return overlapRatio > 0.4;

      });

    });

  }



  // Helper: sort flags by risk/severity (highest risk first)

  function sortFlagsByRisk(flags) {

    if (!Array.isArray(flags)) return [];



    const getSeverityRank = (flag) => {

      const rawSeverity = flag && (flag.severity || flag.risk || flag.type || '');

      const sev = (typeof rawSeverity === 'string' ? rawSeverity : String(rawSeverity || '')).toLowerCase();

      if (sev === 'high') return 0;

      if (sev === 'medium') return 1;

      if (sev === 'low') return 2;

      return 3; // unknown / other

    };



    return [...flags].sort((a, b) => {

      const aRank = getSeverityRank(a);

      const bRank = getSeverityRank(b);

      if (aRank !== bRank) return aRank - bRank;



      // Tieâ€‘breaker: higher numeric riskScore (if present) first

      const aScore = typeof a?.riskScore === 'number' ? a.riskScore : 0;

      const bScore = typeof b?.riskScore === 'number' ? b.riskScore : 0;

      if (aScore !== bScore) return bScore - aScore;



      return 0;

    });

  }



  // CRITICAL: Update analysisFlags (already declared at function scope)

  analysisFlags = deduplicateFlags(appState.flagData || []);



  // Checkpoint: After getting flags

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After getting flags',

      flagCount: analysisFlags.length

    }));

  } catch (e) {}



  // CRITICAL: Update score (already declared at function scope)

  // Score from API (or local fallback if API failed)

  score = typeof appState.currentScore === 'number' 

    ? appState.currentScore

    : (AIDetectionEngine.calculateScore ? AIDetectionEngine.calculateScore(text) : 0);



  // FREE tier must not surface pattern-only scores without phrase flags

  if (!appState.isProUser && score >= 30 && analysisFlags.length === 0) {

    console.warn('âš ï¸ Free tier: score >= 30 but no phrase flags. Forcing clean score.');

    score = 0;

    appState.currentScore = 0;

  }



  // DEBUG: Verify score is defined

  console.log('ðŸ” showFreeUserResult - Score after assignment:', {

    score: score,

    scoreType: typeof score,

    isNumber: typeof score === 'number',

    appStateCurrentScore: appState.currentScore

  });



  if (typeof score === 'undefined' || score === null || isNaN(score)) {

    console.error('âŒ CRITICAL: score is invalid after all fallbacks!', score);

    score = 0; // Final fallback

  }



  // ========= HELPER FUNCTION: Highlight Flagged Words (FREE USERS ONLY) =========

  // Helper function to highlight flagged words in text with red underline and numbers

  // Exact matches: red underline (#dc2626) with number badge

  // Partial/overlapping matches: lighter red underline (#fee2e2) with number badge

  // Numbers correspond to trigger word chip numbers (1, 2, 3, etc.) - numbered by order of appearance in text

  function highlightFlaggedWords(textToHighlight, flags, previewFlagsForNumbering) {

    if (!flags || flags.length === 0 || !textToHighlight) {

      return textToHighlight;

    }



    // Use previewFlagsForNumbering if provided (for chip numbering), otherwise use flags

    const flagsForNumbering = previewFlagsForNumbering && previewFlagsForNumbering.length > 0 

      ? previewFlagsForNumbering 

      : flags;



    // Number flags by order of appearance in text (matching chip numbering logic)

    // Find first occurrence position for each flag in the text

    const textLowerForNumbering = textToHighlight.toLowerCase();

    const flagsWithPositions = flagsForNumbering.map((flag, arrayIndex) => {

      const phrase = ((flag.phrase || flag.text || flag.word || '').trim()).toLowerCase();

      if (!phrase) return null;



      // Find first occurrence in text

      const index = textLowerForNumbering.indexOf(phrase);

      if (index === -1) return null;



      return {

        flag: flag,

        phrase: phrase,

        originalPhrase: (flag.phrase || flag.text || flag.word || '').trim(),

        position: index,

        arrayIndex: arrayIndex

      };

    }).filter(item => item !== null);



    // Sort by position in text (ORDER OF APPEARANCE) - matching chip numbering

    flagsWithPositions.sort((a, b) => a.position - b.position);



    // Create a map of phrase to flag number (based on order of appearance in text)

    // This matches the chip numbering system exactly

    const phraseToNumberMap = new Map();

    flagsWithPositions.forEach((item, textOrderIndex) => {

      if (!phraseToNumberMap.has(item.phrase)) {

        phraseToNumberMap.set(item.phrase, textOrderIndex + 1); // 1-based numbering by text order

      }

    });



    // LIMIT TO MAX 5 FLAGGED WORDS (matching previewFlags limit)

    const maxFlags = 5;

    const limitedFlagsForNumbering = flagsForNumbering.slice(0, maxFlags);



    // Extract phrases from LIMITED flags with their numbers

    const phrasesWithNumbers = limitedFlagsForNumbering.map(flag => {

      const phrase = (flag.phrase || flag.text || flag.word || '').trim();

      const lowerPhrase = phrase.toLowerCase();

      const number = phraseToNumberMap.get(lowerPhrase) || null;

      return { phrase: phrase, lowerPhrase: lowerPhrase, number: number };

    }).filter(p => p.lowerPhrase.length > 0);



    if (phrasesWithNumbers.length === 0) {

      return textToHighlight;

    }



    // Sort by length (longest first) to handle overlaps properly

    phrasesWithNumbers.sort((a, b) => b.lowerPhrase.length - a.lowerPhrase.length);



    // Track which phrases have already been seen (for duplicate detection)

    const seenPhrases = new Set();



    // Track which characters are already highlighted (for exact matches)

    const textLower = textToHighlight.toLowerCase();

    const highlightedRanges = [];

    const partialRanges = [];



    // First pass: Find exact matches (case-insensitive)

    // Only mark FIRST occurrence of each phrase as exact (with number), rest are duplicates (light grey, no number)

    phrasesWithNumbers.forEach((phraseData) => {

      const phrase = phraseData.lowerPhrase;

      const isFirstOccurrence = !seenPhrases.has(phrase);

      let startIndex = 0;

      let occurrenceCount = 0;



      while (true) {

        const index = textLower.indexOf(phrase, startIndex);

        if (index === -1) break;



        const endIndex = index + phrase.length;

        occurrenceCount++;



        // Check if this range overlaps with an already highlighted exact match

        const overlapsExact = highlightedRanges.some(range => 

          (index < range.end && endIndex > range.start)

        );



        if (!overlapsExact) {

          if (isFirstOccurrence && occurrenceCount === 1) {

            // First occurrence: red underline with number badge

            highlightedRanges.push({ 

              start: index, 

              end: endIndex, 

              phrase: phrase,

              originalPhrase: phraseData.phrase,

              number: phraseData.number,

              isDuplicate: false

            });

            seenPhrases.add(phrase);

          } else {

            // Duplicate occurrence: light grey underline, no number badge

            partialRanges.push({ 

              start: index, 

              end: endIndex, 

              phrase: phrase,

              originalPhrase: phraseData.phrase,

              number: null,

              isDuplicate: true

            });

          }

        }



        startIndex = index + 1;

      }

    });



    // Second pass: Find overlapping phrases (partial matches) - mark as light grey, no number

    phrasesWithNumbers.forEach((phraseData) => {

      const phrase = phraseData.lowerPhrase;

      let startIndex = 0;

      while (true) {

        const index = textLower.indexOf(phrase, startIndex);

        if (index === -1) break;



        const endIndex = index + phrase.length;

        // Check if this is already an exact match (first occurrence)

        const isExactMatch = highlightedRanges.some(range => 

          range.start === index && range.end === endIndex && !range.isDuplicate

        );



        // Check if this overlaps with an exact match (partial/overlapping match)

        const overlapsExact = highlightedRanges.some(range => 

          (index < range.end && endIndex > range.start) && 

          !(range.start === index && range.end === endIndex) &&

          !range.isDuplicate

        );



        // Check if already in partial ranges

        const alreadyInPartials = partialRanges.some(range => 

          range.start === index && range.end === endIndex

        );



        if (overlapsExact && !isExactMatch && !alreadyInPartials) {

          // This is a partial/overlapping match - light grey underline, no number

          partialRanges.push({ 

            start: index, 

            end: endIndex, 

            phrase: phrase,

            originalPhrase: phraseData.phrase,

            number: null,

            isDuplicate: true

          });

        }



        startIndex = index + 1;

      }

    });



    // Build HTML with highlights

    // Combine and sort all ranges by start position

    const allRanges = [

      ...highlightedRanges.map(r => ({ ...r, type: 'exact' })),

      ...partialRanges.map(r => ({ ...r, type: 'partial' }))

    ].sort((a, b) => a.start - b.start);



    if (allRanges.length === 0) {

      return textToHighlight;

    }



    let result = '';

    let lastIndex = 0;



    allRanges.forEach(range => {

      // Add text before this range

      if (range.start > lastIndex) {

        result += escapeHtml(textToHighlight.substring(lastIndex, range.start));

      }



      // Add highlighted text with number badge (only for first occurrence)

      const highlightedText = textToHighlight.substring(range.start, range.end);

      // Only show number badge for exact matches (first occurrence), NOT for duplicates/partials

      const numberBadge = (range.type === 'exact' && range.number && !range.isDuplicate) 

        ? `<sup style="background: #dc2626; color: white; border-radius: 50%; width: 14px; height: 14px; display: inline-flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; margin-left: 2px; vertical-align: super; line-height: 1;">${range.number}</sup>` 

        : '';



      if (range.type === 'exact' && !range.isDuplicate) {

        // Red underline for first occurrence (exact matches) with number badge

        result += `<span style="text-decoration: underline; text-decoration-color: #dc2626; color: #dc2626; font-weight: 600;">${escapeHtml(highlightedText)}</span>${numberBadge}`;

      } else {

        // EXTREMELY LIGHT GREY underline for duplicate/partial matches (NO number badge)

        result += `<span style="text-decoration: underline; text-decoration-color: #e5e7eb; color: #9ca3af;">${escapeHtml(highlightedText)}</span>`;

      }



      lastIndex = range.end;

    });



    // Add remaining text

    if (lastIndex < textToHighlight.length) {

      result += escapeHtml(textToHighlight.substring(lastIndex));

    }



    return result;

  }



  // Helper function to escape HTML

  function escapeHtml(text) {

    const div = document.createElement('div');

    div.textContent = text;

    return div.innerHTML;

  }



  // CRITICAL: Hide green "clean and ready" box for Kinda Sus and Hella Sus (score >= 30)

  // This box should ONLY show for Clean No Sus (score < 30)

  // Hide it early to prevent it from showing on Kinda Sus/Hella Sus pages

  if (score >= 30) {

    const cleanMsgEl = document.getElementById('cleanEssayLilSusMessage');

    if (cleanMsgEl) {

      cleanMsgEl.style.display = 'none';

      cleanMsgEl.style.visibility = 'hidden';

      cleanMsgEl.style.opacity = '0';

      console.log('âœ… Hidden clean essay message for Kinda Sus/Hella Sus (score:', score, ')');

    }

  }



  // Checkpoint: After getting score

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After getting score',

      score: score

    }));

  } catch (e) {}



  // TEMPORARY: Force test different scores (uncomment one line to test)

  // score = 85; // Test Hella Sus page (70-100)

  // score = 50; // Test Kinda Sus page (30-69)

  // score = 15; // Test You're Good page (0-29)



  console.log('ðŸ” showFreeUserResult - Score check:', {

    score: score,

    appStateCurrentScore: appState.currentScore,

    isClean: score < 30,

    isKindaSus: score >= 30 && score < 70,

    isHellaSus: score >= 70,

    cardToShow: score >= 70 ? 'hellaSus' : (score >= 30 ? 'kindaSus' : 'youreGood'),

    textLength: text.length,

    textPreview: text.substring(0, 50) + '...'

  });



  if (score === 0 && appState.currentScore === undefined) {

    console.warn('âš ï¸ No score available - using local fallback');

  }



  let flagCount = analysisFlags.length;



  // Checkpoint: After calculating flagCount

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After calculating flagCount',

      flagCount: flagCount

    }));

  } catch (e) {}



  // DEBUG: Log what we have for rendering

  console.log('ðŸ” renderFreeUserAnalysis - Data check:', {

    score: score,

    flagCount: flagCount,

    analysisFlags: analysisFlags,

    flagData: appState.flagData,

    currentScore: appState.currentScore,

    originalTextLength: text.length

  });



  // CRITICAL: If API returned a score >= 30 but 0 flags, this is a bug

  // The API should ALWAYS return at least 1-3 flags for scores >= 30

  // Log this for debugging

  if (score >= 30 && flagCount === 0) {

    console.error('âŒ CRITICAL BUG: API returned score', score, 'but 0 flags. This should not happen - API should return flags for scores >= 30.');

    console.error('Full appState:', {

      flagData: appState.flagData,

      currentScore: appState.currentScore,

      originalText: appState.originalText?.substring(0, 100) + '...'

    });

  }



  // Checkpoint: Before highlighting logic

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'Before highlighting logic',

      score: score,

      flagCount: flagCount

    }));

  } catch (e) {}



  // TEMP FALLBACK: until the real AI engine is wired,

  // If API returns 0 flags but score suggests AI patterns, trust the API

  // Don't add fake flags - the API should always return flags if score >= 30

  // If it doesn't, that means the text genuinely has no specific flaggable phrases

  // (which is possible - score can be high due to overall patterns, not specific phrases)

  // FIXED: Show only highestâ€‘risk flags in preview (top 5 by severity)

  const severitySortedFlags = sortFlagsByRisk(analysisFlags);

  const previewCount = Math.min(5, severitySortedFlags.length); // Show up to 5 highestâ€‘risk flags

  previewFlags = severitySortedFlags.slice(0, previewCount); // ASSIGN to previewFlags (already declared at function scope)

  const extraCount = Math.max(flagCount - previewFlags.length, 0);



  // DEBUG: Verify previewFlags is defined

  console.log('âœ… previewFlags defined:', previewFlags.length, 'flags (previewCount:', previewCount, ', flagCount:', flagCount, ')');



  // ========= STORE SCAN DATA FOR LATER USE =========

  appState.lastScanData = {

    score: score,

    triggers: previewFlags,

    essayText: document.querySelector('#essayInput')?.value || ''

  };



  // ========= OVERLAY SYSTEM =========

  if (!appState.isProUser) {

    appState.pendingOverlay = {

      show: true,

      type: score >= 30 ? 'panic' : 'happy',

      score: score,

      triggers: previewFlags

    };

  }



  console.log('ðŸ”„ POPULATING TRIGGER DISPLAY...');



  // 1. UPDATE TRIGGER COUNT

  const triggerHeading = document.getElementById('freeTriggerHeading');

  if (triggerHeading && previewFlags && previewFlags.length > 0) {

    const count = previewFlags.length;

    triggerHeading.innerHTML = `âš¡ AI Trigger Words/Phrases: <span style="color: #dc2626; font-weight: 800;">${count}</span> Shown <span style="color: #dc2626; font-weight: 800;">${count}</span> Detected`;

    triggerHeading.style.display = 'block';

    console.log(`âœ… Updated trigger count: ${count}`); 

  }



  // 2. POPULATE RED PILLS

  const triggerChips = document.getElementById('freeTriggerChips');

  if (triggerChips && previewFlags && previewFlags.length > 0) {

    triggerChips.innerHTML = ''; // Clear existing



    previewFlags.forEach((flag, index) => {

      // SAFELY extract word text

      let wordText = '';

      if (typeof flag === 'string') {

        wordText = flag;

      } else if (flag && typeof flag === 'object') {

        wordText = flag.word || flag.text || flag.trigger || flag.flaggedWord || flag.phrase || '';

      }



      // Only proceed if we have a valid string

      if (wordText && typeof wordText === 'string' && wordText.trim().length > 0) {

        const chip = document.createElement('span');

        chip.textContent = wordText;

        chip.style.cssText = `

          background: #dc2626;

          color: white;

          padding: 6px 12px;

          border-radius: 20px;

          font-size: 14px;

          font-weight: 600;

          margin: 4px;

          display: inline-block;

        `;

        chip.title = `AI trigger word #${index + 1}: ${wordText}`;

        triggerChips.appendChild(chip);

      }

    });



    triggerChips.style.display = 'flex';

    console.log(`âœ… Added ${previewFlags.length} trigger pills`);

  }



  // 3. HIGHLIGHT TRIGGERS IN ESSAY TEXT WITH BRIGHT HIGHLIGHTER YELLOW

  // Find which essay preview is visible

  const essayContainer = [

    document.getElementById('hellaSusEssayText'),

    document.getElementById('kindaSusEssayText'),

    document.getElementById('cleanEssayText')

  ].find(container => container && container.textContent);



  if (essayContainer && previewFlags && previewFlags.length > 0) {

    let essayText = essayContainer.textContent;



    previewFlags.forEach(flag => {

      // SAFELY extract word text

      let wordText = '';

      if (typeof flag === 'string') {

        wordText = flag;

      } else if (flag && typeof flag === 'object') {

        wordText = flag.word || flag.text || flag.trigger || flag.flaggedWord || '';

      }



      // Only proceed if we have a valid string

      if (wordText && typeof wordText === 'string' && wordText.trim().length > 0) {

        try {

          const escapedWord = wordText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

          const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');

          essayText = essayText.replace(regex,

            `<span style="background-color: #FFFF00; color: #000000; padding: 2px 4px; border-radius: 2px; font-weight: 600;">$&</span>`

          );

          console.log(`âœ… Highlighted: "${wordText}"`);

        } catch (error) {

          console.log(`âŒ Error highlighting "${wordText}":`, error.message);

        }

      }

    });



    essayContainer.innerHTML = essayText;

    console.log('âœ… Highlighted trigger words in BRIGHT YELLOW');

  }



  console.log('=== previewFlags DEBUG ===');

  console.log('Type:', typeof previewFlags);

  console.log('Is array:', Array.isArray(previewFlags));

  console.log('Value:', previewFlags);

  console.log('Length:', previewFlags ? previewFlags.length : 0);



  // Checkpoint: After preview calculations

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After preview calculations',

      previewCount: previewCount,

      previewFlagsLength: previewFlags.length

    }));

  } catch (e) {}



  // Unified thresholds: 0â€“29, 30â€“69, 70â€“100

  let label = "Low Sus";

  let emoji = 'âœ…';

  let color = '#2ecc71';



  if (score >= 70) {

    label = 'Major Sus';

    emoji = 'ðŸš¨';

    color = '#dc2626';

    cardToShow = 'hellaSus';

  } else if (score >= 30) {

    label = 'Mid Sus';

    emoji = 'âš ï¸';

    color = '#FFF000'; // Correct QuickFix yellow for FREE Kinda Sus

    cardToShow = 'kindaSus';

  } else {

    cardToShow = 'youreGood'; // Will implement later

  }



  // Checkpoint: After determining cardToShow

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After determining cardToShow',

      cardToShow: cardToShow,

      score: score

    }));

  } catch (e) {}



  // Hide all cards first

  const hellaSusCard = document.getElementById('hellaSusCard');

  const kindaSusCard = document.getElementById('kindaSusCard');

  const youreGoodCard = document.getElementById('youreGoodCard');



  // Checkpoint: After getElementById calls

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After getElementById calls',

      hasHellaSusCard: !!hellaSusCard,

      hasKindaSusCard: !!kindaSusCard,

      hasYoureGoodCard: !!youreGoodCard

    }));

  } catch (e) {}



  if (hellaSusCard) hellaSusCard.style.display = 'none';

  if (kindaSusCard) kindaSusCard.style.display = 'none';

  if (youreGoodCard) youreGoodCard.style.display = 'none';



  // Show correct card based on score

  if (score < 30) {

    // For Free Clean No Sus, hide the bottom box (youreGoodCard) - we use freeCleanNoSusEssayContainer instead

    if (youreGoodCard) youreGoodCard.style.display = 'none';

    cardToShow = 'youreGood';

  } else if (score < 70) {

    document.body.classList.remove('free-low-sus-mode');

    if (kindaSusCard) kindaSusCard.style.display = 'block';

    cardToShow = 'kindaSus';



    // Hide urgency CTA section for Kinda Sus

    const urgencyCTASection = document.getElementById('urgencyCTASection');

    if (urgencyCTASection) {

      urgencyCTASection.style.display = 'none';

    }

  } else {

    if (hellaSusCard) hellaSusCard.style.display = 'block';

    cardToShow = 'hellaSus';



    // Hide urgency CTA section for Hella Sus

    const urgencyCTASection = document.getElementById('urgencyCTASection');

    if (urgencyCTASection) {

      urgencyCTASection.style.display = 'none';

    }

  }



  // Setup rotating messages for free results (with small delay to ensure DOM is ready)

  setTimeout(() => {

    if (typeof setupRotatingMessages === 'function') {

      setupRotatingMessages(score);

    }

  }, 100);



  // Show correct essay preview based on score

  const essayText = text;

  document.querySelectorAll('.essay-preview-section').forEach(section => {

    section.style.display = 'none';

  });



  if (score < 70) {

    const kindaPreview = document.getElementById('kindaSusEssayPreview');

    const kindaText = document.getElementById('kindaSusEssayText');

    if (kindaPreview) kindaPreview.style.display = 'block';

    if (kindaText && essayText) kindaText.textContent = essayText;

  } else {

    const hellaPreview = document.getElementById('hellaSusEssayPreview');

    const hellaText = document.getElementById('hellaSusEssayText');

    if (hellaPreview) hellaPreview.style.display = 'block';

    if (hellaText && essayText) hellaText.textContent = essayText;

  }



  // Checkpoint: After hiding cards

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After hiding cards',

      cardToShow: cardToShow

    }));

  } catch (e) {}



  // Clear rotating clean messages interval if switching away from Clean/No Sus

  if (cardToShow !== 'youreGood' && window._cleanMessageInterval) {

    clearInterval(window._cleanMessageInterval);

    window._cleanMessageInterval = null;

    const rotatingCleanMessage = document.getElementById('rotatingCleanMessage');

    if (rotatingCleanMessage) {

      rotatingCleanMessage.style.display = 'none';

    }

  }



  // Show the appropriate card and update its elements

  // Hide Clean/No Sus specific CTA under-text for Hella Sus and Kinda Sus

  const cleanNoSusCtaUndertextEl = document.getElementById('cleanNoSusCtaUndertext');

  if (cleanNoSusCtaUndertextEl) {

    cleanNoSusCtaUndertextEl.style.display = 'none';

  }



  if (cardToShow === 'hellaSus') {

    document.body.classList.remove('free-low-sus-mode');

    if (hellaSusCard) hellaSusCard.style.display = 'block';

    // FREE RESULTS: Do NOT start progress bar here - it will start after modal closes

    // requestAnimationFrame(() => startProgressAnimations(score));



    // DEBUG: Verify card label text is correct

    const hellaSusLabelEl = document.getElementById('hellaSusLabel');

    if (hellaSusLabelEl) {

      console.log('ðŸ” [DEBUG] hellaSusLabel textContent:', hellaSusLabelEl.textContent);

      console.log('ðŸ” [DEBUG] Expected: "AI detectors are gonna lose it - time for the full glow-up âœ¨"');

    }



    // Hide urgency CTA section for Hella Sus

    const urgencyCTASection = document.getElementById('urgencyCTASection');

    if (urgencyCTASection) {

      urgencyCTASection.style.display = 'none';

      console.log('âœ… Hidden urgency CTA section for Hella Sus');

    }



    // Start rotating messages for Hella Sus

    if (typeof startRotatingHellaSusMessages === 'function') {

      startRotatingHellaSusMessages();

    }



    const scoreNumberEl = document.getElementById('hellaSusScoreNumber');

    const scoreLabelEl = document.getElementById('hellaSusScoreLabel');

    const progressFill = document.getElementById('hellaSusProgressFill');



    // Score: Large 72px number with label below (matches QuickFix)

    // Set initial state - animation will happen after modal closes via startProgressAnimations

    if (scoreNumberEl) {

      scoreNumberEl.textContent = '0%';

      scoreNumberEl.style.fontSize = '72px';

      // Color will be set by animateProgressBar

    }

    if (scoreLabelEl) {

      scoreLabelEl.textContent = label;

      scoreLabelEl.style.color = '#6b7280';

      scoreLabelEl.style.fontSize = '14px';

    }

    // Progress bar: Set initial state - animation will happen after modal closes

    if (progressFill) {

      progressFill.style.width = '0%';

      // Background will be set by animateProgressBar using getProgressFillGradient

    }

    updateSusBar(score, 'hella');

  } else if (cardToShow === 'kindaSus') {

    if (kindaSusCard) kindaSusCard.style.display = 'block';

    // FREE RESULTS: Do NOT start progress bar here - it will start after modal closes

    // requestAnimationFrame(() => startProgressAnimations(score));



    // DEBUG: Verify card label text is correct

    const kindaSusLabelEl = document.getElementById('kindaSusLabel');

    if (kindaSusLabelEl) {

      console.log('ðŸ” [DEBUG] kindaSusLabel textContent:', kindaSusLabelEl.textContent);

      console.log('ðŸ” [DEBUG] Expected: "These sentences are lowkey cooked. Not on Lil\' Sus\'s watch."');

      console.log('ðŸ” [DEBUG] kindaSusWarningTitle color:', window.getComputedStyle(kindaSusLabelEl.parentElement.querySelector('#kindaSusWarningTitle')).color);

    }



    // Hide urgency CTA section for Kinda Sus

    const urgencyCTASection = document.getElementById('urgencyCTASection');

    if (urgencyCTASection) {

      urgencyCTASection.style.display = 'none';

      console.log('âœ… Hidden urgency CTA section for Kinda Sus');

    }



    // Start rotating messages for Kinda Sus

    if (typeof startRotatingKindaSusMessages === 'function') {

      startRotatingKindaSusMessages();

    }



    const scoreNumberEl = document.getElementById('kindaSusScoreNumber');

    const scoreLabelEl = document.getElementById('kindaSusScoreLabel');

    const progressFill = document.getElementById('kindaSusProgressFill');



    // Score: Large 72px number with label below (matches QuickFix) - USE getScoreFontColor()

    // Set initial state - animation will happen after modal closes via startProgressAnimations

    if (scoreNumberEl) {

      scoreNumberEl.textContent = '0%';

      scoreNumberEl.style.fontSize = '72px';

      // Color will be set by animateProgressBar

    }

    if (scoreLabelEl) {

      scoreLabelEl.textContent = label;

      scoreLabelEl.style.color = '#6b7280';

      scoreLabelEl.style.fontSize = '14px';

    }

    // Progress bar: Set initial state - animation will happen after modal closes

    if (progressFill) {

      progressFill.style.width = '0%';

      // Background will be set by animateProgressBar using getProgressFillGradient

    }

    updateSusBar(score, 'kinda');

  } else if (cardToShow === 'youreGood') {

    // Free Low Sus: add body class for Scan Another Essay green border, trigger confetti

    document.body.classList.add('free-low-sus-mode');

    setTimeout(function() { if (typeof showCanvasConfetti === 'function') showCanvasConfetti(); }, 300);

    // SIMPLIFIED: Exact same pattern as Hella Sus

    // For Free Clean No Sus, hide the bottom box (youreGoodCard) - we use freeCleanNoSusEssayContainer instead

    if (youreGoodCard) youreGoodCard.style.display = 'none';

    // FREE RESULTS: Do NOT start progress bar here - it will start after modal closes

    // requestAnimationFrame(() => startProgressAnimations(score));



    const scoreNumberEl = document.getElementById('youreGoodScoreNumber');

    const scoreLabelEl = document.getElementById('youreGoodScoreLabel');

    const progressFill = document.getElementById('youreGoodProgressFill');



    // Score: Large 72px number with label below (matches QuickFix)

    // Set initial state - animation will happen after modal closes via startProgressAnimations

    if (scoreNumberEl) {

      scoreNumberEl.textContent = '0%';

      scoreNumberEl.style.fontSize = '72px';

      // Color will be set by animateProgressBar

    }

    if (scoreLabelEl) {

      scoreLabelEl.textContent = label;

      scoreLabelEl.style.color = '#6b7280';

      scoreLabelEl.style.fontSize = '14px';

    }

    // Progress bar: Set initial state - animation will happen after modal closes

    if (progressFill) {

      progressFill.style.width = '0%';

      // Background will be set by animateProgressBar using getProgressFillGradient

    }

    updateSusBar(score, 'youreGood');



    // REMOVED: Don't show rotating clean messages for FREE Clean No Sus

    // User requested to remove this rotating message box ("No notes, this is pure ðŸ§¬" etc.)

    const rotatingCleanMessage = document.getElementById('rotatingCleanMessage');

    if (rotatingCleanMessage) {

      // Clear any existing interval first

      if (window._cleanMessageInterval) {

        clearInterval(window._cleanMessageInterval);

        window._cleanMessageInterval = null;

      }

      // Hide the rotating message box for FREE Clean No Sus

      rotatingCleanMessage.style.display = 'none';

      rotatingCleanMessage.style.visibility = 'hidden';

        rotatingCleanMessage.style.opacity = '0';

      console.log('âœ… Hidden rotatingCleanMessage for Clean No Sus (removed per user request)');

    }



    // CRITICAL: Hide the duplicate shared essay preview section (ONLY for Clean/No Sus)

    const sharedEssayPreview = document.getElementById('essayPreview');

    if (sharedEssayPreview) {

      sharedEssayPreview.style.display = 'none';

      console.log('âœ… Hidden duplicate shared essayPreview for Clean/No Sus');

    }



    // REMOVED: Old essayPreviewContent container has been deleted from HTML - only using freeCleanNoSusEssayContainer now



    // CRITICAL: Hide the urgency CTA section for Clean/No Sus (no flags to fix)

    const urgencyCTASection = document.getElementById('urgencyCTASection');

    if (urgencyCTASection) {

      urgencyCTASection.style.display = 'none';

      console.log('âœ… Hidden urgency CTA section for Clean/No Sus');

    }



    // CRITICAL: Hide trigger heading completely for Clean/No Sus (user requested removal)

    const triggerHeading = document.getElementById('freeTriggerHeading');

    const triggerWordsCard = document.getElementById('freeTriggerWordsCard');

    if (triggerHeading) {

      triggerHeading.style.display = 'none';

      triggerHeading.style.visibility = 'hidden';

      triggerHeading.style.opacity = '0';

      triggerHeading.style.height = '0';

      triggerHeading.style.margin = '0';

      triggerHeading.style.padding = '0';

      console.log('âœ… Hidden trigger heading for Clean/No Sus');

    }

    if (triggerWordsCard) {

      triggerWordsCard.style.display = 'none';

      triggerWordsCard.style.visibility = 'hidden';

      triggerWordsCard.style.opacity = '0';

      triggerWordsCard.style.height = '0';

      triggerWordsCard.style.margin = '0';

      triggerWordsCard.style.padding = '0';

      console.log('âœ… Hidden trigger words card for Clean/No Sus');

    }



    // CRITICAL: Hide the hover hint for Clean/No Sus (no trigger words to hover over)

    const triggerChipsHint = document.getElementById('freeTriggerChipsHint');

    if (triggerChipsHint) {

      triggerChipsHint.style.display = 'none';

      console.log('âœ… Hidden trigger chips hover hint for Clean/No Sus');

    }



    // CRITICAL: Hide warning message box for Clean/No Sus

    const warningMessageBox = document.getElementById('freeWarningMessageBox');

    if (warningMessageBox) {

      warningMessageBox.style.display = 'none';

      console.log('âœ… Hidden warning message box for Clean/No Sus');

    }



    // CRITICAL: Hide trigger chips section for Clean/No Sus (no flags)

    const triggerChips = document.getElementById('freeTriggerChips');

    if (triggerChips) {

      triggerChips.innerHTML = '';

      console.log('âœ… Cleared trigger chips for Clean/No Sus');

    }



    // CRITICAL: Hide urgent trigger warning card for Clean/No Sus (card removed)

    const urgentCard = document.getElementById('urgentTriggerWarningCard');

    if (urgentCard) {

      urgentCard.style.display = 'none';

    }



    // CRITICAL: Hide QuickFix/Pro CTA buttons section for Clean/No Sus (no flags to fix)

    const quickfixProCtaSection = document.getElementById('quickfixProCtaSection');

    if (quickfixProCtaSection) {

      quickfixProCtaSection.style.display = 'none';

      console.log('âœ… Hidden QuickFix/Pro CTA section for Clean/No Sus');

    }



    // CRITICAL: Hide the lockbox/blurred essay section for Clean/No Sus (no flags to unlock)

    const freeUnlockOverlay = document.getElementById('freeUnlockOverlay');

    if (freeUnlockOverlay) {

      freeUnlockOverlay.style.display = 'none';

      console.log('âœ… Hidden lockbox overlay for Clean/No Sus');

    }



    // Show the Clean/No Sus specific CTA under-text

    const cleanNoSusCtaUndertext = document.getElementById('cleanNoSusCtaUndertext');

    if (cleanNoSusCtaUndertext) {

      cleanNoSusCtaUndertext.style.display = 'block';

      console.log('âœ… Showing Clean/No Sus CTA under-text');

    }



    // CRITICAL: Show Lil Sus clean essay message for Clean/No Sus

    let cleanEssayLilSusMessage = document.getElementById('cleanEssayLilSusMessage');



    // If element doesn't exist, CREATE IT dynamically

    if (!cleanEssayLilSusMessage) {

      console.log('âš ï¸ cleanEssayLilSusMessage not found, creating it dynamically...');

      const triggerChipsCard = document.getElementById('freeTriggerChips')?.closest('.card');

      if (triggerChipsCard && triggerChipsCard.parentNode) {

        cleanEssayLilSusMessage = document.createElement('div');

        cleanEssayLilSusMessage.id = 'cleanEssayLilSusMessage';

        cleanEssayLilSusMessage.innerHTML = `

          <div style="display: flex; align-items: center; justify-content: center; gap: 16px; flex-wrap: wrap;">

            <img src="https://i.postimg.cc/BvfyyZqm/Generated-Image-September-04-2025-10-44AM.jpg" alt="Lil Sus" style="width: 80px; height: auto; animation: pointBackForth 2s ease-in-out infinite; flex-shrink: 0;">

            <p style="font-size: 20px; font-weight: 700; color: #047857; margin: 0; line-height: 1.4;">

              Your essay is clean and ready to turn in! âœ¨

            </p>

          </div>

        `;

        triggerChipsCard.parentNode.insertBefore(cleanEssayLilSusMessage, triggerChipsCard.nextSibling);

        console.log('âœ… Created cleanEssayLilSusMessage dynamically');

      } else {

        console.error('âŒ Could not find trigger chips card to insert message after');

      }

    }



    if (cleanEssayLilSusMessage) {

      // REMOVED: Don't show cleanEssayLilSusMessage box for Clean No Sus

      // User requested to remove this box from the FREE Clean No Sus page only

      cleanEssayLilSusMessage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

      console.log('âœ… Hidden cleanEssayLilSusMessage for Clean No Sus (removed per user request)');

      // Removed scrollIntoView since box is hidden

    } else {

      console.error('âŒ cleanEssayLilSusMessage STILL NOT FOUND AFTER CREATION ATTEMPT!');

    }



    // CRITICAL: Hide "These words are AI red flags" message for Clean/No Sus

    const triggerWordsMessage = document.getElementById('freeTriggerWordsMessage');

    if (triggerWordsMessage) {

      triggerWordsMessage.style.display = 'none';

      console.log('âœ… Hidden trigger words message for Clean/No Sus');

    }



    // CRITICAL: Populate essay preview for Clean/No Sus

    // NOTE: Using #freeCleanNoSusEssayContainer (the old #essayPreviewContent has been removed)

    // Try multiple sources for the essay text - prioritize the function-scope text variable which should have it

    const essayInput = document.getElementById('essayInput');

    const essayTextForPreview = (text && text.trim()) || 

                                 (essayInput && essayInput.value && essayInput.value.trim()) || 

                                 (appState.originalText && appState.originalText.trim()) || 

                                 (appState.scannedText && appState.scannedText.trim()) ||

                                 '';



    console.log('ðŸ” Clean No Sus - Essay text sources:', {

      textVarLength: text ? text.length : 0,

      essayInputLength: essayInput && essayInput.value ? essayInput.value.length : 0,

      appStateOriginalLength: appState.originalText ? appState.originalText.length : 0,

      appStateScannedLength: appState.scannedText ? appState.scannedText.length : 0,

      finalTextLength: essayTextForPreview.length

    });



    // Populate the FREE Clean No Sus essay container - EXACT COPY from QuickFix Step 2 Clean No Sus (lines 9070-9083)

    const freeCleanNoSusEssayContainer = document.getElementById('freeCleanNoSusEssayContainer');

    const freeCleanNoSusEssayContent = document.getElementById('freeCleanNoSusEssayContent');



    // CRITICAL: Always show the container for Clean No Sus, even if we don't have text yet

    // Use setProperty with !important to override any CSS rules

    if (freeCleanNoSusEssayContainer) {

      freeCleanNoSusEssayContainer.style.setProperty('display', 'block', 'important');

      freeCleanNoSusEssayContainer.style.setProperty('visibility', 'visible', 'important');

      freeCleanNoSusEssayContainer.style.setProperty('opacity', '1', 'important');

      freeCleanNoSusEssayContainer.style.setProperty('position', 'relative', 'important');

      freeCleanNoSusEssayContainer.style.setProperty('z-index', '10', 'important');



      // Also check computed styles to verify

      const computedDisplay = window.getComputedStyle(freeCleanNoSusEssayContainer).display;

      const computedVisibility = window.getComputedStyle(freeCleanNoSusEssayContainer).visibility;

      const computedOpacity = window.getComputedStyle(freeCleanNoSusEssayContainer).opacity;



      console.log('âœ… Showing FREE Clean No Sus essay container', {

        inlineDisplay: freeCleanNoSusEssayContainer.style.display,

        computedDisplay: computedDisplay,

        computedVisibility: computedVisibility,

        computedOpacity: computedOpacity,

        isInDOM: document.body.contains(freeCleanNoSusEssayContainer),

        parentDisplay: freeCleanNoSusEssayContainer.parentElement ? window.getComputedStyle(freeCleanNoSusEssayContainer.parentElement).display : 'NO PARENT'

      });



      if (computedDisplay === 'none') {

        console.error('âŒ Container display is still "none" after setting! Forcing again...');

        freeCleanNoSusEssayContainer.style.display = 'block !important';

      }



      // CRITICAL: Verify parent card is visible

      const parentCard = freeCleanNoSusEssayContainer.closest('#youreGoodCard');

      if (parentCard) {

        const parentDisplay = window.getComputedStyle(parentCard).display;

        console.log('ðŸ” Parent card (#youreGoodCard) visibility check:', {

          parentDisplay: parentDisplay,

          parentInlineDisplay: parentCard.style.display,

          isBlock: parentDisplay === 'block'

        });



        if (parentDisplay === 'none') {

          console.error('âŒ Parent card is hidden! Forcing it visible...');

          parentCard.style.setProperty('display', 'block', 'important');

          parentCard.style.setProperty('visibility', 'visible', 'important');

          parentCard.style.setProperty('opacity', '1', 'important');

        }

        } else {

        console.error('âŒ Parent card (#youreGoodCard) NOT FOUND! Container may not be in the right place in DOM.');

      }



      // Double-check container is visible after all operations

      setTimeout(() => {

        const finalDisplay = window.getComputedStyle(freeCleanNoSusEssayContainer).display;

        const finalVisibility = window.getComputedStyle(freeCleanNoSusEssayContainer).visibility;

        const finalOpacity = window.getComputedStyle(freeCleanNoSusEssayContainer).opacity;

        console.log('ðŸ” Final container visibility check (after 100ms):', {

          display: finalDisplay,

          visibility: finalVisibility,

          opacity: finalOpacity,

          isVisible: finalDisplay !== 'none' && finalVisibility !== 'hidden' && finalOpacity !== '0'

        });



        if (finalDisplay === 'none' || finalVisibility === 'hidden') {

          console.error('âŒ Container is STILL hidden! Re-forcing visibility...');

          freeCleanNoSusEssayContainer.style.setProperty('display', 'block', 'important');

          freeCleanNoSusEssayContainer.style.setProperty('visibility', 'visible', 'important');

          freeCleanNoSusEssayContainer.style.setProperty('opacity', '1', 'important');

        }

      }, 100);

    } else {

      console.error('âŒ freeCleanNoSusEssayContainer NOT FOUND in DOM!');

    }



    // CRITICAL: Ensure the content element exists - if not found, log error but continue

    if (!freeCleanNoSusEssayContent) {

      console.error('âŒ freeCleanNoSusEssayContent NOT FOUND in DOM! Looking for element...');

      // Try to find it again in case it was just created

      const retryContent = document.getElementById('freeCleanNoSusEssayContent');

      if (retryContent) {

        console.log('âœ… Found freeCleanNoSusEssayContent on retry');

        // Update the reference

        const retryContainer = document.getElementById('freeCleanNoSusEssayContainer');

        if (retryContainer) {

          retryContainer.style.display = 'block';

          retryContainer.style.visibility = 'visible';

          retryContainer.style.opacity = '1';

        }

    } else {

        console.error('âŒ freeCleanNoSusEssayContent STILL NOT FOUND after retry!');

      }

    }



    if (freeCleanNoSusEssayContainer && freeCleanNoSusEssayContent) {

      console.log('âœ… Both container and content elements found, attempting to populate...');

      if (essayTextForPreview && essayTextForPreview.trim().length > 0) {

        // Exact same logic as QuickFix Step 2 Clean No Sus: limit to first 5-7 lines, max 500 chars

        const lines = essayTextForPreview.split('\n').filter(line => line.trim().length > 0);

        const previewLines = lines.slice(0, 5); // First 5 non-empty lines

        let previewText = previewLines.join('\n');

        // Limit to 500 characters max

        if (previewText.length > 500) {

          previewText = previewText.substring(0, 500) + '...';

        }

        // Escape HTML to prevent XSS

        const escapedPreview = previewText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');



        // Same HTML structure as QuickFix Step 2 Clean No Sus (line 9083) - but store FULL text for copying

        // Store full text in a data attribute for copying

        freeCleanNoSusEssayContent.setAttribute('data-full-text', essayTextForPreview);



        // CRITICAL: Ensure content element is visible before populating

        freeCleanNoSusEssayContent.style.setProperty('display', 'block', 'important');

        freeCleanNoSusEssayContent.style.setProperty('visibility', 'visible', 'important');

        freeCleanNoSusEssayContent.style.setProperty('opacity', '1', 'important');

        freeCleanNoSusEssayContent.style.setProperty('min-height', '50px', 'important');



        freeCleanNoSusEssayContent.innerHTML = `<div style="font-weight: 700; color: #374151; margin-bottom: 12px; font-size: 14px; text-align: center;">Your Essay Preview:</div><p style="white-space: pre-wrap; word-wrap: break-word; margin: 0; padding: 0;">${escapedPreview}</p>`;

        freeCleanNoSusEssayContent.style.borderLeft = '4px solid #2ecc71';

        freeCleanNoSusEssayContent.style.borderRight = '4px solid #2ecc71';



        // Verify content is actually set

        const contentAfterSet = freeCleanNoSusEssayContent.innerHTML;

        console.log('âœ… Content innerHTML after setting:', {

          length: contentAfterSet.length,

          preview: contentAfterSet.substring(0, 100),

          hasContent: contentAfterSet.length > 0,

          computedDisplay: window.getComputedStyle(freeCleanNoSusEssayContent).display,

          computedVisibility: window.getComputedStyle(freeCleanNoSusEssayContent).visibility,

          computedOpacity: window.getComputedStyle(freeCleanNoSusEssayContent).opacity

        });



        // Show copy button for Clean No Sus - Same as QuickFix Step 2

        const freeCleanNoSusCopyTextCTA = document.getElementById('freeCleanNoSusCopyTextCTA');

        if (freeCleanNoSusCopyTextCTA) {

          freeCleanNoSusCopyTextCTA.style.setProperty('display', 'block', 'important');

          freeCleanNoSusCopyTextCTA.style.setProperty('visibility', 'visible', 'important');

          freeCleanNoSusCopyTextCTA.style.setProperty('opacity', '1', 'important');

          console.log('âœ… Showing FREE Clean No Sus copy button');

        }



        console.log('âœ… SUCCESS: Populated FREE Clean No Sus essay preview! Preview length:', previewText.length, 'Full text length:', essayTextForPreview.length);

        console.log('âœ… Content element innerHTML length after population:', freeCleanNoSusEssayContent.innerHTML.length);

    } else {

        // No text available - show placeholder

        console.warn('âš ï¸ No essay text available - showing placeholder message');

        freeCleanNoSusEssayContent.innerHTML = `<div style="font-weight: 700; color: #374151; margin-bottom: 12px; font-size: 14px; text-align: center;">Your Essay Preview:</div><p style="color: #6b7280; font-style: italic;">No essay text available to display. Please try scanning again.</p>`;

        console.warn('âš ï¸ No essay text available for FREE Clean No Sus preview:', {

          hasContainer: !!freeCleanNoSusEssayContainer,

          hasContent: !!freeCleanNoSusEssayContent,

          textVar: text ? text.substring(0, 50) + '...' : 'NO TEXT VAR',

          essayInputValue: essayInput && essayInput.value ? essayInput.value.substring(0, 50) + '...' : 'NO ESSAY INPUT',

          appStateOriginal: appState.originalText ? appState.originalText.substring(0, 50) + '...' : 'NO APPSTATE ORIGINAL'

        });

      }

    } else {

      console.error('âŒ CRITICAL: FREE Clean No Sus essay container elements not found!', {

        hasContainer: !!freeCleanNoSusEssayContainer,

        hasContent: !!freeCleanNoSusEssayContent,

        containerId: freeCleanNoSusEssayContainer ? freeCleanNoSusEssayContainer.id : 'NOT FOUND',

        contentId: freeCleanNoSusEssayContent ? freeCleanNoSusEssayContent.id : 'NOT FOUND'

      });

    }



    // REMOVED: Don't show the green box with main character energy message for Clean No Sus

    // User requested to remove this box from the FREE Clean No Sus page only

    const freeCleanNoSusMainCharacterBox = document.getElementById('freeCleanNoSusMainCharacterBox');

    if (freeCleanNoSusMainCharacterBox) {

      // Force hide with multiple methods to ensure it stays hidden

      freeCleanNoSusMainCharacterBox.style.setProperty('display', 'none', 'important');

      freeCleanNoSusMainCharacterBox.style.setProperty('visibility', 'hidden', 'important');

      freeCleanNoSusMainCharacterBox.style.setProperty('opacity', '0', 'important');

      freeCleanNoSusMainCharacterBox.style.setProperty('position', 'absolute', 'important');

      freeCleanNoSusMainCharacterBox.style.setProperty('left', '-9999px', 'important');

      freeCleanNoSusMainCharacterBox.style.setProperty('height', '0', 'important');

      freeCleanNoSusMainCharacterBox.style.setProperty('overflow', 'hidden', 'important');

      freeCleanNoSusMainCharacterBox.remove(); // Actually remove it from DOM entirely

      console.log('âœ… Removed freeCleanNoSusMainCharacterBox from DOM for Clean No Sus (removed per user request)');

    }



    // REMOVED: Old essayPreviewContent container has been deleted from HTML - only using freeCleanNoSusEssayContainer now

    console.log('âœ… Clean No Sus: Using freeCleanNoSusEssayContainer (old essayPreviewContent removed)');



  // FREE RESULTS: Do NOT start progress bar animation here

  // Progress bar will only run AFTER modal closes (see closeOverlayAndShowEssay function)

  // This prevents the progress bar from running twice

  console.log('â¸ï¸ FREE RESULTS: Progress bar animation paused - will start after modal closes');



  // Set progress bar to 0% initially (but don't animate yet)

  try {

    let fillEl;

    if (cardToShow === 'hellaSus') {

      fillEl = document.getElementById('hellaSusProgressFill');

    } else if (cardToShow === 'kindaSus') {

      fillEl = document.getElementById('kindaSusProgressFill');

    } else if (cardToShow === 'youreGood') {

      fillEl = document.getElementById('youreGoodProgressFill');

    }



    if (fillEl) {

      const clampedScore = Math.max(0, Math.min(100, score));

      // Set initial width to 0% but NO transition/animation

      fillEl.style.width = '0%';

      fillEl.style.transition = 'none'; // No animation yet



      // Set background color based on score (but don't animate) - Use getProgressFillGradient for consistency

      if (typeof getProgressFillGradient === 'function') {

        fillEl.style.background = getProgressFillGradient(clampedScore);

      } else {

        // Fallback gradients using correct #FFF000 yellow

        if (clampedScore <= 29) {

          fillEl.style.background = '#10b981'; // Green only

        } else if (clampedScore <= 69) {

          fillEl.style.background = `linear-gradient(to right, #10b981 0%, #10b981 29%, #FFF000 30%, #FFF000 ${clampedScore}%)`;

        } else {

          fillEl.style.background = `linear-gradient(to right, #10b981 0%, #10b981 29%, #FFF000 30%, #FFF000 69%, #ef4444 70%, #ef4444 ${clampedScore}%)`;

        }

      }



      // Reset indicator to 0 but don't animate

      let indicatorId;

      if (cardToShow === 'hellaSus') {

        indicatorId = 'hellaSusProgressIndicator';

      } else if (cardToShow === 'kindaSus') {

        indicatorId = 'kindaSusProgressIndicator';

      } else if (cardToShow === 'youreGood') {

        indicatorId = 'youreGoodProgressIndicator';

      }



      if (indicatorId) {

        const indicator = document.getElementById(indicatorId);

        if (indicator) {

          indicator.style.left = '0%';

          indicator.style.transition = 'none'; // No animation yet

        }

      }

    }

  } catch (e) {

    console.error('Error setting initial progress bar state:', e);

  }



  // Checkpoint: After startProgressAnimations

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After startProgressAnimations'

    }));

  } catch (e) {}



  // Common elements for all cards

  const flagCountEl = document.getElementById('freeFlagCountText');

  const triggerHeadingEl = document.getElementById('freeTriggerHeading');

  const extraFlagsSummaryEl = document.getElementById('freeExtraFlagsSummary');

  const unlockOverlayHeading = document.getElementById('unlockOverlayHeading');

  const quickfixUnlockButton = document.getElementById('quickfixUnlockButton');



  // Checkpoint: After getting common elements

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After getting common elements',

      hasQuickfixButton: !!quickfixUnlockButton

    }));

  } catch (e) {}



  // Update unlock overlay heading color based on score

  if (unlockOverlayHeading) {

    if (score >= 70) {

      unlockOverlayHeading.style.color = '#dc2626'; // Red for Hella Sus

    } else if (score >= 30) {

      unlockOverlayHeading.style.color = '#374151'; // Black for Kinda Sus

    } else {

      unlockOverlayHeading.style.color = '#374151'; // Dark gray for You're Good

    }

  }



  // Adjust spacing under the trigger count line for Hella Sus only

  if (flagCountEl) {

    if (score >= 70) {

      // Decrease bottom margin (tighter to the extra flags line)

      flagCountEl.style.marginBottom = '0px';

    } else {

      // Default spacing for other scores

      flagCountEl.style.marginBottom = '4px';

    }

  }



  // Checkpoint: Before QuickFix button innerHTML (potential hang point)

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'Before QuickFix button innerHTML',

      score: score,

      hasQuickfixButton: !!quickfixUnlockButton

    }));

  } catch (e) {}



  // Show/hide QuickFix button based on score (show for clean to offer $1.99)

  if (quickfixUnlockButton) {

    if (score < 30) {

      quickfixUnlockButton.style.display = 'inline-flex';

      quickfixUnlockButton.style.visibility = 'visible';

      quickfixUnlockButton.style.opacity = '1';



      // FIXED: Simplify innerHTML to prevent hang (complex styles can cause browser freeze)

      // Use simpler HTML without complex text-shadow/filter combinations

      quickfixUnlockButton.innerHTML = '<span style="color: #ffffff !important; font-weight: bold;">âš¡</span> Get QuickFix';

    } else {

    quickfixUnlockButton.style.display = 'none';

    quickfixUnlockButton.style.visibility = 'hidden';

    quickfixUnlockButton.style.opacity = '0';

    }

  }



  // Checkpoint: After QuickFix button innerHTML

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After QuickFix button innerHTML'

    }));

  } catch (e) {}



  // For Hella Sus, also immediately hide and update buttons

  if (score >= 70) {

    setTimeout(() => {

      const quickfixBtn = document.getElementById('quickfixUnlockButton');

      if (quickfixBtn) {

        quickfixBtn.style.display = 'none';

        quickfixBtn.style.visibility = 'hidden';

        quickfixBtn.style.opacity = '0';

      }

    }, 50);

  }





  // Update "Scan Another Essay" button with dynamic scan count

  // Use the current appState.scansUsed (already incremented by incrementScans())

  // Function to update the button

  function updateScanAnotherButton() {

    const scanAnotherButton = document.getElementById('scanAnotherEssayBtn');

    if (scanAnotherButton) {

      // Always sync from storage first to ensure accuracy

      appState.scansUsed = getScansUsed();

      // Match the front page format: show actual scans used (not next scan number)

      const scansUsed = Math.min(appState.scansUsed, FREE_SCAN_LIMIT);

      scanAnotherButton.textContent = `ðŸ“ Scan Another Essay (${scansUsed}/${FREE_SCAN_LIMIT})`;

      console.log('âœ… Updated Scan Another Essay button:', scansUsed, '/', FREE_SCAN_LIMIT, 'appState.scansUsed:', appState.scansUsed);

      return true;

    }

    console.warn('âš ï¸ scanAnotherEssayBtn button not found');

    return false;

  }



  // Try to update immediately

  if (!updateScanAnotherButton()) {

    // TEMPORARILY DISABLED: All async callbacks to prevent hang

    // Just skip if button not found - not critical

    console.log('âš ï¸ scanAnotherEssayBtn not found, skipping update');

  }



  // Checkpoint: Before getDynamicPhrase

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'Before getDynamicPhrase',

      score: score

    }));

  } catch (e) {}



  // Get dynamic phrase for this score

  let dynamicPhrase = getDynamicPhrase(score);



  // Checkpoint: After getDynamicPhrase

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'After getDynamicPhrase',

      dynamicPhrase: dynamicPhrase

    }));

  } catch (e) {}



  // Format phrase for header (add apostrophe for "Bussin", add exclamation)

  let headerPhrase = dynamicPhrase;

  if (dynamicPhrase === "Bussin") {

    headerPhrase = "Bussin'!";

  } else if (dynamicPhrase.includes(" ")) {

    // For phrases with spaces, just add exclamation

    headerPhrase = dynamicPhrase + "!";

  } else {

    // For single words, add exclamation

    headerPhrase = dynamicPhrase + "!";

  }



  // Update headers with dynamic phrase

  if (score >= 70) {

    // Hella Sus

    const hellaSusPhrase = document.getElementById('hellaSusPhrase');

    if (hellaSusPhrase) {

      hellaSusPhrase.textContent = headerPhrase;

    }

  } else if (score >= 30) {

    // Kinda Sus

    const kindaSusPhrase = document.getElementById('kindaSusPhrase');

    if (kindaSusPhrase) {

      kindaSusPhrase.textContent = headerPhrase;

    }

  } else {

    // You're Good

    const youreGoodPhrase = document.getElementById('youreGoodPhrase');

    if (youreGoodPhrase) {

      youreGoodPhrase.textContent = headerPhrase;

    }

  }



  // Update trigger heading

  if (triggerHeadingEl) {

    const headingText = document.getElementById('freeTriggerHeadingText');

    if (headingText) {

      const shownCount = Math.min(5, flagCount); // Show up to 5 in preview, but keep total count



      // Determine box color based on score range

      let boxBgColor = '#d1fae5'; // Light green background for Low Sus (0-29%)

      let boxBorderColor = '#2ecc71'; // Green border

      let boxTextColor = '#047857'; // Dark green text



      if (score >= 70) {

        boxBgColor = '#fee2e2'; // Light red background for Hella Sus (70-100%)

        boxBorderColor = '#dc2626'; // Red border

        boxTextColor = '#991b1b'; // Dark red text

      } else if (score >= 30) {

        boxBgColor = '#fef3c7'; // Light yellow background for Kinda Sus (30-69%)

        boxBorderColor = '#eed202'; // Yellow border

        boxTextColor = '#92400e'; // Dark yellow/brown text

      }



      // Checkpoint: Before headingText innerHTML (potential hang point)

      try {

        localStorage.setItem('fff_last_checkpoint', JSON.stringify({

          time: new Date().toISOString(),

          checkpoint: 'Before headingText innerHTML',

          score: score,

          flagCount: flagCount

        }));

      } catch (e) {}



      // SIMPLIFIED: Use createElement instead of complex innerHTML to prevent hang

      headingText.textContent = ''; // Clear first

      headingText.appendChild(document.createTextNode('âš¡ AI Trigger Words/Phrases: '));



      // Determine color based on score (green for Clean/No Sus, red for others)

      const numberColor = (score < 30) ? '#2ecc71' : '#dc2626'; // Green for Clean/No Sus, red for others

      const fontSize = (score < 30) ? '22px' : '20px'; // Bigger font for Clean/No Sus



      // Create first span

      const span1 = document.createElement('span');

      span1.style.color = numberColor;

      span1.style.fontWeight = '800';

      span1.textContent = shownCount;

      headingText.appendChild(span1);



      headingText.appendChild(document.createTextNode(' Shown '));



      // Create second span

      const span2 = document.createElement('span');

      span2.style.color = numberColor;

      span2.style.fontWeight = '800';

      span2.textContent = flagCount;

      headingText.appendChild(span2);



      headingText.appendChild(document.createTextNode(' Detected'));



      // Set font size (bigger for Clean/No Sus)

      headingText.style.fontSize = fontSize;

      headingText.style.fontWeight = '800';



      // Checkpoint: After headingText innerHTML

      try {

        localStorage.setItem('fff_last_checkpoint', JSON.stringify({

          time: new Date().toISOString(),

          checkpoint: 'After headingText innerHTML'

        }));

      } catch (e) {}

    }

    // Add 1/4" padding (24px) for Kinda Sus page (30-69%)

    if (score >= 30 && score < 70) {

      triggerHeadingEl.style.paddingTop = '24px';

    } else {

      triggerHeadingEl.style.paddingTop = '0';

    }

    // Reduce padding below heading by 1/4" (6px) for pages with trigger words (score >= 30)

    // Add 1/4" padding below heading for Clean No Sus page (score < 30)

    if (score >= 30) {

      const enforceHeadingMargin = () => {

        triggerHeadingEl.style.setProperty('margin-bottom', '6px', 'important');

      };



      // Apply immediately

      enforceHeadingMargin();



      // Use MutationObserver to watch for style changes

      const headingObserver = new MutationObserver(() => {

        enforceHeadingMargin();

      });

      headingObserver.observe(triggerHeadingEl, {

        attributes: true,

        attributeFilter: ['style']

      });



      // Store observer for cleanup

      if (!window._activeObservers) window._activeObservers = [];

      window._activeObservers.push(headingObserver);



      // Also apply periodically as backup

      const headingInterval = setInterval(() => {

        if (document.body.contains(triggerHeadingEl)) {

          enforceHeadingMargin();

        } else {

          clearInterval(headingInterval);

          if (window._headingInterval === headingInterval) {

            window._headingInterval = null;

          }

        }

      }, 100);

      window._headingInterval = headingInterval; // Store for cleanup



      console.log('âœ… Set heading margin-bottom to 6px for score', score);

    } else {

      // Clean No Sus page: Add 1/4" (6px) padding below heading

      const enforceCleanHeadingMargin = () => {

        triggerHeadingEl.style.setProperty('margin-bottom', '18px', 'important'); // 12px default + 6px = 18px

      };



      enforceCleanHeadingMargin();



      const cleanHeadingObserver = new MutationObserver(() => {

        enforceCleanHeadingMargin();

      });

      cleanHeadingObserver.observe(triggerHeadingEl, {

        attributes: true,

        attributeFilter: ['style']

      });



      // Store observer for cleanup

      if (!window._activeObservers) window._activeObservers = [];

      window._activeObservers.push(cleanHeadingObserver);



      const cleanHeadingInterval = setInterval(() => {

        if (document.body.contains(triggerHeadingEl)) {

          enforceCleanHeadingMargin();

        } else {

          clearInterval(cleanHeadingInterval);

          if (window._cleanHeadingInterval === cleanHeadingInterval) {

            window._cleanHeadingInterval = null;

          }

        }

      }, 100);

      window._cleanHeadingInterval = cleanHeadingInterval; // Store for cleanup



      console.log('âœ… Clean No Sus: Set heading margin-bottom to 18px');

    }

  }



  // Update lock heading above lock box - hide for Clean No Sus page

  const lockHeading = document.getElementById('freeLockHeading');

  if (lockHeading) {

    if (score >= 30) {

      // Show on Hella Sus + Kinda Sus

      lockHeading.textContent = `ðŸ”“ Unlock All ${flagCount} â€¢ One-time with âš¡ QuickFix OR All Month with ðŸ’Ž Pro`;

      lockHeading.style.display = 'block';

    } else {

      // Hide on Clean No Sus results page

      lockHeading.textContent = '';

      lockHeading.style.display = 'none';

    }

  }



  // Hide "What's the Move?" section for Clean No Sus page

  const whatsTheMoveHeading = document.getElementById('whatsTheMoveHeading');

  if (whatsTheMoveHeading) {

    if (score < 30) {

      whatsTheMoveHeading.style.display = 'none';

      console.log('âœ… Clean No Sus: Hidden "What\'s the Move?" section');

    } else {

      whatsTheMoveHeading.style.display = 'block';

    }

  }



  // Update flag count message - show dynamic phrase with emoji

  if (flagCountEl) {

    const flagCountMessage = document.getElementById('freeFlagCountMessage');

    if (flagCountMessage) {

      const emoji = getPhraseEmoji(dynamicPhrase);

      flagCountMessage.textContent = `${emoji} ${dynamicPhrase}`;

      // Ensure font size is preserved

      flagCountMessage.style.fontSize = '22px';

      flagCountMessage.style.fontWeight = '600';

    }

    // For Hella Sus only: Add 1/4" padding below "Nope" dynamic word

    if (score >= 70) {

      flagCountEl.style.marginBottom = '8px';

      flagCountEl.style.paddingBottom = '24px';

    } else if (score >= 30) {

      // Kinda Sus: Add 1/2" padding (48px) + 1/4" additional (24px) = 72px total at the bottom of dynamic phrase

      flagCountEl.style.paddingBottom = '72px';

    } else {

      // Reduce padding below by 1/4" (24px) for other cases

      flagCountEl.style.marginBottom = '-16px';

    }

  }



  // Show/hide Zero AI Trigger Words box - only for clean scores (0-29%)

  // Zero trigger box removed - always hidden

  const freeZeroTriggerBox = document.getElementById('freeZeroTriggerBox');

  if (freeZeroTriggerBox) {

      freeZeroTriggerBox.style.display = 'none';

  }



  if (extraFlagsSummaryEl) {

    if (extraCount > 0) {

      extraFlagsSummaryEl.style.display = 'block';

      // For Kinda Sus and Hella Sus, show a generic message about additional locked triggers

      extraFlagsSummaryEl.textContent =

        'More AI-trigger words were found in your text â€” but they\'re locked in free mode. Unlock QuickFix to see them all and reduce your AI detection risk.';

      // Reduce padding below by 1/2" (12px) and reduce top margin to close gap for all pages (score >= 30)

      // For Hella Sus, add 1/4" (6px) more padding below

      if (score >= 30) {

        const marginBottom = score >= 70 ? '26px' : '20px'; // Hella Sus: 20px + 6px = 26px



        const enforceExtraFlagsMargin = () => {

          extraFlagsSummaryEl.style.setProperty('margin-top', '-22px', 'important');

          extraFlagsSummaryEl.style.setProperty('margin-bottom', marginBottom, 'important');

        };



        // Apply immediately

        enforceExtraFlagsMargin();



        // Use MutationObserver to watch for style changes

        const extraFlagsObserver = new MutationObserver(() => {

          enforceExtraFlagsMargin();

        });

        extraFlagsObserver.observe(extraFlagsSummaryEl, {

          attributes: true,

          attributeFilter: ['style']

        });



        // Store observer for cleanup

        if (!window._activeObservers) window._activeObservers = [];

        window._activeObservers.push(extraFlagsObserver);



        // Also apply periodically as backup

        const extraFlagsInterval = setInterval(() => {

          if (document.body.contains(extraFlagsSummaryEl)) {

            enforceExtraFlagsMargin();

          } else {

            clearInterval(extraFlagsInterval);

            if (window._extraFlagsInterval === extraFlagsInterval) {

              window._extraFlagsInterval = null;

            }

          }

        }, 100);

        window._extraFlagsInterval = extraFlagsInterval; // Store for cleanup



        console.log('âœ… Set extraFlagsSummary margin-top to -22px, margin-bottom to', marginBottom, 'for score', score);

      }

    } else {

      extraFlagsSummaryEl.style.display = 'none';

      extraFlagsSummaryEl.textContent = '';

    }

  }



  // ========= MIDDLE CARD: TRIGGER CHIPS =========

  const chipsContainerJan10 = document.getElementById('freeTriggerChips');

  const chipsHint = document.getElementById('freeTriggerChipsHint');



  // Show/hide the hover hint based on whether there are chips to display

  if (chipsHint) {

    const hasChips = previewFlags.length > 0;

    // Clean free results: hide the hint entirely

    if (score < 30) {

      chipsHint.style.display = 'none';

    } else {

      chipsHint.style.display = hasChips ? 'block' : 'none';

      // Add 1/2" padding (12px) above hover hint for Hella Sus page (70+), and 1/4" padding (6px) below

      requestAnimationFrame(() => {

        if (score >= 70) {

          const enforceChipsHintMargin = () => {

            chipsHint.style.setProperty('margin-top', '42px', 'important'); // 30px + 12px = 42px

            chipsHint.style.setProperty('margin-bottom', '14px', 'important');

          };



          enforceChipsHintMargin();



          // Use MutationObserver to watch for style changes

          const chipsHintObserver = new MutationObserver(() => {

            enforceChipsHintMargin();

          });

          chipsHintObserver.observe(chipsHint, {

            attributes: true,

            attributeFilter: ['style']

          });



          // Store observer for cleanup

          if (!window._activeObservers) window._activeObservers = [];

          window._activeObservers.push(chipsHintObserver);



          // Also apply periodically as backup

          const chipsHintInterval = setInterval(() => {

            if (document.body.contains(chipsHint)) {

              enforceChipsHintMargin();

            } else {

              clearInterval(chipsHintInterval);

              if (window._chipsHintInterval === chipsHintInterval) {

                window._chipsHintInterval = null;

              }

            }

          }, 100);

          window._chipsHintInterval = chipsHintInterval; // Store for cleanup



          console.log('âœ… Hella Sus: Set chipsHint margin-top to 42px, margin-bottom to 14px');

        } else {

          let currentStyle = chipsHint.getAttribute('style') || '';

          currentStyle = currentStyle.replace(/margin:\s*[^;]+;?/gi, '').trim();

          currentStyle = currentStyle + (currentStyle ? ' ' : '') + 'margin: 30px 0 8px 0;';

          chipsHint.setAttribute('style', currentStyle);

        }

      });

    }

  }



  // CRITICAL FIX: Only render chips for scores >= 30

  // For clean scores (< 30), just hide the container and skip all chip rendering

  if (chipsContainer) {

    if (score < 30) {

      // Clean/No Sus - just hide it and skip all chip rendering

      chipsContainer.style.display = 'none';

      console.log('âœ… Clean/No Sus - skipping chip rendering entirely (score:', score, ')');

    } else {

      // Only render chips for Kinda Sus and Hella Sus (score >= 30)

    chipsContainer.innerHTML = '';



    // DEBUG: Log what we're trying to display

    console.log('ðŸ” Rendering trigger chips:', {

      previewFlags: previewFlags,

      analysisFlags: analysisFlags,

      flagCount: flagCount,

      previewCount: previewCount,

      score: score

    });



    // Determine chip colors based on score range

    let chipBgColor = '#fee2e2'; // Red for Hella Sus

    let chipBorderColor = '#dc2626';

    let chipTextColor = '#991b1b';



    // Use previewFlags for all score ranges - it's already calculated correctly above

    // LIMIT TO MAX 5 FLAGS

    let flagsToShow = previewFlags.slice(0, 5);



    if (score >= 30 && score < 70) {

      // Red for Kinda Sus (Free version)

      chipBgColor = '#fee2e2';

      chipBorderColor = '#dc2626';

      chipTextColor = '#991b1b';

    }



    // Structural keyword helpers to distinguish structural vs direct phrase flags

    const structuralKeywords = [

      'no contractions',

      'no personal voice',

      'overly formal',

      'overall writing',

      'overall patterns',

      'overall text',

      'lacks human',

      'too formal'

    ];



    // DYNAMIC TOOLTIP EXPLANATIONS

    const tooltipMap = {

      // Buzzword/Corporate Jargon

      "leverage cutting-edge solutions": "Overused corporate buzzword phrase",

      "cutting-edge solutions": "Generic tech jargon - sounds AI-generated",

      "leverage cutting-edge": "Vague business terminology",

      "cutting-edge": "Buzzword frequently used in AI-generated content",

      "leverage": "Corporate jargon that AI models overuse",



      // Exaggerated Claims

      "unprecedented levels of efficiency": "Exaggerated claim common in AI writing",

      "unprecedented levels of": "Overly dramatic language",

      "achieve unprecedented levels": "Grandiose statement",

      "unprecedented levels": "Overly formal phrasing commonly generated by AI models",

      "unprecedented": "Overly formal phrasing commonly generated by AI models",



      // ClichÃ© Phrases

      "rapidly evolving digital landscape": "ClichÃ© opening phrase in AI business writing",

      "in today's rapidly evolving digital landscape": "Overused introductory phrase",



      // Structural Phrases

      "furthermore": "Transition word overused in AI essays",

      "moreover": "Academic transition common in AI writing",

      "in conclusion": "Formulaic conclusion phrase",

      "it is important to note": "Redundant academic phrasing",

      "the fact that": "Wordy construction AI loves",

      "consequently": "Formal connector frequently used by AI",

      "thus": "Formal transition word typical of AI content",

      "more important": "Generic transition phrase common in AI writing",

      "in new ways": "Vague phrasing typical of AI-generated text",

      "synergy": "Corporate buzzword often found in AI content",

      "utilize": "Overly formal alternative to 'use' favored by AI"

    };



    // CRITICAL: Number trigger chips by ORDER THEY APPEAR IN TEXT (not array index)

    // Find positions of each phrase in the text and sort by position

    // CRITICAL: Only use flags that ACTUALLY appear in the essay text

    const flagsWithPositions = flagsToShow.map((flag, arrayIndex) => {

      const phrase = (flag.phrase || flag.word || flag.text || '').trim();

      if (!phrase) {

        console.warn('âš ï¸ Flag missing phrase:', flag);

        return null;

      }



      // Find first occurrence in text

      const escapedPhrase = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

      const regex = new RegExp(escapedPhrase, 'gi');

      const match = regex.exec(text);

      const position = match ? match.index : 999999;



      return {

        flag: flag,

        phrase: phrase,

        arrayIndex: arrayIndex,

        position: position

      };

    }).filter(item => item !== null);



    // Sort by position in text (ORDER OF APPEARANCE)

    flagsWithPositions.sort((a, b) => a.position - b.position);



    // Now create chips numbered 1, 2, 3, 4, 5 by order of appearance

    flagsWithPositions.forEach((item, textOrderIndex) => {

      const flag = item.flag;

      const phrase = item.phrase;

      const lowerPhrase = phrase.toLowerCase();

      const isStructural = structuralKeywords.some(kw => lowerPhrase.includes(kw));



      const chip = document.createElement('span');

      chip.className = 'trigger-chip';



      // Create number badge - NUMBER BY ORDER IN TEXT (1, 2, 3, 4, 5)

      const numberBadge = document.createElement('span');

      numberBadge.className = 'flag-number';

      numberBadge.textContent = textOrderIndex + 1; // 1, 2, 3, 4, 5 based on text order

      // Use red background with white text for Kinda Sus (Free version), red for Hella Sus

      const badgeBgColor = (score >= 30 && score < 70) ? '#dc2626' : '#dc2626';

      const badgeTextColor = (score >= 30 && score < 70) ? 'white' : 'white';

      numberBadge.style.cssText = `background: ${badgeBgColor}; color: ${badgeTextColor}; border-radius: 50%; width: 14px; height: 14px; display: inline-flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; margin-right: 4px; flex-shrink: 0;`;



      // Add number, phrase and optional structural label to chip

      chip.appendChild(numberBadge);

      chip.appendChild(document.createTextNode(phrase));

      if (isStructural) {

        const structuralLabel = document.createElement('span');

        structuralLabel.textContent = '[Structure]';

        structuralLabel.style.cssText = 'font-size: 10px; font-weight: 600; color: #0b0646; background: rgba(148, 163, 184, 0.18); border-radius: 999px; padding: 1px 6px; margin-left: 6px; display: inline-flex; align-items: center; gap: 2px;';



        const icon = document.createElement('span');

        icon.textContent = 'âš ï¸';

        icon.style.cssText = 'font-size: 11px;';



        structuralLabel.insertBefore(icon, structuralLabel.firstChild);

        chip.appendChild(structuralLabel);

      }



      // Get explanation - check exact phrase first, then lowercase

      const tooltipText = flag.explanation || 

                          tooltipMap[phrase] || 

                          tooltipMap[phrase.toLowerCase()] || 

                          `"${phrase}" is commonly flagged by AI detection tools`;



      // Set the tooltip (DO NOT REMOVE!)

      chip.title = tooltipText;

      chip.setAttribute('data-bs-toggle', 'tooltip');

      chip.setAttribute('data-bs-placement', 'top');



      // Keep the styling

      chip.style.cssText = `background: ${chipBgColor} !important; border: 1.5px solid ${chipBorderColor} !important; color: ${chipTextColor} !important; padding: 2px 5px !important; border-radius: 16px !important; font-size: 9px !important; font-weight: 600 !important; cursor: help !important; position: relative !important; display: inline-flex !important; align-items: center !important; line-height: 1.2 !important;`;



      // Add custom tooltip on hover (keep for enhanced styling)

      chip.addEventListener('mouseenter', function(e) {

        // Remove any existing tooltip first

        const existingTooltip = document.getElementById('triggerTooltip');

        if (existingTooltip) existingTooltip.remove();



        const tooltip = document.createElement('div');

        tooltip.id = 'triggerTooltip';

        tooltip.textContent = tooltipText;



        // Create arrow element

        const arrow = document.createElement('div');

        arrow.className = 'trigger-tooltip-arrow';



        tooltip.style.cssText = `

          position: fixed;

          background: white;

          color: #0b0646;

          border: 2px dotted #dc2626;

          padding: 6px 8px;

          border-radius: 6px;

          font-size: 12px;

          font-weight: 500;

          letter-spacing: 0.3px;

          max-width: 200px;

          white-space: normal;

          word-wrap: break-word;

          z-index: 10000;

          box-shadow: 0 2px 8px rgba(0,0,0,0.3);

          pointer-events: none;

          text-align: left;

          line-height: 1.4;

          opacity: 0;

          transition: opacity 0.2s ease;

        `;



        tooltip.appendChild(arrow);

        document.body.appendChild(tooltip);



        // Position tooltip relative to chip

        setTimeout(() => {

          const chipRect = chip.getBoundingClientRect();

          const tooltipRect = tooltip.getBoundingClientRect();

          const spaceAbove = chipRect.top;

          const spaceBelow = window.innerHeight - chipRect.bottom;



          let tooltipTop, tooltipLeft, arrowStyle;



          // Determine if tooltip should go above or below

          if (spaceAbove >= tooltipRect.height + 20 || spaceAbove >= spaceBelow) {

            // Show above

            tooltipTop = chipRect.top - tooltipRect.height - 8;

            arrowStyle = `

              position: absolute;

              bottom: -6px;

              left: 50%;

              transform: translateX(-50%);

              width: 0;

              height: 0;

              border-left: 6px solid transparent;

              border-right: 6px solid transparent;

              border-top: 6px solid #dc2626;

            `;

          } else {

            // Show below

            tooltipTop = chipRect.bottom + 8;

            arrowStyle = `

              position: absolute;

              top: -6px;

              left: 50%;

              transform: translateX(-50%);

              width: 0;

              height: 0;

              border-left: 6px solid transparent;

              border-right: 6px solid transparent;

              border-bottom: 6px solid #dc2626;

            `;

          }



          arrow.style.cssText = arrowStyle;



          // Center horizontally, but adjust if it would go off-screen

          tooltipLeft = chipRect.left + (chipRect.width / 2) - (tooltipRect.width / 2);



          if (tooltipLeft < 10) {

            tooltipLeft = 10;

            arrow.style.left = `${chipRect.left + (chipRect.width / 2) - 10}px`;

          } else if (tooltipLeft + tooltipRect.width > window.innerWidth - 10) {

            tooltipLeft = window.innerWidth - tooltipRect.width - 10;

            arrow.style.left = `${chipRect.right - (window.innerWidth - tooltipLeft - tooltipRect.width)}px`;

          }



          tooltip.style.left = tooltipLeft + 'px';

          tooltip.style.top = tooltipTop + 'px';

          tooltip.style.opacity = '1';

        }, 10);

      });



      chip.addEventListener('mouseleave', function() {

        const tooltip = document.getElementById('triggerTooltip');

        if (tooltip) {

          tooltip.style.opacity = '0';

          setTimeout(() => tooltip.remove(), 200);

        }

      });



      chipsContainer.appendChild(chip);

    });



    // NOTE: Urgent trigger warning card is now displayed via displayUrgentTriggerWarning() 

    // called after trigger chips rendering completes (see line ~19010)



    // DEBUG: Log if no chips were added

    if (flagsToShow.length === 0) {

      console.warn('âš ï¸ No trigger chips to display - flagsToShow is empty', {

        previewFlags: previewFlags,

        analysisFlags: analysisFlags,

        flagCount: flagCount,

        score: score

      });

    } else {

      console.log('âœ… Added', flagsToShow.length, 'trigger chips to display');

    }

    } // End of else block for score >= 30 chip rendering

  } // End of chipsContainer check



  console.log('âœ… Rendering trigger chips COMPLETE');



  // ========= URGENT TRIGGER WARNING CARD - REMOVED =========

  // Card has been removed per user request

  const urgentTriggerCard = document.getElementById('urgentTriggerWarningCard');

  if (urgentTriggerCard) {

    urgentTriggerCard.style.display = 'none';

  }



  // CRITICAL: Hide green "clean and ready" box for Kinda Sus and Hella Sus (score >= 30)

  // This box should ONLY show for Clean No Sus (score < 30)

  if (score >= 30) {

    const cleanMsgEl2 = document.getElementById('cleanEssayLilSusMessage');

    if (cleanMsgEl2) {

      cleanMsgEl2.style.display = 'none';

      cleanMsgEl2.style.visibility = 'hidden';

      cleanMsgEl2.style.opacity = '0';

      console.log('âœ… Hidden clean essay message for Kinda Sus/Hella Sus (score:', score, ')');

    }

  }



  // ========= ESSAY PREVIEW: REMOVED displayEssayPreview() call for FREE users =========

  // The old displayEssayPreview() function creates red highlight boxes - we don't want that for FREE users

  // The simplified highlighting code below will handle essay preview instead (plain text only, no highlights)

  console.log('DEBUG showFreeUserResult:', {

    previewFlags: previewFlags,

    analysisFlags: analysisFlags,

    score: score,

    text: text ? text.substring(0, 100) : 'NO TEXT'

  });



  // displayEssayPreview() removed - interactive essay box now handles essay display



  console.log('TRIGGER PILLS DEBUG - score:', score, 'previewFlags:', previewFlags, 'analysisFlags:', analysisFlags);



 // Only call showInteractiveEssayBox for scores 30+ (Kinda Sus and Hella Sus)

// Clean scores (0-29) should NOT show the interactive essay box

if (score >= 30) {

    // Call showInteractiveEssayBox for kinda sus and hella sus only

    showInteractiveEssayBox(score, essayText, triggers);

}

  // This ensures the essay box with blur, lock emoji, and CTAs appears for all users

  // Store data in appState for overlay fallback, but also call directly

  if (!appState.lastScanData) {

    appState.lastScanData = {};

  }

  appState.lastScanData.score = score;

  appState.lastScanData.triggers = previewFlags && previewFlags.length > 0 ? previewFlags : (analysisFlags || []);

  appState.lastScanData.essayText = text; // CRITICAL: Store the essay text



  console.log('ðŸ’¾ [DEBUG] Stored in appState.lastScanData:', {

    score: appState.lastScanData.score,

    triggersCount: appState.lastScanData.triggers.length,

    essayTextLength: appState.lastScanData.essayText ? appState.lastScanData.essayText.length : 0,

    essayTextPreview: appState.lastScanData.essayText ? appState.lastScanData.essayText.substring(0, 100) : 'NO TEXT'

  });



  console.log('ðŸš€ [DEBUG] Calling showInteractiveEssayBox directly for score:', score, 'triggers:', appState.lastScanData.triggers.length);



  // Call showInteractiveEssayBox directly for Kinda Sus and Hella Sus (score >= 30)

  // This ensures it appears even if overlays aren't shown

  if (score >= 30 && typeof showInteractiveEssayBox === 'function') {

    setTimeout(() => {

      const essayTextToPass = appState.lastScanData.essayText || text || '';

      console.log('ðŸš€ [DEBUG] Direct call to showInteractiveEssayBox - Score:', score, 'Range:', score < 70 ? 'Kinda Sus (30-69)' : 'Hella Sus (70+)', 'Essay text length:', essayTextToPass.length);

      showInteractiveEssayBox(score, appState.lastScanData.triggers, essayTextToPass);

    }, 500); // Small delay to ensure DOM is ready

  }

  // Simple trigger pills rendering

  const chipsContainer = document.getElementById('freeTriggerChips');

  const headingEl = document.getElementById('freeTriggerHeadingText');



  if (score >= 30 && chipsContainer && previewFlags && previewFlags.length > 0) {

    chipsContainer.innerHTML = '';

    const shownCount = Math.min(5, previewFlags.length);

    const detectedCount = analysisFlags.length;



    // Create pills

    for (let i = 0; i < shownCount; i++) {

      const flag = previewFlags[i];

      const phrase = flag.phrase || flag.word || flag.text || '';

      if (phrase) {

        const pill = document.createElement('span');

        pill.textContent = (i + 1) + '. ' + phrase;

        pill.style.cssText = 'background: #dc2626; color: white; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; display: inline-block; margin: 4px;';

        chipsContainer.appendChild(pill);

      }

    }



    // Update heading - BUT HIDE IT FOR KINDA SUS (30-69%) AND HELLA SUS (70+)

    if (headingEl) {

      if (score >= 30) {

        // Hide the heading for Kinda Sus and Hella Sus

        const triggerHeading = document.getElementById('freeTriggerHeading');

        if (triggerHeading) {

          triggerHeading.style.display = 'none';

          triggerHeading.style.visibility = 'hidden';

          triggerHeading.style.opacity = '0';

          triggerHeading.style.height = '0';

          triggerHeading.style.margin = '0';

          triggerHeading.style.padding = '0';

          triggerHeading.style.overflow = 'hidden';

          console.log('âœ… Hidden trigger heading for', score < 70 ? 'Mid Sus' : 'Major Sus');

        }

        // Also hide the entire card container to close the gap

        const triggerCard = document.getElementById('freeTriggerWordsCard');

        if (triggerCard) {

          triggerCard.style.display = 'none';

          triggerCard.style.visibility = 'hidden';

          triggerCard.style.opacity = '0';

          triggerCard.style.height = '0';

          triggerCard.style.margin = '0';

          triggerCard.style.padding = '0';

          triggerCard.style.overflow = 'hidden';

          console.log('âœ… Hidden trigger card container for', score < 70 ? 'Mid Sus' : 'Major Sus', 'to close gap');

        }

      } else {

        // For Clean/No Sus, update the heading text

        headingEl.innerHTML = `âš¡ AI Trigger Words/Phrases: <span style=\"color: #dc2626; font-weight: 800;\">${shownCount}</span> Shown <span style=\"color: #dc2626; font-weight: 800;\">${detectedCount}</span> Detected`;

      }

    }



    console.log('âœ… Trigger pills rendered:', shownCount, 'shown,', detectedCount, 'detected');

  }



  // Hide lockbox for FREE users so essay preview and trigger pills are visible

  const lockbox = document.getElementById('freeUnlockOverlay');

  if (lockbox) {

    lockbox.style.display = 'none';

    lockbox.style.visibility = 'hidden';

    lockbox.style.opacity = '0';

    lockbox.style.pointerEvents = 'none';

    console.log('âœ… Lockbox hidden for FREE essay preview visibility');

  }



  // CRITICAL FIX: Only render chips for scores >= 30

  // For clean scores (< 30), just hide the container and skip all chip rendering

  if (chipsContainer) {

    if (score < 30) {

      // Clean/No Sus - just hide it and skip all chip rendering

      chipsContainer.style.display = 'none';

      console.log('âœ… Clean/No Sus - skipping chip rendering entirely (score:', score, ')');

    } else {

      // Only render chips for Kinda Sus and Hella Sus (score >= 30)

    chipsContainer.innerHTML = '';



    // DEBUG: Log what we're trying to display

    console.log('ðŸ” Rendering trigger chips:', {

      previewFlags: previewFlags,

      analysisFlags: analysisFlags,

      flagCount: flagCount,

      previewCount: previewCount,

      score: score

    });



    // Determine chip colors based on score range

    let chipBgColor = '#fee2e2'; // Red for Hella Sus

    let chipBorderColor = '#dc2626';

    let chipTextColor = '#991b1b';



    // Use previewFlags for all score ranges - it's already calculated correctly above

    // LIMIT TO MAX 5 FLAGS

    let flagsToShow = previewFlags.slice(0, 5);



    if (score >= 30 && score < 70) {

      // Red for Kinda Sus (Free version)

      chipBgColor = '#fee2e2';

      chipBorderColor = '#dc2626';

      chipTextColor = '#991b1b';

    }



    // Structural keyword helpers to distinguish structural vs direct phrase flags

    const structuralKeywords = [

      'no contractions',

      'no personal voice',

      'overly formal',

      'overall writing',

      'overall patterns',

      'overall text',

      'lacks human',

      'too formal'

    ];



    // DYNAMIC TOOLTIP EXPLANATIONS

    const tooltipMap = {

      // Buzzword/Corporate Jargon

      "leverage cutting-edge solutions": "Overused corporate buzzword phrase",

      "cutting-edge solutions": "Generic tech jargon - sounds AI-generated",

      "leverage cutting-edge": "Vague business terminology",

      "cutting-edge": "Buzzword frequently used in AI-generated content",

      "leverage": "Corporate jargon that AI models overuse",



      // Exaggerated Claims

      "unprecedented levels of efficiency": "Exaggerated claim common in AI writing",

      "unprecedented levels of": "Overly dramatic language",

      "achieve unprecedented levels": "Grandiose statement",

      "unprecedented levels": "Overly formal phrasing commonly generated by AI models",

      "unprecedented": "Overly formal phrasing commonly generated by AI models",



      // ClichÃ© Phrases

      "rapidly evolving digital landscape": "ClichÃ© opening phrase in AI business writing",

      "in today's rapidly evolving digital landscape": "Overused introductory phrase",



      // Structural Phrases

      "furthermore": "Transition word overused in AI essays",

      "moreover": "Academic transition common in AI writing",

      "in conclusion": "Formulaic conclusion phrase",

      "it is important to note": "Redundant academic phrasing",

      "the fact that": "Wordy construction AI loves",

      "consequently": "Formal connector frequently used by AI",

      "thus": "Formal transition word typical of AI content",

      "more important": "Generic transition phrase common in AI writing",

      "in new ways": "Vague phrasing typical of AI-generated text",

      "synergy": "Corporate buzzword often found in AI content",

      "utilize": "Overly formal alternative to 'use' favored by AI"

    };



    // CRITICAL: Number trigger chips by ORDER THEY APPEAR IN TEXT (not array index)

    // Find positions of each phrase in the text and sort by position

    // CRITICAL: Only use flags that ACTUALLY appear in the essay text

    const flagsWithPositions = flagsToShow.map((flag, arrayIndex) => {

      const phrase = (flag.phrase || flag.word || flag.text || '').trim();

      if (!phrase) {

        console.warn('âš ï¸ Flag missing phrase:', flag);

        return null;

      }



      // CRITICAL: Verify phrase ACTUALLY exists in essay text

      const phraseLower = phrase.toLowerCase();

      const textLower = text.toLowerCase();

      if (!textLower.includes(phraseLower)) {

        console.warn('âš ï¸ Flag phrase not found in essay text:', phrase, '- Skipping this flag');

        return null; // Skip flags that don't appear in the essay

      }



      // Find first occurrence in text

      const escapedPhrase = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

      const regex = new RegExp(escapedPhrase, 'gi');

      const match = regex.exec(text);

      const position = match ? match.index : 999999;



      if (position === 999999) {

        console.warn('âš ï¸ Could not find position for phrase:', phrase);

        return null; // Skip if position not found

      }



      return {

        flag: flag,

        phrase: phrase,

        arrayIndex: arrayIndex,

        position: position

      };

    }).filter(item => item !== null && item.position !== 999999);



    // Sort by position in text (ORDER OF APPEARANCE)

    flagsWithPositions.sort((a, b) => a.position - b.position);



    // Now create chips numbered 1, 2, 3, 4, 5 by order of appearance

    flagsWithPositions.forEach((item, textOrderIndex) => {

      const flag = item.flag;

      const phrase = item.phrase;

      const lowerPhrase = phrase.toLowerCase();

      const isStructural = structuralKeywords.some(kw => lowerPhrase.includes(kw));



      const chip = document.createElement('span');

      chip.className = 'trigger-chip';



      // Create number badge - NUMBER BY ORDER IN TEXT (1, 2, 3, 4, 5)

      const numberBadge = document.createElement('span');

      numberBadge.className = 'flag-number';

      numberBadge.textContent = textOrderIndex + 1; // 1, 2, 3, 4, 5 based on text order

      // Use red background with white text for Kinda Sus (Free version), red for Hella Sus

      const badgeBgColor = (score >= 30 && score < 70) ? '#dc2626' : '#dc2626';

      const badgeTextColor = (score >= 30 && score < 70) ? 'white' : 'white';

      numberBadge.style.cssText = `background: ${badgeBgColor}; color: ${badgeTextColor}; border-radius: 50%; width: 14px; height: 14px; display: inline-flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; margin-right: 4px; flex-shrink: 0;`;



      // Add number, phrase and optional structural label to chip

      chip.appendChild(numberBadge);

      chip.appendChild(document.createTextNode(phrase));

      if (isStructural) {

        const structuralLabel = document.createElement('span');

        structuralLabel.textContent = '[Structure]';

        structuralLabel.style.cssText = 'font-size: 10px; font-weight: 600; color: #0b0646; background: rgba(148, 163, 184, 0.18); border-radius: 999px; padding: 1px 6px; margin-left: 6px; display: inline-flex; align-items: center; gap: 2px;';



        const icon = document.createElement('span');

        icon.textContent = 'âš ï¸';

        icon.style.cssText = 'font-size: 11px;';



        structuralLabel.insertBefore(icon, structuralLabel.firstChild);

        chip.appendChild(structuralLabel);

      }



      // Get explanation - check exact phrase first, then lowercase

      const tooltipText = flag.explanation || 

                          tooltipMap[phrase] || 

                          tooltipMap[phrase.toLowerCase()] || 

                          `"${phrase}" is commonly flagged by AI detection tools`;



      // Set the tooltip (DO NOT REMOVE!)

      chip.title = tooltipText;

      chip.setAttribute('data-bs-toggle', 'tooltip');

      chip.setAttribute('data-bs-placement', 'top');



      // Keep the styling

      chip.style.cssText = `background: ${chipBgColor} !important; border: 1.5px solid ${chipBorderColor} !important; color: ${chipTextColor} !important; padding: 2px 5px !important; border-radius: 16px !important; font-size: 9px !important; font-weight: 600 !important; cursor: help !important; position: relative !important; display: inline-flex !important; align-items: center !important; line-height: 1.2 !important;`;



      // Add custom tooltip on hover (keep for enhanced styling)

      chip.addEventListener('mouseenter', function(e) {

        // Remove any existing tooltip first

        const existingTooltip = document.getElementById('triggerTooltip');

        if (existingTooltip) existingTooltip.remove();



        const tooltip = document.createElement('div');

        tooltip.id = 'triggerTooltip';

        tooltip.textContent = tooltipText;



        // Create arrow element

        const arrow = document.createElement('div');

        arrow.className = 'trigger-tooltip-arrow';



        tooltip.style.cssText = `

          position: fixed;

          background: white;

          color: #0b0646;

          border: 2px dotted #dc2626;

          padding: 6px 8px;

          border-radius: 6px;

          font-size: 12px;

          font-weight: 500;

          letter-spacing: 0.3px;

          max-width: 200px;

          white-space: normal;

          word-wrap: break-word;

          z-index: 10000;

          box-shadow: 0 2px 8px rgba(0,0,0,0.3);

          pointer-events: none;

          text-align: left;

          line-height: 1.4;

          opacity: 0;

          transition: opacity 0.2s ease;

        `;



        tooltip.appendChild(arrow);

        document.body.appendChild(tooltip);



        // Position tooltip relative to chip

        setTimeout(() => {

          const chipRect = chip.getBoundingClientRect();

          const tooltipRect = tooltip.getBoundingClientRect();

          const spaceAbove = chipRect.top;

          const spaceBelow = window.innerHeight - chipRect.bottom;



          let tooltipTop, tooltipLeft, arrowStyle;



          // Determine if tooltip should go above or below

          if (spaceAbove >= tooltipRect.height + 20 || spaceAbove >= spaceBelow) {

            // Show above

            tooltipTop = chipRect.top - tooltipRect.height - 8;

            arrowStyle = `

              position: absolute;

              bottom: -6px;

              left: 50%;

              transform: translateX(-50%);

              width: 0;

              height: 0;

              border-left: 6px solid transparent;

              border-right: 6px solid transparent;

              border-top: 6px solid #dc2626;

            `;

          } else {

            // Show below

            tooltipTop = chipRect.bottom + 8;

            arrowStyle = `

              position: absolute;

              top: -6px;

              left: 50%;

              transform: translateX(-50%);

              width: 0;

              height: 0;

              border-left: 6px solid transparent;

              border-right: 6px solid transparent;

              border-bottom: 6px solid #dc2626;

            `;

          }



          arrow.style.cssText = arrowStyle;



          // Center horizontally, but adjust if it would go off-screen

          tooltipLeft = chipRect.left + (chipRect.width / 2) - (tooltipRect.width / 2);



          if (tooltipLeft < 10) {

            tooltipLeft = 10;

            arrow.style.left = `${chipRect.left + (chipRect.width / 2) - 10}px`;

          } else if (tooltipLeft + tooltipRect.width > window.innerWidth - 10) {

            tooltipLeft = window.innerWidth - tooltipRect.width - 10;

            arrow.style.left = `${chipRect.right - (window.innerWidth - tooltipLeft - tooltipRect.width)}px`;

          }



          tooltip.style.left = tooltipLeft + 'px';

          tooltip.style.top = tooltipTop + 'px';

          tooltip.style.opacity = '1';

        }, 10);

      });



      chip.addEventListener('mouseleave', function() {

        const tooltip = document.getElementById('triggerTooltip');

        if (tooltip) {

          tooltip.style.opacity = '0';

          setTimeout(() => tooltip.remove(), 200);

        }

      });



      chipsContainer.appendChild(chip);

    });



    // NOTE: Urgent trigger warning card is now displayed via displayUrgentTriggerWarning() 

    // called after trigger chips rendering completes (see line ~19010)



    // DEBUG: Log if no chips were added

    if (flagsToShow.length === 0) {

      console.warn('âš ï¸ No trigger chips to display - flagsToShow is empty', {

        previewFlags: previewFlags,

        analysisFlags: analysisFlags,

        flagCount: flagCount,

        score: score

      });

    } else {

      console.log('âœ… Added', flagsToShow.length, 'trigger chips to display');

    }

    } // End of else block for score >= 30 chip rendering

  } // End of chipsContainer check



  console.log('âœ… Rendering trigger chips COMPLETE');



  // UPDATE THE TRIGGER HEADING WITH ACTUAL COUNTS

  const triggerHeadingElJan10 = document.getElementById('freeTriggerHeadingText');

  if (triggerHeadingElJan10) {

    const shownCount = Math.min(5, previewFlags.length); // Show up to 5

    const detectedCount = analysisFlags.length; // Total detected

    triggerHeadingElJan10.innerHTML = `âš¡ AI Trigger Words/Phrases: <span style="color: #dc2626; font-weight: 800;">${shownCount}</span> Shown <span style="color: #dc2626; font-weight: 800;">${detectedCount}</span> Detected`;

    console.log('âœ… Updated trigger heading:', shownCount, 'Shown,', detectedCount, 'Detected');

  }



  console.log('âœ… Skipping displayEssayPreview() for FREE users - using simplified highlighting instead');



  // ========= POPULATE FIRST 5 LINES OF ESSAY WITH FLAGGED WORD HIGHLIGHTING (FREE USERS ONLY) =========

  const essayFirstLinesEl = document.getElementById('essayFirstLines');

  if (essayFirstLinesEl && text && text.trim().length > 0) {

    // Extract first 5 lines from the essay text (limit to 500 chars)

    const lines = text.split('\n').filter(line => line.trim().length > 0);

    let first5Lines = lines.slice(0, 5).join('\n');



    // Limit to 500 characters

    if (first5Lines.length > 500) {

      first5Lines = first5Lines.substring(0, 500) + '...';

    }



    if (first5Lines.trim().length > 0) {

      // Highlight flagged words (FREE USERS ONLY)

      // Pass previewFlags for correct numbering to match trigger chips

      const highlightedText = highlightFlaggedWords(first5Lines, analysisFlags, previewFlags);

      essayFirstLinesEl.innerHTML = highlightedText;

      essayFirstLinesEl.style.display = 'block';

      console.log('âœ… Populated first 5 lines of essay with flagged word highlighting');



      // === TOP 5 SUMMARY MESSAGE ABOVE ESSAY ===

      // If more than 5 flags total, show summary text above the essay snippet

      const totalFlags = flagCount || (analysisFlags ? analysisFlags.length : 0);

      let summaryEl = document.getElementById('essayTop5Summary');

      if (!summaryEl) {

        summaryEl = document.createElement('p');

        summaryEl.id = 'essayTop5Summary';

        summaryEl.style.margin = '0 0 8px 0';

        summaryEl.style.fontSize = '13px';

        summaryEl.style.color = '#4b5563';

        summaryEl.style.fontWeight = '500';

        summaryEl.style.textAlign = 'left';

        if (essayFirstLinesEl.parentNode) {

          essayFirstLinesEl.parentNode.insertBefore(summaryEl, essayFirstLinesEl);

        }

      }



      if (totalFlags > 5) {

        summaryEl.textContent = `We found ${totalFlags} AI trigger words. Here are the top 5 highest risk:`;

        summaryEl.style.display = 'block';

      } else if (summaryEl) {

        summaryEl.style.display = 'none';

      }

    } else {

      essayFirstLinesEl.style.display = 'none';

    }

  } else if (essayFirstLinesEl) {

    essayFirstLinesEl.style.display = 'none';

  }



  // Update urgency CTA and upgrade count to match total flag count

  const urgencyCTAFlagCountEl = document.getElementById('urgencyCTAFlagCount');

  if (urgencyCTAFlagCountEl) urgencyCTAFlagCountEl.textContent = flagCount;



  // dynamicUpgradeCount may not exist if we remove the "Unlock All X" text

  const dynamicUpgradeCountEl = document.getElementById('dynamicUpgradeCount');

  if (dynamicUpgradeCountEl) dynamicUpgradeCountEl.textContent = flagCount;



  // Update urgency warning message with dynamic content

  // CRITICAL: This must run for scores >= 30 (Kinda Sus and Hella Sus)

  if (score >= 30 && flagCount > 0) {

    const urgencyWarningMessage = document.getElementById('urgencyWarningMessage');

    console.log('ðŸ” [URGENCY WARNING] Looking for element, found:', !!urgencyWarningMessage, 'flagCount:', flagCount, 'score:', score);



    if (urgencyWarningMessage) {

      const shownCount = Math.min(5, flagCount); // Same logic as heading

      let warningText = '';



      console.log('ðŸ” [URGENCY WARNING] Updating - shownCount:', shownCount, 'flagCount:', flagCount);



      if (shownCount === flagCount && flagCount > 0) {

        // All words are shown - use the new sentence format

        if (flagCount === 1) {

          // Dynamic variations for single trigger word - emphasize this is a basic scan

          const variations = [

            `Although 1 trigger is shown above, this is a basic scan. A deeper scan may detect additional words and patterns that need attention.`,

            `While 1 trigger is shown above, this basic scan may have missed more. A deeper scan could reveal additional words and patterns that need attention.`,

            `Even though 1 trigger is shown above, this is just a basic scan. A deeper scan may find additional words and patterns that need attention.`,

            `1 trigger is shown above, but this is a basic scan. A deeper scan may detect more words and patterns that need attention.`

          ];

          // Pick a random variation

          warningText = variations[Math.floor(Math.random() * variations.length)];

        } else {

          warningText = `Although ${flagCount} triggers are shown above, this is a basic scan. A deeper scan may detect additional words and patterns that need attention.`;

        }

      } else if (flagCount > 0) {

        // Some words shown, but more detected - use the new sentence format

        if (shownCount === 1) {

          // Dynamic variations for single shown trigger word - emphasize this is a basic scan

          const variations = [

            `Although 1 trigger is shown above, this is a basic scan. A deeper scan may detect additional words and patterns that need attention.`,

            `While 1 trigger is shown above, this basic scan may have missed more. A deeper scan could reveal additional words and patterns that need attention.`,

            `Even though 1 trigger is shown above, this is just a basic scan. A deeper scan may find additional words and patterns that need attention.`,

            `1 trigger is shown above, but this is a basic scan. A deeper scan may detect more words and patterns that need attention.`

          ];

          // Pick a random variation

          warningText = variations[Math.floor(Math.random() * variations.length)];

        } else {

          warningText = `Although ${shownCount} triggers are shown above, this is a basic scan. A deeper scan may detect additional words and patterns that need attention.`;

        }

      }



      // Display the warning text

      if (warningText) {

        urgencyWarningMessage.innerHTML = warningText;

        urgencyWarningMessage.style.setProperty('display', 'block', 'important');

        urgencyWarningMessage.style.setProperty('visibility', 'visible', 'important');

        urgencyWarningMessage.style.setProperty('opacity', '1', 'important');

        console.log('âœ… [URGENCY WARNING] Updated message:', warningText.substring(0, 80) + '...');

      }

    } else {

      console.error('âŒ [URGENCY WARNING] Element urgencyWarningMessage NOT FOUND in DOM!');

    }

  } else {

    // Hide for clean scores or no flags

    const urgencyWarningMessage = document.getElementById('urgencyWarningMessage');

    if (urgencyWarningMessage) {

      urgencyWarningMessage.style.display = 'none';

    }

  }



  // Update warning message based on score (Hella Sus vs Kinda Sus)

  try {

  const warningTextEl = document.getElementById('freeWarningMessageText');

    const warningBoxEl = document.getElementById('freeWarningMessageBox');



  if (warningTextEl) {

      if (score >= 70) {

        // Hella Sus

        warningTextEl.textContent = `âš ï¸ If you submit your essay as is, there's an extremely high chance it'll get flagged. Academic integrity violation = failing grade, course failure, or worse on your record. Don't risk it.`;

      } else if (score >= 30) {

        // Kinda Sus

        warningTextEl.textContent = `âš ï¸ If you submit your essay as is, there's a good chance it'll get flagged. Academic integrity violation = failing grade, course failure, or worse on your record. Don't risk it.`;

      }

      console.log('âœ… Updated warning message for score:', score);

    }



    // Show warning box for Hella Sus only (not Kinda Sus), hide for Clean / No Sus

    if (warningBoxEl) {

      if (score >= 70) {

        warningBoxEl.style.display = 'block';

      } else {

        warningBoxEl.style.display = 'none';

      }

    }

  } catch (e) {

    console.error('âŒ Error updating warning message:', e);

  }



  // ========= CAN'T DECIDE MESSAGE =========

  // CRITICAL: Always show "Can't decide?" message for scores >= 30 (Hella Sus and Kinda Sus)

  const cantDecideMessageEl = document.getElementById('cantDecideMessage');

  if (cantDecideMessageEl) {

    if (score >= 30) {

      cantDecideMessageEl.style.setProperty('display', 'block', 'important');

      cantDecideMessageEl.style.setProperty('visibility', 'visible', 'important');

      cantDecideMessageEl.style.setProperty('opacity', '1', 'important');

      console.log('âœ… Showing "Can\'t decide?" message for score:', score);

    } else {

      // Hide for clean scores

      cantDecideMessageEl.style.display = 'none';

    }

  } else {

    console.error('âŒ cantDecideMessage element NOT FOUND!');

  }



  // ========= TRIGGER WORDS MESSAGE =========

  console.log('ðŸ“ About to process trigger words message...');

  const triggerWordsMessageEl = document.getElementById('freeTriggerWordsMessage');

  if (triggerWordsMessageEl && flagCount > 0) {

    if (score >= 70) {

      triggerWordsMessageEl.innerHTML = "These words are AI red flags.<br>Your prof's detector will catch them in seconds.";

      triggerWordsMessageEl.style.color = '#dc2626';

      triggerWordsMessageEl.style.fontSize = '16px';

      triggerWordsMessageEl.style.fontWeight = '700';

      triggerWordsMessageEl.style.paddingTop = '0';

      triggerWordsMessageEl.style.paddingBottom = '0';

    } else if (score >= 30) {

      triggerWordsMessageEl.innerHTML = "These words are AI red flags.<br>Your prof's detector will catch them in seconds.";

      triggerWordsMessageEl.style.color = '#dc2626';

      triggerWordsMessageEl.style.fontSize = '16px';

      triggerWordsMessageEl.style.fontWeight = '700';

      // Add 1/8" padding (12px) top and 1/4" padding (24px) bottom for Kinda Sus page

      triggerWordsMessageEl.style.paddingTop = '12px';

      triggerWordsMessageEl.style.paddingBottom = '24px';

    }

  } else if (triggerWordsMessageEl) {

    triggerWordsMessageEl.textContent = '';

  }



      const deduplicatedFlags = [];

      // Use previewFlags or analysisFlags - whichever is available

      const flagsToDedupe = typeof previewFlags !== 'undefined' && previewFlags.length > 0 

        ? previewFlags 

        : (typeof analysisFlags !== 'undefined' && analysisFlags.length > 0 

          ? analysisFlags 

          : []);

      flagsToDedupe.forEach(flag => {

        const phrase = (flag.phrase || flag.text || '').toLowerCase();

        // Check if this phrase is a substring of any already-added phrase

        const isSubstring = deduplicatedFlags.some(existing => {

          const existingPhrase = (existing.phrase || existing.text || '').toLowerCase();

          return existingPhrase.includes(phrase) && existingPhrase !== phrase;

        });



        if (!isSubstring) {

          deduplicatedFlags.push(flag);

  } else {

          console.log('ðŸ”„ Skipping shorter overlapping phrase:', phrase);

        }

      });



      // Limit to 5 trigger words max in preview

      const textPhraseFlags = deduplicatedFlags.slice(0, Math.min(5, deduplicatedFlags.length));



      console.log('ðŸŽ¨ Text phrases to highlight (after dedupe):', textPhraseFlags.map(f => f.phrase || f.text));



      // ========= ESSAY PREVIEW: REMOVED displayEssayPreview() call for FREE users =========

      // The old displayEssayPreview() function creates red highlight boxes - we don't want that for FREE users

      // The simplified highlighting code below will handle essay preview instead (plain text only, no highlights)

      console.log('âœ… Skipping displayEssayPreview() for FREE users - using simplified highlighting instead');

      let sortedFlagsForPills = []; // Empty array - not used for FREE users



      // ========= "WHAT'S THE MOVE?" - Update total flag count (INSIDE TRY BLOCK) =========

      const totalFlagsCount = document.getElementById('freeTotalFlagsCount');

      if (totalFlagsCount) {

        // CRITICAL: Use the SAME flagCount as "Detected" count to ensure consistency

        // flagCount is already set from analysisFlags.length (deduplicated), so use it directly

        const totalDetectedFlags = flagCount; // Use flagCount directly (already from deduplicated analysisFlags)

        totalFlagsCount.textContent = totalDetectedFlags;

        console.log('âœ… Updated freeTotalFlagsCount to:', totalDetectedFlags, '(flagCount:', flagCount, ', analysisFlags.length:', analysisFlags.length, ', appState.flagData.length:', appState.flagData ? appState.flagData.length : 0, ')');

      } else {

        console.warn('âš ï¸ freeTotalFlagsCount element not found');

      }



      // Update urgency CTA flag count dynamically (use same flagCount as "Detected" count)

      const urgencyCTACount = document.getElementById('urgencyCTAFlagCount');

      if (urgencyCTACount) {

        urgencyCTACount.textContent = flagCount; // Use flagCount directly (same as "Detected" count)

        console.log('âœ… Updated urgency CTA flag count to:', urgencyCTACount.textContent, '(flagCount:', flagCount, ')');

      } else {

        console.warn('âš ï¸ urgencyCTAFlagCount element not found');

      }



      // Update the "Unlock All X" count dynamically (use same flagCount as "Detected" count)

      const upgradeCount = document.getElementById('dynamicUpgradeCount');

      if (upgradeCount) {

        upgradeCount.textContent = flagCount; // Use flagCount directly (same as "Detected" count)

        console.log('âœ… Updated "Unlock All" count to:', upgradeCount.textContent, '(flagCount:', flagCount, ')');

        } else {

        console.warn('âš ï¸ dynamicUpgradeCount element not found');

      }



      // ========= FREE USERS: Essay preview is now created by showInteractiveEssayBox() =========

      // REMOVED: Code that tried to find essayPreviewContent/essayPreview elements - they don't exist yet

      // The essay preview is created by showInteractiveEssayBox() function, not here

      console.log('âœ… Essay preview will be created by showInteractiveEssayBox() - skipping lookup');



      // Populate lockbox blurred background with essay text using the function

      // ONLY for Kinda Sus/Hella Sus (score >= 30) - NOT for Clean No Sus (score < 30)

      if (score >= 30) {

        console.log('ðŸŽ¯ Populating lockbox blurred background for Kinda Sus/Hella Sus (score >= 30)...');

      // Ensure we have the actual user text from textarea (reuse essayInput from function scope)

      const actualEssayText = (essayInput && essayInput.value && essayInput.value.trim()) || text || '';



      console.log('ðŸ” Lockbox essay text check:', {

        fromTextarea: essayInput ? essayInput.value.substring(0, 50) + '...' : 'NO TEXTAREA',

        fromTextVar: text ? text.substring(0, 50) + '...' : 'NO TEXT VAR',

        finalText: actualEssayText ? actualEssayText.substring(0, 50) + '...' : 'NO FINAL TEXT',

        finalLength: actualEssayText.length

      });



      // Call populateLockboxEssay with the actual user essay text

      if (actualEssayText && actualEssayText.length > 0) {

        if (typeof populateLockboxEssay === 'function') {

          populateLockboxEssay(actualEssayText);

          console.log('âœ… Called populateLockboxEssay with user essay text, length:', actualEssayText.length);

    } else {

          // Fallback: directly set if function doesn't exist

          const blurredBackground = document.getElementById('lockboxBlurredBackground');

          if (blurredBackground) {

            const previewText = actualEssayText.substring(0, 500) + (actualEssayText.length > 500 ? '...' : '');

            blurredBackground.innerHTML = `

              <div style="font-size: 13px; line-height: 1.6; color: #6b7280; white-space: pre-wrap; word-wrap: break-word; max-height: 400px; overflow: hidden; padding: 32px 24px;">

                ${previewText}

              </div>

            `;

            console.log('âœ… Lockbox blurred background populated directly with essay text, length:', previewText.length);

          }

        }

      } else {

        console.log('âŒ Could not populate lockbox - no essay text available', {

          hasTextarea: !!essayInput,

          textareaValue: essayInput ? essayInput.value.length : 0,

          textVarLength: text ? text.length : 0,

          finalTextLength: actualEssayText.length

        });

        }

      } else {

        // Clean No Sus (score < 30) - DO NOT populate lockbox, show actual essay preview instead

        console.log('âœ… Clean No Sus (score < 30) - skipping lockbox population, showing freeCleanNoSusEssayContainer instead');

      }

      }

  } catch (error) {

    // CATCH for the main try block starting at line 18109 in showFreeUserResult

    console.error('âŒ Main try block error in showFreeUserResult:', error);

    console.error('Error stack:', error.stack);



    // CRITICAL: Ensure score and analysisFlags have fallback values if try block failed

    if (typeof score === 'undefined' || score === null || isNaN(score)) {

      score = typeof appState.currentScore === 'number' ? appState.currentScore : 0;

      console.warn('âš ï¸ Score was undefined in catch block, using fallback:', score);

    }



    if (!Array.isArray(analysisFlags) || analysisFlags.length === 0) {

      analysisFlags = appState.flagData || [];

      console.warn('âš ï¸ analysisFlags was empty in catch block, using appState.flagData:', analysisFlags.length);

    }

  }



  // ========= LOCKBOX: Dynamic Colors Based on Score =========

  const lockbox = document.getElementById('freeUnlockOverlay');

  if (lockbox) {

    // Determine border color based on score

    let borderColor = '#dc2626'; // Default: Red for Hella Sus

    if (score >= 70) {

      // HELLA SUS (70%+): RED BORDER

      borderColor = '#dc2626';

      lockbox.style.setProperty('display', 'block', 'important');

    } else if (score >= 30) {

      // KINDA SUS (30-69%): YELLOW/ORANGE BORDER

      borderColor = '#f59e0b';

      lockbox.style.setProperty('display', 'block', 'important');

    } else {

      // CLEAN - NO SUS (0-29%): HIDE LOCKBOX (no flags to show)

      borderColor = '#2ecc71';

      lockbox.style.setProperty('display', 'none', 'important');



    }



    // Apply dynamic border color to the inner div

      const innerDiv = lockbox.querySelector('[style*="border: 2px dashed"]');

      if (innerDiv) {

      innerDiv.style.borderColor = borderColor;

      innerDiv.style.setProperty('border-color', borderColor, 'important');

      }



    // Update heading text (already set in HTML, but ensure it's correct)

      const heading = lockbox.querySelector('h3');

    if (heading) {

      heading.textContent = 'Need a Quick Last Minute Fix?';

      heading.style.color = '#ff4500'; // Bright orange-red

    }



    // Populate blurred essay background

    const blurredBackground = document.getElementById('lockboxBlurredBackground');

    if (blurredBackground) {

      const essayText = (text && text.trim()) || (appState.originalText && appState.originalText.trim()) || '';

      if (essayText.length > 0) {

        const previewText = essayText.substring(0, 500) + (essayText.length > 500 ? '...' : '');

        blurredBackground.innerHTML = `

          <div style="font-size: 13px; line-height: 1.6; color: #6b7280; white-space: pre-wrap; word-wrap: break-word; max-height: 400px; overflow: hidden; padding: 32px 24px;">

            ${previewText}

          </div>

        `;

        console.log('âœ… Lockbox blurred background populated in lockbox section, length:', previewText.length);

      } else {

        console.log('âŒ No essay text available for lockbox blurred background');

      }

    } else {

      console.log('âŒ lockboxBlurredBackground element not found');

    }

  }



  // ========= ZERO TRIGGER BOX: Removed - no longer shown =========

  const zeroBox = document.getElementById('freeZeroTriggerBox');

  if (zeroBox) {

    zeroBox.style.display = 'none'; // Always hidden

  }



  // ========= UPSELL: ALWAYS VISIBLE (all 3 variants) =========

  const upsellSection = document.getElementById('freeUpsellSection');

  if (upsellSection) {

    upsellSection.style.display = 'block'; // Always show

  }



  // ========= TRIGGER WORDS SUBTITLE: Show if flags detected =========

  const triggerSubtitle = document.getElementById('freeTriggerWordsSubtitle');

  if (triggerSubtitle) {

    triggerSubtitle.style.display = (flagCount > 0) ? 'block' : 'none';

  }



  // ========= DYNAMIC MESSAGE BASED ON SCORE =========

  // HIDE FOR FREE CLEAN NO SUS (score < 30) - User requested to remove this green box

  // Remove any existing dynamic message first (for all cases, including Clean No Sus)

    const existingMsg = document.getElementById('essayDynamicMessage');

    if (existingMsg) {

      existingMsg.remove();

    console.log('âœ… Removed existing essayDynamicMessage');

  }



  // ONLY create/show dynamic message for Kinda Sus and Hella Sus (score >= 30)

  // Skip entirely for Clean No Sus (score < 30) in FREE version

  // NOTE: Essay preview is now created by showInteractiveEssayBox() - don't look for it here

  // REMOVED: Code that tried to find 'essayPreview' element - it doesn't exist yet

  // The essay preview is created by showInteractiveEssayBox() function, not here

  if (score >= 30) {

    // Essay preview will be created by showInteractiveEssayBox() - skip dynamic message for now

    // The dynamic message can be added later if needed, but the essay box is the main content

    console.log('âœ… Skipping essay preview lookup - will be created by showInteractiveEssayBox()');



    // REMOVED: All code that tried to find and insert into essayPreview element

    // The essay preview container doesn't exist until showInteractiveEssayBox() creates it

    // Dynamic message functionality removed - essay box handles all content display

  } else {

    // Clean No Sus (score < 30) - DO NOT show dynamic message for FREE version

    console.log('âœ… Skipped creating essayDynamicMessage for FREE Clean No Sus (score < 30, hidden per user request)');

  }



  // ========= AI RED FLAGS WARNING MESSAGE: Replaced with urgent badge card =========

  // The urgent badge card is now displayed in the trigger chips section above

  // Hide any old freeTriggerWarningMessage elements if they exist

  const oldWarningMessage = document.getElementById('freeTriggerWarningMessage');

  if (oldWarningMessage) {

    oldWarningMessage.style.display = 'none';

  }



  // TODO: Tooltips currently show same text for all chips - will be updated when dynamic explanation logic is implemented



  // ========= "WHAT'S THE MOVE?" - Update total flag count (FALLBACK - if not updated in try block) =========

  // This is a fallback in case the try block failed - use deduplicated count if available

  const totalFlagsCount = document.getElementById('freeTotalFlagsCount');

  if (totalFlagsCount && totalFlagsCount.textContent === '0') {

    // If still showing 0, try to get from analysisFlags (deduplicated) first, then appState

    const fallbackCount = (analysisFlags && analysisFlags.length > 0) 

      ? analysisFlags.length 

      : (appState.flagData ? appState.flagData.length : 0);

    if (fallbackCount > 0) {

      totalFlagsCount.textContent = fallbackCount;

      console.log('âœ… Updated freeTotalFlagsCount (fallback) to:', fallbackCount, '(from analysisFlags:', analysisFlags.length, 'or appState.flagData:', appState.flagData ? appState.flagData.length : 0, ')');



      // Keep urgency CTA and "Unlock All" counts in sync with the same total

      const urgencyCTACountFallback = document.getElementById('urgencyCTAFlagCount');

      if (urgencyCTACountFallback) {

        urgencyCTACountFallback.textContent = fallbackCount;

        console.log('âœ… Updated urgencyCTAFlagCount (fallback) to match totalFlagsCount:', fallbackCount);

      }



      const dynamicUpgradeCountFallback = document.getElementById('dynamicUpgradeCount');

      if (dynamicUpgradeCountFallback) {

        dynamicUpgradeCountFallback.textContent = fallbackCount;

        console.log('âœ… Updated dynamicUpgradeCount (fallback) to match totalFlagsCount:', fallbackCount);

      }

    }

  }



  // ========= TRIGGER CHIPS: Red pill-shaped buttons with lock icons =========

  // NOTE: Trigger chips with tooltips are created earlier in the function (around line 17490)

  // This duplicate section has been removed to prevent overwriting chips with tooltips



  // ========= GREEN UPSELL SECTION: Update copy based on score =========

  const upsellHeading = document.getElementById('freeUpsellHeadingText');

  const upsellText = document.getElementById('freeUpsellText');



  // Always show the heading with "ðŸ’Ž Go Pro and Chill..."

  if (upsellHeading) {

    upsellHeading.textContent = 'ðŸ’Ž Go Pro and Chill...';

    upsellHeading.style.display = 'block';

  }



  if (upsellText) {

    if (score >= 70) {

      // HELLA SUS (70%+)

      upsellText.innerHTML = '100 scans and fixes/month â€¢ Deeper AI fixes powered by Claude Haiku â€¢ Priority chat support â€¢ Cancel anytime';

    } else if (score >= 30) {

      // KINDA SUS (30-69%)

      upsellText.innerHTML = '100 scans and fixes/month â€¢ Deeper AI fixes powered by Claude Haiku â€¢ Priority chat support â€¢ Cancel anytime';

    } else {

      // YOU'RE GOOD (Under 30%)

      upsellText.textContent = 'You nailed this one. Lock in the wins with Pro â€¢ Catch triggers on EVERY essay before your prof does â€¢ 100 monthly scans â€¢ Stay undefeated';

    }

  }



  // ========= BLURRED ESSAY SNIPPET =========

  // SAFEGUARD: Ensure previewFlags is defined before using it

  if (typeof previewFlags === 'undefined' || !Array.isArray(previewFlags)) {

    console.warn('âš ï¸ previewFlags is undefined or not an array, initializing...');

    const severitySortedFlagsForSnippet = sortFlagsByRisk(analysisFlags || []);

    previewFlags = severitySortedFlagsForSnippet.slice(0, Math.min(5, severitySortedFlagsForSnippet.length));

  }

  console.log('ðŸ” Processing essay snippet, flags count:', previewFlags.length);

  const sentencesContainer = document.getElementById('freeFlagSentences');

  if (sentencesContainer) {

    sentencesContainer.innerHTML = '';

      // SAFEGUARD: Limit processing to prevent hangs - REDUCE TO 10

      const maxFlagsToProcess = 10; // Reduced from 50 to prevent hangs

    const flagsToProcess = previewFlags.slice(0, maxFlagsToProcess);

    console.log('ðŸ” Processing', flagsToProcess.length, 'flags (limited from', previewFlags.length, ')');



      // CRITICAL: Add timeout safeguard

      const processingStartTime = performance.now();

      const MAX_FLAG_PROCESSING_TIME = 1000; // 1 second max



    flagsToProcess.forEach((flag, index) => {

        // Check if processing is taking too long

        if (performance.now() - processingStartTime > MAX_FLAG_PROCESSING_TIME) {

          console.error('âŒ Flag processing taking too long, stopping at flag', index);

          return; // Exit forEach early

        }



        if (index % 5 === 0) console.log('ðŸ” Processing flag', index + 1, 'of', flagsToProcess.length);

      const phrase = flag.phrase || flag.word || flag.text || '';

        if (!phrase || phrase.trim().length === 0) return; // Skip empty phrases



      const lowerText = text.toLowerCase();

      const lowerPhrase = phrase.toLowerCase();

      const idx = phrase ? lowerText.indexOf(lowerPhrase) : -1;



      let sentence = text;

      if (idx !== -1) {

        let start = text.lastIndexOf('.', idx);

        let newlineStart = text.lastIndexOf('\n', idx);

        if (newlineStart > start) start = newlineStart;

        start = start === -1 ? 0 : start + 1;



        let end = text.indexOf('.', idx + phrase.length);

        let newlineEnd = text.indexOf('\n', idx + phrase.length);

        if (newlineEnd !== -1 && (end === -1 || newlineEnd < end)) end = newlineEnd;

        end = end === -1 ? Math.min(text.length, idx + phrase.length + 120) : end + 1;



        sentence = text.slice(start, end).trim();

      }



      const safeSentence = sentence || text;

      let highlighted = safeSentence;

      if (phrase) {

        const escaped = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        highlighted = safeSentence.replace(

          new RegExp(escaped, 'gi'),

          match => `<span class="trigger-chip">${match}</span>`

        );

      }



      const row = document.createElement('div');

      row.className = 'free-flag-row';

      row.innerHTML = `

        <p class="free-flag-sentence" style="font-size:13px;color:#4b5563;line-height:1.6;margin:0 0 8px 0;text-align:left;">

          ${highlighted}

        </p>

      `;

      sentencesContainer.appendChild(row);

    });



    if (extraCount > 0) {

      const extra = document.createElement('p');

      extra.style.cssText = 'font-size:12px;color:#6b7280;line-height:1.5;margin:4px 0 0 0;text-align:left;';

      extra.textContent =

          `We found ${extraCount} more AI-trigger word${extraCount === 1 ? '' : 's'} in your text â€” they're locked in Free mode.`;

      sentencesContainer.appendChild(extra);

    }

  }



  const blurredTextEl = document.getElementById('freeBlurredText');

  if (blurredTextEl) {

    const snippet = text.length > 600 ? text.slice(0, 600) + 'â€¦' : text;

    blurredTextEl.innerHTML =

      `<p style="color:#6b7280;font-size:13px;line-height:1.6;margin:0;">${snippet.replace(/\n/g, '<br>')}</p>`;

  }



  // CRITICAL FIX: Make scrollIntoView non-blocking to prevent freeze

  // Defer scrolling to next frame to avoid blocking the UI thread

  const resultsContainerScroll = document.getElementById('resultsContainer');

  if (resultsContainerScroll) {

    // Use requestAnimationFrame + setTimeout to ensure it doesn't block

    requestAnimationFrame(() => {

      setTimeout(() => {

        try {

          // Use 'auto' instead of 'smooth' for faster, non-blocking scroll

          resultsContainerScroll.scrollIntoView({ behavior: 'auto', block: 'start' });

        } catch (e) {

          console.error('Error scrolling to results:', e);

        }

      }, 50);

    });

  }



    // CRITICAL: Ensure all modals are closed and body is not stuck

    document.body.classList.remove('modal-open');



    // Remove any lingering modals - make this non-blocking too

    setTimeout(() => {

    const lingeringModals = document.querySelectorAll('[style*="position:fixed"][style*="z-index"]');

      // Limit to first 10 modals to prevent blocking

      for (let i = 0; i < Math.min(lingeringModals.length, 10); i++) {

        const modal = lingeringModals[i];

        try {

      if (parseInt(modal.style.zIndex) > 1000) {

        modal.remove();

      }

        } catch (e) {

          // Ignore errors

        }

      }

    }, 10);



  const endTime = performance.now();

  console.log('âœ… showFreeUserResult COMPLETE in', (endTime - startTime).toFixed(2), 'ms');



  // Make lockbox visible - ensure opacity is 1 on lockbox AND all parents

  if (lockbox) {

    // Set opacity on lockbox itself

    lockbox.style.setProperty('display', 'block', 'important');

    lockbox.style.setProperty('opacity', '1', 'important');

    lockbox.style.setProperty('visibility', 'visible', 'important');



    // Ensure ALL parent containers also have opacity: 1

    let parent = lockbox.parentElement;

    while (parent && parent !== document.body) {

      parent.style.setProperty('opacity', '1', 'important');

      parent = parent.parentElement;

    }



    // Show the PARENT container too

    const resultsContainer = document.getElementById('resultsContainer') || 

                              lockbox.parentElement;

    if (resultsContainer) {

      resultsContainer.style.setProperty('display', 'block', 'important');

      resultsContainer.style.setProperty('opacity', '1', 'important');

      resultsContainer.style.setProperty('visibility', 'visible', 'important');

      console.log('âœ… Parent container shown with opacity: 1');

    }



    console.log('âœ… Lockbox forced visible with !important, all parents opacity: 1');

  }



  // Save completion checkpoint

  try {

    localStorage.setItem('fff_last_checkpoint', JSON.stringify({

      time: new Date().toISOString(),

      checkpoint: 'showFreeUserResult COMPLETE (but setTimeout callbacks may still be pending)',

      duration: (endTime - startTime).toFixed(2) + 'ms',

      note: 'If page hangs, check for "Inside setTimeout" checkpoint'

    }));

  } catch (e) {}



  // REMOVED: Old essayPreviewContent container has been deleted from HTML

  // Essay preview for Clean No Sus is now handled by freeCleanNoSusEssayContainer (populated earlier in this function)

  // For other score ranges, essay preview is handled by their respective containers

  console.log('âœ… FREE user - essay preview population handled by specific containers (freeCleanNoSusEssayContainer for Clean No Sus)');



  // CRITICAL: Final check - ensure freeCleanNoSusEssayContainer is visible for Clean No Sus cases

  if (cardToShow === 'youreGood' && score < 30) {

    // FINAL CHECK: Ensure main character energy box is REMOVED (not just hidden)

    const finalCheckMainCharacterBox = document.getElementById('freeCleanNoSusMainCharacterBox');

    if (finalCheckMainCharacterBox && finalCheckMainCharacterBox.parentNode) {

      console.error('âŒ freeCleanNoSusMainCharacterBox STILL EXISTS in DOM! Removing it now...');

      finalCheckMainCharacterBox.remove();

    } else if (!finalCheckMainCharacterBox) {

      console.log('âœ… freeCleanNoSusMainCharacterBox successfully removed from DOM');

    }



    // FINAL CHECK: Ensure essayDynamicMessage green box is REMOVED for FREE Clean No Sus

    const finalCheckDynamicMsg = document.getElementById('essayDynamicMessage');

    if (finalCheckDynamicMsg && finalCheckDynamicMsg.parentNode) {

      console.error('âŒ essayDynamicMessage STILL EXISTS in DOM for FREE Clean No Sus! Removing it now...');

      finalCheckDynamicMsg.remove();

    } else if (!finalCheckDynamicMsg) {

      console.log('âœ… essayDynamicMessage successfully removed/hidden for FREE Clean No Sus');

    }



    const finalCheckContainer = document.getElementById('freeCleanNoSusEssayContainer');

    const finalCheckContent = document.getElementById('freeCleanNoSusEssayContent');



    if (finalCheckContainer) {

      const finalDisplay = window.getComputedStyle(finalCheckContainer).display;

      const finalVisibility = window.getComputedStyle(finalCheckContainer).visibility;

      const finalOpacity = window.getComputedStyle(finalCheckContainer).opacity;



      console.log('ðŸ” FINAL CHECK: freeCleanNoSusEssayContainer visibility:', {

        display: finalDisplay,

        visibility: finalVisibility,

        opacity: finalOpacity,

        shouldBeVisible: finalDisplay !== 'none' && finalVisibility !== 'hidden',

        hasContent: finalCheckContent && finalCheckContent.innerHTML.length > 0,

        contentLength: finalCheckContent ? finalCheckContent.innerHTML.length : 0,

        parentCardVisible: document.getElementById('youreGoodCard') ? window.getComputedStyle(document.getElementById('youreGoodCard')).display : 'NO CARD'

      });



      if (finalDisplay === 'none' || finalVisibility === 'hidden') {

        console.error('âŒ Container is HIDDEN at final check! Re-forcing visibility with !important...');

        finalCheckContainer.style.setProperty('display', 'block', 'important');

        finalCheckContainer.style.setProperty('visibility', 'visible', 'important');

        finalCheckContainer.style.setProperty('opacity', '1', 'important');

      }



      if (finalCheckContent && finalCheckContent.innerHTML.length === 0) {

        console.error('âŒ Content element is EMPTY at final check! Container may have been cleared.');

      }

    }

  }



  // ========= SHOW OVERLAY AFTER RENDER =========

  if (appState.pendingOverlay && appState.pendingOverlay.show) {

    setTimeout(() => {

      if (appState.pendingOverlay.type === 'panic') {

        showPanicOverlay(appState.pendingOverlay.score, appState.pendingOverlay.triggers);

      } else {

        showHappyOverlay(appState.pendingOverlay.score, appState.pendingOverlay.triggers);

      }

      appState.pendingOverlay = null;

    }, 300);

  }

}



// CRITICAL: Cleanup function to clear all background processes

function cleanupBackgroundProcesses() {

  // Clear all stored intervals

  if (window.messageRotationInterval) {

    clearInterval(window.messageRotationInterval);

    window.messageRotationInterval = null;

  }

  if (window.cleanMessageRotationInterval) {

    clearInterval(window.cleanMessageRotationInterval);

    window.cleanMessageRotationInterval = null;

  }

  if (window.headerRotationInterval) {

    clearInterval(window.headerRotationInterval);

    window.headerRotationInterval = null;

  }

  if (window._rotationInterval) {

    clearInterval(window._rotationInterval);

    window._rotationInterval = null;

  }

  if (window.scanTimerInterval) {

    clearInterval(window.scanTimerInterval);

    window.scanTimerInterval = null;

  }

  if (window._headingInterval) {

    clearInterval(window._headingInterval);

    window._headingInterval = null;

  }

  if (window._cleanHeadingInterval) {

    clearInterval(window._cleanHeadingInterval);

    window._cleanHeadingInterval = null;

  }

  if (window._zeroBoxInterval) {

    clearInterval(window._zeroBoxInterval);

    window._zeroBoxInterval = null;

  }

  if (window._extraFlagsInterval) {

    clearInterval(window._extraFlagsInterval);

    window._extraFlagsInterval = null;

  }

  if (window._chipsHintInterval) {

    clearInterval(window._chipsHintInterval);

    window._chipsHintInterval = null;

  }



  console.log('âœ… Cleaned up all background processes');

}



// GLOBAL: Force reset scan button - can be called from console if button gets stuck

window.forceResetScanButton = function() {

  console.log('ðŸ”§ Force resetting scan button...');



  // Clear animatedBars

  if (typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

    animatedBars.clear();

  }



  // Clear all intervals

  cleanupBackgroundProcesses();



  // Abort any pending API requests

  if (window._currentAbortController) {

    try { window._currentAbortController.abort(); } catch (e) {}

    window._currentAbortController = null;

  }



  // Reset scan button

  const scanButton = document.getElementById('scanButton');

  if (scanButton) {

    scanButton.dataset.scanning = 'false';

    scanButton.disabled = false;

    scanButton.classList.remove('scanning-button');

    scanButton.style.background = '#2ecc71';

    scanButton.style.color = 'white';

    scanButton.style.cursor = 'pointer';

    scanButton.style.pointerEvents = 'auto';

    scanButton.style.opacity = '1';



    const scansUsed = window.getScansUsed ? window.getScansUsed() : 0;

    scanButton.innerHTML = `ðŸ” Free Scan (<span id="scanCounter">${scansUsed}/50</span>)`;

  }



  console.log('âœ… Scan button force reset complete');

  return 'Scan button reset!';

};



function minimizeResults() {

  console.log('ðŸ”„ minimizeResults() - Cleaning up scan state');

  document.body.classList.remove('free-low-sus-mode');



  // CRITICAL: Abort local detection if in progress

  if (window._localDetectionAbortController) {

    try {

      window._localDetectionAbortController.abort();

      console.log('âœ… Aborted local detection process');

    } catch (e) {

      console.warn('âš ï¸ Error aborting local detection:', e);

    }

    window._localDetectionAbortController = null;

  }



  // CRITICAL: Clear local detection timeout

  if (window._localDetectionTimeout) {

    clearTimeout(window._localDetectionTimeout);

    window._localDetectionTimeout = null;

    console.log('âœ… Cleared local detection timeout');

  }



  // CRITICAL: Clear animatedBars Set so progress bars can re-animate on next scan

  if (typeof animatedBars !== 'undefined' && animatedBars instanceof Set) {

    animatedBars.clear();

    console.log('âœ… Cleared animatedBars Set for fresh animations');

  }



  // CRITICAL: Clean up background processes when leaving results

  cleanupBackgroundProcesses();



  // CRITICAL: Reset scan state completely

  const scanButton = document.getElementById('scanButton');

  if (scanButton) {

    scanButton.dataset.scanning = 'false';

    scanButton.disabled = false;

    scanButton.classList.remove('scanning-button');

    scanButton.style.background = '#2ecc71';

    scanButton.style.color = 'white';

    scanButton.style.cursor = 'pointer';

    scanButton.style.pointerEvents = 'auto';

    scanButton.style.opacity = '1';

    console.log('âœ… Reset scan button state');

  }



  // CRITICAL: Reset appState scan-related variables

  appState.flagData = [];

  appState.currentScore = 0;

  appState.apiResponse = null;

  appState.quickfixFlags = [];

  appState.quickfixTextPhraseFlags = [];

  appState.quickfixStructuralFlags = [];

  appState.lastScanData = null;

  console.log('âœ… Reset appState scan variables');



  const resultsContainer = document.getElementById('resultsContainer');

  if (resultsContainer) {

    resultsContainer.classList.remove('show');

    resultsContainer.style.display = 'none';

  }

  document.getElementById('inputSection').style.display = 'block';



  // Clear the form completely

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    essayInput.value = '';

  }



  // Reset authorship checkbox

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (authorshipCheckbox) {

    authorshipCheckbox.checked = false;

  }



  // Sync scan count from localStorage when returning to front page

  appState.scansUsed = getScansUsed();

  updateCounter();

  updateScansDisplay();

}



window.handleProUpgrade = function handleProUpgrade() {

  // Close the essay too long modal if it's open

  const essayTooLongModal = document.getElementById('essayTooLongModal');

  if (essayTooLongModal && essayTooLongModal.style.display !== 'none') {

    essayTooLongModal.style.display = 'none';

    document.body.classList.remove('modal-open');

  }



  // Show welcome modal first, before payment

  showProWelcomeModal(true); // Pass true to indicate it's for upgrade (not dashboard welcome)

}



// ==================== STEP 6: PRO DASHBOARD FUNCTIONS ====================



function showProDashboard() {

  console.log('ðŸ”„ showProDashboard() called');



  // CRITICAL: Hide all stuck tooltips immediately

  if (typeof clearAllTooltips === 'function') {

    clearAllTooltips();

  } else if (typeof hideTooltip === 'function') {

    hideTooltip();

  }

  // Force hide all tooltip elements

  const allTooltips = document.querySelectorAll('#tooltip, .tooltip, [id*="tooltip"], [class*="tooltip"]');

  allTooltips.forEach(tt => {

    tt.classList.remove('show');

    tt.style.display = 'none';

    tt.style.visibility = 'hidden';

    tt.style.opacity = '0';

  });



  // Set Pro mode flag

  appState.isProUser = true;



  // Update labels from QuickFix to Pro

  updateStepLabels(true);



  // Show reminder about 5000 character limit (unless user dismissed it)

  const proCharacterReminder = document.getElementById('proCharacterReminder');

  if (proCharacterReminder) {

    // Hide if user previously dismissed it, otherwise show it

    if (sessionStorage.getItem('proReminderDismissed')) {

      proCharacterReminder.style.display = 'none';

    } else {

      proCharacterReminder.style.display = 'block';

    }

  }



  // Hide all other sections FIRST

  const inputSection = document.getElementById('inputSection');

  if (inputSection) {

    inputSection.style.display = 'none';

    console.log('âœ… Input section hidden');

  }



  // Hide QuickFix flow container

  const quickfixFlow = document.getElementById('quickfixFlow');

  if (quickfixFlow) {

    quickfixFlow.style.display = 'none';

    console.log('âœ… QuickFix flow hidden');

  }



  // Hide all QuickFix steps

  document.querySelectorAll('.quickfix-step').forEach(step => {

    if (step.id !== 'quickfixStep6') {

      step.style.display = 'none';

      step.classList.remove('active');

    }

  });



  const managePage = document.getElementById('manageSubscriptionPage');

  if (managePage) managePage.style.display = 'none';



  // Hide results container if visible

  const resultsContainer = document.getElementById('resultsContainer');

  if (resultsContainer) {

    resultsContainer.classList.remove('show');

    resultsContainer.style.display = 'none';

  }



  // Show Step 6 - make sure it's visible

  const step6 = document.getElementById('quickfixStep6');

  if (!step6) {

    console.error('âŒ Step 6 element not found!');

    return;

  }



  // Remove any inline display:none styles

  let currentStyle = step6.getAttribute('style') || '';

  currentStyle = currentStyle.replace(/display\s*:\s*none\s*;?/gi, '');

  if (currentStyle.trim()) {

    step6.setAttribute('style', currentStyle);

  } else {

    step6.removeAttribute('style');

  }



  // Force show Step 6 with multiple methods to ensure visibility

  step6.style.setProperty('display', 'block', 'important');

  step6.style.setProperty('opacity', '1', 'important');

  step6.style.setProperty('visibility', 'visible', 'important');

  step6.classList.add('active');



  // Double-check it's visible after a brief delay

  setTimeout(() => {

    const computedDisplay = window.getComputedStyle(step6).display;

    if (computedDisplay === 'none') {

      console.error('âŒ Step 6 still hidden after show attempt!');

      step6.style.setProperty('display', 'block', 'important');

      step6.style.setProperty('opacity', '1', 'important');

      step6.style.setProperty('visibility', 'visible', 'important');

    }

  }, 100);



  console.log('âœ… Step 6 displayed');

  console.log('Step 6 computed style:', window.getComputedStyle(step6).display);

  console.log('Step 6 has active class:', step6.classList.contains('active'));

  console.log('Step 6 innerHTML length:', step6.innerHTML.length);



  // Update usage stats

  updateProUsageStats();



  // Initialize signup date if not set

  if (!appState.proSubscription.signupDate) {

    appState.proSubscription.signupDate = new Date().toISOString();

  }



  // Update dashboard stats and recent scans

  updateProDashboardStats();



  // Update dashboard stats display

  updateProDashboardStats();



  // Ensure manage subscription gear icon is clickable

  setTimeout(() => {

    const settingsIcon = document.querySelector('#quickfixStep6 .settings-icon');

    if (settingsIcon) {

      // Remove any existing listeners and add fresh one

      const newIcon = settingsIcon.cloneNode(true);

      settingsIcon.parentNode.replaceChild(newIcon, settingsIcon);

      newIcon.addEventListener('click', function(e) {

        e.preventDefault();

        e.stopPropagation();

        if (typeof window.showManageSubscription === 'function') {

          window.showManageSubscription();

        } else {

          console.error('âŒ showManageSubscription function not found');

        }

        return false;

      });

      console.log('âœ… Manage subscription gear icon listener attached');

    }

  }, 100);



  // Initialize character counter for Pro scan input

  const proInput = document.getElementById('proScanInput');

  if (proInput) {

    // CRITICAL: Auto-populate Pro scan input with text from main essay input if it exists

    // Do this BEFORE cloning the input so the value is preserved

    const mainInput = document.getElementById('essayInput');

    if (mainInput && mainInput.value.trim() && !proInput.value.trim()) {

      // Only transfer if Pro input is empty (don't overwrite existing text)

      proInput.value = mainInput.value.trim();

      console.log('âœ… Transferred essay from main input to Pro input:', proInput.value.length, 'characters');



      // Auto-check Pro authorship checkbox if main page checkbox was checked

      const mainAuthorshipCheckbox = document.getElementById('authorshipCheckbox');

      const proAuthorshipCheckbox = document.getElementById('proAuthorshipCheckbox');

      if (mainAuthorshipCheckbox && mainAuthorshipCheckbox.checked && proAuthorshipCheckbox) {

        proAuthorshipCheckbox.checked = true;

      }

    }



    // Remove old listeners first

    const newInput = proInput.cloneNode(true);

    proInput.parentNode.replaceChild(newInput, proInput);



    // Get the new input element after cloning

    const newProInput = document.getElementById('proScanInput');



    // Update character count after cloning

    if (newProInput && newProInput.value.trim()) {

      const charCountEl = document.getElementById('proCharCount');

      if (charCountEl) {

        charCountEl.textContent = `${newProInput.value.length} / 1,500`;

      }

    }



    if (newProInput) {

      newProInput.addEventListener('input', function() {

        const count = this.value.length;

        const countEl = document.getElementById('proCharCount');

        if (countEl) {

          let proWc = (document.getElementById('proScanInput').value || '').trim().split(/\s+/).filter(w => w.length > 0).length; countEl.textContent = Math.min(proWc, 1500).toLocaleString() + ' / 1,500';

        }



        // Update button state using helper function (checks both text length and authorship)

        if (typeof updateProScanButtonState === 'function') {

          updateProScanButtonState();

        }

      });



      // Trigger input event to update button state if text was transferred

      if (newProInput.value.trim()) {

        const inputEvent = new Event('input', { bubbles: true });

        newProInput.dispatchEvent(inputEvent);



        // Update button state

        if (typeof updateProScanButtonState === 'function') {

          updateProScanButtonState();

          setTimeout(() => {

            if (typeof updateProScanButtonState === 'function') {

              updateProScanButtonState();

            }

          }, 50);

          setTimeout(() => {

            if (typeof updateProScanButtonState === 'function') {

              updateProScanButtonState();

            }

          }, 300);

        }

      }

    }



    // Also listen for authorship checkbox changes

    const proAuthorshipCheckbox = document.getElementById('proAuthorshipCheckbox');

    if (proAuthorshipCheckbox) {

      proAuthorshipCheckbox.addEventListener('change', function() {

        if (typeof updateProScanButtonState === 'function') {

          updateProScanButtonState();

        }

      });

    }

  }



  // Scroll to top

  window.scrollTo({ top: 0, behavior: 'smooth' });



  // Show welcome modal on first visit (only for existing Pro users, not during upgrade flow)

  const hasSeenProWelcome = localStorage.getItem('proWelcomeSeen');

  if (!hasSeenProWelcome) {

    setTimeout(() => {

      showProWelcomeModal(false); // false = dashboard welcome, not upgrade

    }, 500);

  }



  console.log('âœ… Pro Dashboard ready');

}



// Pro Welcome Modal - Shows Pro features before payment or on first dashboard visit

function showProWelcomeModal(isUpgrade = false) {

  const modal = document.createElement('div');

  modal.id = 'proWelcomeModal';

  modal.style.cssText = `

    position: fixed;

    top: 0;

    left: 0;

    width: 100%;

    height: 100%;

    background: rgba(0, 0, 0, 0.6);

    display: flex;

    justify-content: center;

    align-items: center;

    z-index: 10000;

    backdrop-filter: blur(5px);

  `;



  const title = isUpgrade ? 'Upgrade to Pro ðŸ’Ž' : 'Welcome to Pro! ðŸŽ‰';

  const subtitle = isUpgrade ? 'Full protection from false AI flags â€” see your exact score, catch every trigger, and fix it before you submit' : 'Here\'s what you can do with your Pro subscription';

  const buttonText = isUpgrade ? 'Continue to Pro âœ¨' : 'Start Scanning âœ¨';

  const buttonOnClick = isUpgrade ? 'proWelcomeToPayment()' : 'closeProWelcomeModal()';



  modal.innerHTML = `

    <div style="

      background: white;

      border-radius: 24px;

      padding: 40px;

      max-width: 900px;

      width: 90%;

      max-height: 90vh;

      overflow-y: auto;

      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);

      position: relative;

    ">

      <button onclick="closeProWelcomeModal()" style="

        position: absolute;

        top: 15px;

        right: 20px;

        background: none;

        border: none;

        font-size: 32px;

        color: #9ca3af;

        cursor: pointer;

        padding: 5px;

        line-height: 1;

        transition: color 0.2s;

      " onmouseover="this.style.color='#dc2626';" onmouseout="this.style.color='#9ca3af';">Ã—</button>



      <div style="text-align: center; margin-bottom: 30px;">

        <h2 class="modal-title" style="color: #0b0646; margin: 0 0 10px; font-size: 28px; font-weight: 800;">

          ${title}

        </h2>

        <p class="modal-subtitle" style="color: #6b7280; font-size: 16px; margin: 0;">

          ${subtitle}

        </p>

      </div>



      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 18px; margin-bottom: 30px;">

        <div class="pro-feature" style="background: #f8f9fa; padding: 20px; border-radius: 14px; border: 2px solid #e5e7eb;">

          <div class="pro-feature-icon" style="font-size: 36px; margin-bottom: 10px;">ðŸ§ </div>

          <div class="pro-feature-title" style="color: #0b0646; margin: 0 0 8px; font-size: 16px; font-weight: 700;">School-Level Scan</div>

          <div class="pro-feature-desc" style="color: #6b7280; font-size: 13px; line-height: 1.5; margin: 0;">Emulates real university AI detectors for the most accurate risk prediction.</div>

        </div>



        <div class="pro-feature" style="background: #f8f9fa; padding: 20px; border-radius: 14px; border: 2px solid #e5e7eb;">

          <div class="pro-feature-icon" style="font-size: 36px; margin-bottom: 10px;">ðŸ“‰</div>

          <div class="pro-feature-title" style="color: #0b0646; margin: 0 0 8px; font-size: 16px; font-weight: 700;">AI Risk Score</div>

          <div class="pro-feature-desc" style="color: #6b7280; font-size: 13px; line-height: 1.5; margin: 0;">See your exact AI detection risk level after applying fixes â€” know if it's safe to submit before you turn it in.</div>

        </div>



        <div class="pro-feature" style="background: #f8f9fa; padding: 20px; border-radius: 14px; border: 2px solid #e5e7eb;">

          <div class="pro-feature-icon" style="font-size: 36px; margin-bottom: 10px;">ðŸ”€</div>

          <div class="pro-feature-title" style="color: #0b0646; margin: 0 0 8px; font-size: 16px; font-weight: 700;">Multiple Fix Options</div>

          <div class="pro-feature-desc" style="color: #6b7280; font-size: 13px; line-height: 1.5; margin: 0;">Pick from options that are less likely to get flagged, or write your own replacement that matches your vibe.</div>

        </div>



        <div class="pro-feature" style="background: #f8f9fa; padding: 20px; border-radius: 14px; border: 2px solid #e5e7eb;">

          <div class="pro-feature-icon" style="font-size: 36px; margin-bottom: 10px;">ðŸ’¡</div>

          <div class="pro-feature-title" style="color: #0b0646; margin: 0 0 8px; font-size: 16px; font-weight: 700;">Risk Explanations</div>

          <div class="pro-feature-desc" style="color: #6b7280; font-size: 13px; line-height: 1.5; margin: 0;">See exactly why detectors flag certain phrases â€” and how to rewrite them.</div>

        </div>



        <div class="pro-feature" style="background: #f8f9fa; padding: 20px; border-radius: 14px; border: 2px solid #e5e7eb;">

          <div class="pro-feature-icon" style="font-size: 36px; margin-bottom: 10px;">ðŸ“</div>

          <div class="pro-feature-title" style="color: #0b0646; margin: 0 0 8px; font-size: 16px; font-weight: 700;">1,500 Words</div>

          <div class="pro-feature-desc" style="color: #6b7280; font-size: 13px; line-height: 1.5; margin: 0;">Scan full assignments and reports with expanded character limits.</div>

        </div>



        <div class="pro-feature" style="background: #f8f9fa; padding: 20px; border-radius: 14px; border: 2px solid #e5e7eb;">

          <div class="pro-feature-icon" style="font-size: 36px; margin-bottom: 10px;">ðŸ“Š</div>

          <div class="pro-feature-title" style="color: #0b0646; margin: 0 0 8px; font-size: 16px; font-weight: 700;">500 Monthly Scans + Fix History</div>

          <div class="pro-feature-desc" style="color: #6b7280; font-size: 13px; line-height: 1.5; margin: 0;">Scan on repeat and check your last 10 fixes â€” compare versions and track your improvements.</div>

        </div>

      </div>



      ${isUpgrade ? `

      <div style="text-align: center; margin: 20px 0;">

        <p style="color: #6b7280; font-size: 16px; margin: 0 0 8px 0; font-weight: 500;">

          Trusted by students everywhere.

        </p>

        <p style="color: #0b0646; font-size: 15px; margin: 0 0 4px 0; font-weight: 600;">

          Join thousands of students using False Flag Fixerâ„¢ Pro

        </p>

        <p style="margin: 0; font-size: 18px;">

          <span style="color: #fbbf24;">â˜…â˜…â˜…â˜…â˜…</span>

        </p>

      </div>

      ` : ''}



      <div style="text-align: center;">

        <button onclick="${buttonOnClick}" class="pro-upgrade-btn btn-success" style="padding: 12px 32px; font-size: 16px !important; font-weight: 600 !important; box-shadow: 0 4px 15px rgba(0, 168, 232, 0.3); margin-bottom: 15px;">

          ${buttonText}

        </button>

        ${isUpgrade ? '<a href="javascript:void(0)" onclick="closeProWelcomeModal(); hideProDashboard();" class="modal-dismiss" style="display:block;text-align:center;color:#9ca3af;font-size:14px;text-decoration:underline;cursor:pointer;margin-top:10px;">Not now â€” I\'ll risk it ðŸ˜¬</a>' : ''}

      </div>

    </div>

  `;



  document.body.appendChild(modal);

  document.body.classList.add('modal-open');



  // Close on backdrop click

  modal.addEventListener('click', function(e) {

    if (e.target === modal) {

      closeProWelcomeModal();

    }

  });

}



function closeProWelcomeModal() {

  const modal = document.getElementById('proWelcomeModal');

  if (modal) {

    modal.remove();

    document.body.classList.remove('modal-open');

    localStorage.setItem('proWelcomeSeen', 'true');

  }

  // Re-check button state after modal closes

  updateProScanButtonState();

}



// Helper function to update Pro scan button state

function updateProScanButtonState() {

  const proInput = document.getElementById('proScanInput');

  const proScanButton = document.getElementById('proScanButton');

  const proAuthorshipCheckbox = document.getElementById('proAuthorshipCheckbox');



  if (proInput && proScanButton) {

    const textLength = proInput.value.trim().length;

    const isAuthorshipConfirmed = proAuthorshipCheckbox ? proAuthorshipCheckbox.checked : true; // Default to true if checkbox doesn't exist



    console.log('updateProScanButtonState called:', { textLength, isAuthorshipConfirmed, buttonExists: !!proScanButton });



    // For Pro, only check text length (>= 50 chars) - no authorship checkbox required

    if (textLength >= 50) {

      proScanButton.disabled = false;

      proScanButton.style.background = 'linear-gradient(135deg, #00a8e8 0%, #0077b6 100%)';

      proScanButton.style.opacity = '1';

      proScanButton.style.cursor = 'pointer';

      proScanButton.style.boxShadow = '0 4px 15px rgba(0, 168, 232, 0.3)';

      console.log('Button enabled - Pro blue');

    } else {

      proScanButton.disabled = true;

      proScanButton.style.background = '#9ca3af';

      proScanButton.style.opacity = '0.6';

      proScanButton.style.cursor = 'not-allowed';

      proScanButton.style.boxShadow = 'none';

      console.log('Button disabled - grey (text too short:', textLength, ')');

    }

  } else {

    console.log('updateProScanButtonState: elements not found', { proInput: !!proInput, proScanButton: !!proScanButton });

  }

}



function proWelcomeToPayment() {

  closeProWelcomeModal();



  // Close the essay too long modal if it's open

  const essayTooLongModal = document.getElementById('essayTooLongModal');

  if (essayTooLongModal && essayTooLongModal.style.display !== 'none') {

    essayTooLongModal.style.display = 'none';

    document.body.classList.remove('modal-open');

  }



  // If user is already Pro, go directly to Pro dashboard

  if (appState.isProUser || appState.proSubscription?.active) {

    showProDashboard();

    return;

  }



  // Otherwise, go to Pro dashboard (payment can be handled later)

  // For now, allow access to Pro dashboard

  showProDashboard();

}



function hideProDashboard() {

  console.log('ðŸ”„ hideProDashboard() called');

  const step6 = document.getElementById('quickfixStep6');

  if (step6) {

    step6.style.display = 'none';

    step6.classList.remove('active');

  }

  const inputSection = document.getElementById('inputSection');

  if (inputSection) {

    inputSection.style.display = 'block';

  }



  // CRITICAL: Clear essay input completely when returning to main dashboard

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    essayInput.value = '';

    updateCounter();

  }



  // CRITICAL: Uncheck authorship checkbox when returning to main dashboard

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (authorshipCheckbox) {

    authorshipCheckbox.checked = false;

    updateCounter(); // Update counter to reflect unchecked state

  }



  console.log('âœ… Returned to main dashboard');

}



// ===== PRO PAST FIXES HISTORY SYSTEM =====

// Save Pro scan to localStorage (max 10 scans)

function saveProScanToHistory(originalText, fixedText, flags, newScore, improvement) {

  try {

    const originalScore = appState.quickfixOriginalScore || (newScore + improvement);

    const scanData = {

      id: Date.now(),

      date: new Date().toLocaleString('en-US', { 

        month: 'short', 

        day: 'numeric', 

        year: 'numeric',

        hour: 'numeric',

        minute: '2-digit',

        hour12: true

      }),

      timestamp: Date.now(),

      originalScore: originalScore,

      newScore: newScore,

      improvement: improvement,

      flagsCount: flags ? flags.length : 0,

      originalText: originalText.substring(0, 500), // Store first 500 chars for preview

      fixedText: fixedText.substring(0, 500),

      fullOriginalText: originalText,

      fullFixedText: fixedText,

      flags: flags || []

    };



    // Get existing history

    let history = JSON.parse(localStorage.getItem('proScanHistory') || '[]');



    // Add new scan to beginning

    history.unshift(scanData);



    // Keep only last 10 scans

    if (history.length > 10) {

      history = history.slice(0, 10);

    }



    // Save back to localStorage

    localStorage.setItem('proScanHistory', JSON.stringify(history));

    console.log('âœ… Pro scan saved to history. Total scans:', history.length);

  } catch (error) {

    console.error('Error saving Pro scan to history:', error);

  }

}



// Show Pro Past Fixes modal

function showProPastFixes() {

  console.log('ðŸ“Š showProPastFixes() called');

  try {

    const history = JSON.parse(localStorage.getItem('proScanHistory') || '[]');

    console.log('ðŸ“Š Pro scan history found:', history.length, 'scans');



    if (history.length === 0) {

      console.log('ðŸ“Š No history found, showing message');

      if (typeof showSuccessMessage === 'function') {

        showSuccessMessage('No past fixes found. Your scan history will appear here after you complete scans.');

      } else {

        alert('No past fixes found. Your scan history will appear here after you complete scans.');

      }

      return;

    }



  // Create modal HTML

  const modalHTML = `

    <div id="proPastFixesModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;">

      <div style="background: white; border-radius: 16px; max-width: 800px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); position: relative;">

        <button onclick="closeProPastFixesModal()" style="position: absolute; top: 16px; right: 16px; background: #f3f4f6; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 24px; color: #6b7280; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#e5e7eb'; this.style.color='#374151';" onmouseout="this.style.background='#f3f4f6'; this.style.color='#6b7280';">Ã—</button>



        <div style="padding: 32px 24px 24px 24px;">

          <h2 style="margin: 0 0 8px 0; font-size: 28px; font-weight: 700; color: #0b0646; text-align: center;">ðŸ“Š Your Past Fixes</h2>

          <p style="margin: 0 0 24px 0; font-size: 14px; color: #6b7280; text-align: center;">View and copy your last 10 Pro scans</p>



          <div id="proPastFixesList" style="display: flex; flex-direction: column; gap: 12px;">

            ${history.slice(0, 10).map((scan, index) => `

              <div style="background: #f8f9fa; border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; transition: all 0.2s;" onmouseover="this.style.borderColor='#00a8e8'; this.style.boxShadow='0 2px 8px rgba(0, 168, 232, 0.15)';" onmouseout="this.style.borderColor='#e5e7eb'; this.style.boxShadow='none';">

                <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 16px; flex-wrap: wrap;">

                  <div style="flex: 1; min-width: 200px;">

                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">

                      <span style="font-size: 20px;">${index === 0 ? 'ðŸ†•' : 'ðŸ“„'}</span>

                      <div>

                        <div style="font-size: 14px; font-weight: 600; color: #374151;">${scan.date}</div>

                        <div style="font-size: 12px; color: #6b7280;">${scan.flagsCount} ${scan.flagsCount === 1 ? 'flag' : 'flags'} fixed</div>

                      </div>

                    </div>

                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">

                      <span style="font-size: 18px; font-weight: 700; color: #dc2626;">${scan.originalScore || 0}%</span>

                      <span style="color: #9ca3af;">â†’</span>

                      <span style="font-size: 18px; font-weight: 700; color: #2ecc71;">${scan.newScore !== undefined && scan.newScore !== null ? scan.newScore : '--'}%</span>

                      <span style="font-size: 12px; color: #6b7280; margin-left: 4px;">(${scan.improvement !== undefined && scan.improvement !== null ? scan.improvement : '--'}% improvement)</span>

                    </div>

                  </div>

                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">

                    <button onclick="viewProPastFixDetails(${scan.id})" style="background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#0099d4';" onmouseout="this.style.background='#00a8e8';">View Details</button>

                    <button onclick="copyProPastFix(${scan.id})" style="background: white; color: #00a8e8; border: 1px solid #00a8e8; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f0f9ff';" onmouseout="this.style.background='white';">Copy Text</button>

                  </div>

                </div>

              </div>

            `).join('')}

          </div>

        </div>

      </div>

    </div>

  `;



    // Remove existing modal if any

    const existingModal = document.getElementById('proPastFixesModal');

    if (existingModal) {

      existingModal.remove();

    }



    // Add modal to page

    document.body.insertAdjacentHTML('beforeend', modalHTML);

    document.body.style.overflow = 'hidden';

    console.log('ðŸ“Š Pro Past Fixes modal displayed');

  } catch (error) {

    console.error('âŒ Error in showProPastFixes:', error);

    if (typeof showSuccessMessage === 'function') {

      showSuccessMessage('Error loading past fixes. Please try again.');

    } else {

      alert('Error loading past fixes. Please try again.');

    }

  }

}



// Close Pro Past Fixes modal

function closeProPastFixesModal() {

  const modal = document.getElementById('proPastFixesModal');

  if (modal) {

    modal.remove();

    document.body.style.overflow = '';

  }

}



// View details of a past fix

function viewProPastFixDetails(scanId) {

  const history = JSON.parse(localStorage.getItem('proScanHistory') || '[]');

  const scan = history.find(s => s.id === scanId);



  if (!scan) {

    showSuccessMessage('Scan not found.');

    return;

  }



  // Close the list modal

  closeProPastFixesModal();



  // Create detail modal

  const detailModalHTML = `

    <div id="proPastFixDetailModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10001; display: flex; align-items: center; justify-content: center; padding: 20px;">

      <div style="background: white; border-radius: 16px; max-width: 900px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); position: relative;">

        <button onclick="closeProPastFixDetailModal()" style="position: absolute; top: 16px; right: 16px; background: #f3f4f6; border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 24px; color: #6b7280; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#e5e7eb'; this.style.color='#374151';" onmouseout="this.style.background='#f3f4f6'; this.style.color='#6b7280';">Ã—</button>



        <div style="padding: 32px 24px 24px 24px;">

          <h2 style="margin: 0 0 8px 0; font-size: 24px; font-weight: 700; color: #0b0646;">Scan Details - ${scan.date}</h2>

          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 24px; padding: 16px; background: #f8f9fa; border-radius: 8px;">

            <div>

              <div style="font-size: 14px; color: #6b7280; margin-bottom: 4px;">Score Improvement</div>

              <div style="display: flex; align-items: center; gap: 8px;">

                <span style="font-size: 32px; font-weight: 700; color: #dc2626;">${scan.originalScore || 0}%</span>

                <span style="color: #9ca3af; font-size: 20px;">â†’</span>

                <span style="font-size: 32px; font-weight: 700; color: #2ecc71;">${scan.newScore !== undefined && scan.newScore !== null ? scan.newScore : '--'}%</span>

                <span style="font-size: 16px; color: #6b7280; margin-left: 8px;">(${scan.improvement !== undefined && scan.improvement !== null ? scan.improvement : '--'}% improvement)</span>

              </div>

            </div>

            <div style="margin-left: auto; text-align: right;">

              <div style="font-size: 14px; color: #6b7280;">Flags Fixed</div>

              <div style="font-size: 24px; font-weight: 700; color: #00a8e8;">${scan.flagsCount}</div>

            </div>

          </div>



          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 24px;">

            <div>

              <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 700; color: #dc2626;">Before Pro - ${scan.originalScore || 0}%</h3>

              <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 16px; max-height: 300px; overflow-y: auto; font-size: 14px; line-height: 1.6; color: #374151; white-space: pre-line;">

                ${scan.fullOriginalText || scan.originalText}

              </div>

            </div>

            <div>

              <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 700; color: #2ecc71;">After Pro - ${scan.newScore !== undefined && scan.newScore !== null ? scan.newScore : '--'}%</h3>

              <div style="background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 16px; max-height: 300px; overflow-y: auto; font-size: 14px; line-height: 1.6; color: #374151; white-space: pre-line;">

                ${scan.fullFixedText || scan.fixedText}

              </div>

            </div>

          </div>



          <div style="display: flex; gap: 12px; justify-content: center;">

            <button onclick="copyProPastFix(${scan.id})" style="background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#0099d4';" onmouseout="this.style.background='#00a8e8';">ðŸ“‹ Copy Fixed Text</button>

            <button onclick="closeProPastFixDetailModal(); showProPastFixes();" style="background: white; color: #00a8e8; border: 1px solid #00a8e8; padding: 12px 24px; border-radius: 8px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f0f9ff';" onmouseout="this.style.background='white';">â† Back to List</button>

          </div>

        </div>

      </div>

    </div>

  `;



  document.body.insertAdjacentHTML('beforeend', detailModalHTML);

  document.body.style.overflow = 'hidden';

}



// Close detail modal

function closeProPastFixDetailModal() {

  const modal = document.getElementById('proPastFixDetailModal');

  if (modal) {

    modal.remove();

    document.body.style.overflow = '';

  }

}



// Copy past fix text

function copyProPastFix(scanId) {

  const history = JSON.parse(localStorage.getItem('proScanHistory') || '[]');

  const scan = history.find(s => s.id === scanId);



  if (!scan) {

    showSuccessMessage('Scan not found.');

    return;

  }



  const textToCopy = scan.fullFixedText || scan.fixedText;



  navigator.clipboard.writeText(textToCopy).then(() => {

    showSuccessMessage('âœ… Fixed text copied to clipboard!');

  }).catch(() => {

    // Fallback for older browsers

    const textArea = document.createElement('textarea');

    textArea.value = textToCopy;

    document.body.appendChild(textArea);

    textArea.select();

    document.execCommand('copy');

    document.body.removeChild(textArea);

    showSuccessMessage('âœ… Fixed text copied to clipboard!');

  });

}



// Edit Pro fixes - go back to step 2

async function editProFixes() {

  // Ensure we're in Pro mode context

  appState.isProUser = true;



  // Show Step 2 and hide Step 3

  showQuickFixStep(2);

  const step3 = document.getElementById('quickfixStep3');

  if (step3) step3.classList.remove('active');



  // CRITICAL: For Pro users, ALWAYS show both Step 2 CTAs (green Pro All + blue Pro Selected Words Only + Back to Pro Dashboard) immediately when returning from Step 3

  const step2BackToDashboard = document.getElementById('quickfixStep2BackToDashboard');

  const step2BackToProDashboard = document.getElementById('step2BackToProDashboard');

  const step2TrustedSection = document.getElementById('step2TrustedSection');

  const applyAllBtn = document.getElementById('applyAllFixes');

  const applySelectedBtn = document.getElementById('applySelectedFixes');

  const step2BtnGroup = document.getElementById('quickfixButtonGroup');

  if (step2BackToDashboard) { step2BackToDashboard.style.display = 'none'; step2BackToDashboard.style.setProperty('display', 'none', 'important'); }

  if (step2BackToProDashboard) { step2BackToProDashboard.style.display = 'block'; step2BackToProDashboard.style.setProperty('display', 'block', 'important'); }

  const editProScore = appState.quickfixOriginalScore ?? appState.proOriginalScore ?? 99;

  const proStep2BackBtn = document.getElementById('proStep2BackToDashboard');

  if (proStep2BackBtn) {

    if (editProScore < 30) { proStep2BackBtn.style.display = 'none'; proStep2BackBtn.style.setProperty('display', 'none', 'important'); }

    else { proStep2BackBtn.style.display = 'block'; proStep2BackBtn.style.setProperty('display', 'block', 'important'); }

  }

  if (step2TrustedSection) {

    if (editProScore < 30) { step2TrustedSection.style.display = 'none'; step2TrustedSection.style.setProperty('display', 'none', 'important'); }

    else { step2TrustedSection.style.display = 'block'; }

  }

  if (step2BtnGroup) { step2BtnGroup.style.display = 'flex'; step2BtnGroup.style.setProperty('display', 'flex', 'important'); }

  if (applyAllBtn) { applyAllBtn.style.display = 'flex'; applyAllBtn.style.setProperty('display', 'flex', 'important'); applyAllBtn.style.visibility = 'visible'; applyAllBtn.style.setProperty('visibility', 'visible', 'important'); }

  if (applySelectedBtn) {

    applySelectedBtn.style.display = 'flex';

    applySelectedBtn.style.setProperty('display', 'flex', 'important');

    applySelectedBtn.style.visibility = 'visible';

    applySelectedBtn.style.setProperty('visibility', 'visible', 'important');

    applySelectedBtn.style.setProperty('background', '#00a8e8', 'important');

    applySelectedBtn.style.setProperty('color', 'white', 'important');

  }

  console.log('âœ… editProFixes: both Step 2 CTAs (Pro All + Pro Selected Words Only + Back to Pro Dashboard) forced visible');



  // CRITICAL: Restore to ORIGINAL state (before any partial fixes) - like trying again from scratch

  // Use stored reset state from when user first arrived at Step 2, or fallback to current original

  const originalText = appState.quickfixResetOriginalText || appState.quickfixOriginalText || '';

  const originalScore = appState.quickfixResetOriginalScore ?? appState.quickfixOriginalScore ?? appState.proOriginalScore ?? 0;

  const originalFlags = (appState.quickfixResetFlagsOriginal && appState.quickfixResetFlagsOriginal.length > 0)

    ? JSON.parse(JSON.stringify(appState.quickfixResetFlagsOriginal))

    : (appState.quickfixFlagsOriginal || appState.quickfixFlags || []);



  // Restore appState to original so apply fixes uses correct baseline

  appState.quickfixOriginalText = originalText;

  appState.quickfixOriginalScore = originalScore;

  appState.quickfixFlags = JSON.parse(JSON.stringify(originalFlags));

  appState.quickfixFlagsOriginal = originalFlags;

  appState.quickfixFixedText = '';

  appState.quickfixNewScore = null;

  appState.apiResponse = null;



  console.log('ðŸ”„ editProFixes - Restoring to original state (try again from scratch):', {

    originalTextLength: originalText.length,

    originalScore: originalScore,

    originalFlagsCount: originalFlags.length

  });



  if (originalText && originalFlags.length > 0 && typeof displayQuickFixAnalysis === 'function') {

    displayQuickFixAnalysis(originalText, originalScore, originalFlags);

  }



  // Reset select-all checkbox so user starts fresh

  const selectAllCheckbox = document.getElementById('selectAllFixes');

  if (selectAllCheckbox) selectAllCheckbox.checked = false;



  // Re-enable fix selection UI

  const fixSelectionContainer = document.getElementById('fixSelection');

  const instructionText = document.getElementById('quickfixInstructionText');

  const fixesTitle = document.getElementById('quickfixFixesTitle');

  const fixesSubtitle = document.getElementById('quickfixFixesSubtitle');

  const applyButton = document.getElementById('applySelectedFixes');

  const copyButton = document.getElementById('copyTextButton');

  const buttonGroup = document.getElementById('quickfixButtonGroup');

  const flagExplanationsSection = document.getElementById('flagExplanationsSection');



  if (fixSelectionContainer) fixSelectionContainer.style.display = 'block';

  if (flagExplanationsSection) flagExplanationsSection.style.display = 'block';

  if (instructionText) instructionText.style.display = 'block';

  if (fixesTitle) {

    fixesTitle.textContent = 'Pick Your Fixes';

    fixesTitle.style.color = '#dc2626';

  }

  if (fixesSubtitle) {

    fixesSubtitle.textContent = 'You can auto-fix all high-risk words at once, or customize each one below.';

    fixesSubtitle.style.color = '#6b7280';

  }

  if (applyButton) {

    // Show/hide button based on Pro status and score

    const step2 = document.getElementById('quickfixStep2');

    const isStep2Active = step2 && (step2.style.display !== 'none' && step2.classList.contains('active'));

    const isPro = appState.isProUser || false;

    const currentScore = appState.quickfixOriginalScore || appState.proOriginalScore || 0;

    const isHellaSusOrKindaSus = currentScore >= 30;



    if (isPro && isStep2Active) {

      if (!isHellaSusOrKindaSus) {

        // Hide button only for Clean cases (score < 30)

        applyButton.style.display = 'none';

        applyButton.style.setProperty('display', 'none', 'important');

        applyButton.style.visibility = 'hidden';

        applyButton.style.setProperty('visibility', 'hidden', 'important');

      } else {

        // CRITICAL: Show blue button for Hella Sus/Kinda Sus (score >= 30)

        applyButton.style.display = 'inline-block';

        applyButton.style.setProperty('display', 'inline-block', 'important');

        applyButton.style.visibility = 'visible';

        applyButton.style.setProperty('visibility', 'visible', 'important');

        applyButton.style.setProperty('background', '#00a8e8', 'important');

        applyButton.style.setProperty('color', 'white', 'important');

        console.log('âœ… Blue CTA shown in editProFixes for Pro Step 2 Hella Sus/Kinda Sus');

      }

    } else {

      applyButton.style.display = 'inline-block';

      applyButton.style.setProperty('display', 'inline-block', 'important');

    }

  }

  if (copyButton) {

    copyButton.style.display = 'none';

    copyButton.style.setProperty('display', 'none', 'important');

  }

  if (buttonGroup) {

    buttonGroup.style.display = 'flex';

    buttonGroup.style.setProperty('display', 'flex', 'important');

  }



  // CRITICAL: Update button text and color for Pro users

  setTimeout(() => {

    updateStepLabels(true);

    // Force update the selected count button

    const applySelectedButton = document.getElementById('applySelectedFixes');

    if (applySelectedButton && appState.isProUser) {

      const selectedCountEl = applySelectedButton.querySelector('#selectedCount');

      const currentCount = selectedCountEl ? selectedCountEl.textContent : '0';

      applySelectedButton.innerHTML = `Pro (Selected Words Only (<span id="selectedCount">${currentCount}</span>))`;

      applySelectedButton.style.setProperty('background', '#00a8e8', 'important');

      applySelectedButton.style.setProperty('color', 'white', 'important');

    }

  }, 100);



  // Scroll to top

  window.scrollTo({ top: 0, behavior: 'smooth' });



  showSuccessMessage('Edit your fixes below, then click "Apply Selected Fixes" when done.');

}



// Make functions globally accessible

window.saveProScanToHistory = saveProScanToHistory;

window.showProPastFixes = showProPastFixes;

window.closeProPastFixesModal = closeProPastFixesModal;

window.viewProPastFixDetails = viewProPastFixDetails;

window.closeProPastFixDetailModal = closeProPastFixDetailModal;

window.copyProPastFix = copyProPastFix;

window.editProFixes = editProFixes;

window.viewProScanHistory = viewProScanHistory;

window.updateProDashboardStats = updateProDashboardStats;



// Save Pro scan to history

function saveProScanToHistory(originalText, score, flags, fixedText, newScore) {

  // Check if user is Pro (either via subscription or isProUser flag)

  const isPro = appState.isProUser || (appState.proSubscription && appState.proSubscription.active);

  if (!isPro) {

    console.log('âš ï¸ Not saving to history - user is not Pro');

    return;

  }



  console.log('ðŸ’¾ Saving Pro scan to history...', {

    originalScore: score,

    newScore: newScore,

    flagsCount: flags ? flags.length : 0

  });



  try {

    const originalScore = typeof score === 'number' ? score : (appState.quickfixOriginalScore || score || 0);

    const finalNewScore = typeof newScore === 'number' ? newScore : originalScore;

    const improvement = originalScore - finalNewScore;



    const scanData = {

      id: Date.now(),

      // Human-readable date for dashboard tiles and past fixes modal

      date: new Date().toLocaleString('en-US', {

        month: 'short',

        day: 'numeric',

        year: 'numeric',

        hour: 'numeric',

        minute: '2-digit',

        hour12: true

      }),

      timestamp: Date.now(),

      // Fields expected by the Past Fixes modal

      originalScore: originalScore,

      newScore: finalNewScore,

      improvement: improvement,

      flagsCount: flags ? flags.length : 0,

      // Short previews for dashboard

      originalText: (originalText || '').substring(0, 500),

      fixedText: (fixedText || '').substring(0, 500),

      // Full texts for detail view

      fullOriginalText: originalText || '',

      fullFixedText: fixedText || '',

      flags: flags || []

    };



    let scanHistory = JSON.parse(localStorage.getItem('proScanHistory') || '[]');

    scanHistory.unshift(scanData); // Add to beginning

    if (scanHistory.length > 10) {

      scanHistory = scanHistory.slice(0, 10); // Keep last 10

    }



    localStorage.setItem('proScanHistory', JSON.stringify(scanHistory));

    console.log('âœ… Pro scan saved to history successfully! Total scans:', scanHistory.length);

    updateProDashboardStats();

  } catch (error) {

    console.error('âŒ Failed to save Pro scan to history:', error);

  }

}



// Calculate renewal date (signup + 30 days)

function getProRenewalDate() {

  const signupDate = appState.proSubscription.signupDate || new Date().toISOString();

  const signup = new Date(signupDate);

  const renewal = new Date(signup);

  renewal.setDate(renewal.getDate() + 30);

  return renewal;

}



// Calculate days until renewal

function getDaysUntilRenewal() {

  const renewal = getProRenewalDate();

  const now = new Date();

  const diffTime = renewal - now;

  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return Math.max(0, diffDays);

}



// Calculate average score drop from scan history

function calculateAvgScoreDrop() {

  const scanHistory = JSON.parse(localStorage.getItem('proScanHistory') || '[]');

  if (scanHistory.length === 0) return 0;



  const improvements = scanHistory

    .filter(scan => scan.improvement > 0)

    .map(scan => scan.improvement);



  if (improvements.length === 0) return 0;

  const avg = improvements.reduce((a, b) => a + b, 0) / improvements.length;

  return Math.round(avg);

}



// Update Pro Dashboard stats display

function updateProDashboardStats() {

  const scansUsed = appState.proSubscription.scansUsed || 0;

  const scansLimit = appState.proSubscription.scansLimit || 500;

  const remaining = scansLimit - scansUsed;

  const percentage = (scansUsed / scansLimit) * 100;



  // Update Pro Scans Remaining card

  const scansRemainingEl = document.getElementById('proScansRemainingNumber');

  if (scansRemainingEl) {

    scansRemainingEl.textContent = `${remaining}`;

  }



  const renewalDate = getProRenewalDate();

  const renewalTextEl = document.getElementById('proScansRenewalText');

  if (renewalTextEl) {

    const renewalStr = renewalDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

    renewalTextEl.textContent = `Resets ${renewalStr}`;

  }



  const progressBarEl = document.getElementById('proScansProgressBar');

  if (progressBarEl) {

    progressBarEl.style.width = `${percentage}%`;

  }



  // Update Essays Fixed

  const scanHistory = JSON.parse(localStorage.getItem('proScanHistory') || '[]');

  const thisMonthScans = scanHistory.filter(scan => {

    const scanDate = new Date(scan.date);

    const now = new Date();

    return scanDate.getMonth() === now.getMonth() && scanDate.getFullYear() === now.getFullYear();

  });

  const essaysFixedEl = document.getElementById('proEssaysFixedNumber');

  if (essaysFixedEl) {

    essaysFixedEl.textContent = thisMonthScans.length || scansUsed;

  }



  // Update Avg Score Drop

  const avgDrop = calculateAvgScoreDrop();

  const avgDropEl = document.getElementById('proAvgScoreDrop');

  if (avgDropEl) {

    avgDropEl.textContent = avgDrop > 0 ? `${avgDrop}%` : 'â€”';

  }



  // Update Recent Scans

  updateRecentScansDisplay();

}



// Update Recent Scans grid

function updateRecentScansDisplay() {

  const scanHistory = JSON.parse(localStorage.getItem('proScanHistory') || '[]');

  const recentScansGrid = document.getElementById('proRecentScansGrid');

  if (!recentScansGrid) return;



  if (scanHistory.length === 0) {

    recentScansGrid.innerHTML = '<div class="empty-state" style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #94a3b8;"><div class="empty-icon" style="font-size: 60px; margin-bottom: 12px; opacity: 0.5;">ðŸ“</div><div class="empty-text" style="font-size: 15px; font-weight: 600;">No scans yet â€” let\'s fix your first essay!</div></div>';

    return;

  }



  const recent3 = scanHistory.slice(0, 3);

  recentScansGrid.innerHTML = recent3.map(scan => {

    // Handle date - it might be a formatted string or timestamp

    let dateStr = scan.date || '';

    if (scan.timestamp) {

      const scanDate = new Date(scan.timestamp);

      dateStr = scanDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

    } else if (scan.date && typeof scan.date === 'string' && scan.date.includes(',')) {

      // Already formatted date string, extract just month and day

      const parts = scan.date.split(',');

      dateStr = parts[0] || scan.date;

    }



    // Use newScore (final score after fixes) instead of score

    const finalScore = scan.newScore !== undefined && scan.newScore !== null ? scan.newScore : (scan.originalScore || 0);

    const scoreColor = finalScore >= 70 ? '#dc2626' : finalScore >= 30 ? '#f59e0b' : '#10b981';

    const scoreLabel = finalScore >= 70 ? 'Major Sus' : finalScore >= 30 ? 'Mid Sus' : 'Low Sus';



    return `

      <div onclick="viewProScanHistory(${scan.id})" style="background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='#0ea5e9'; this.style.boxShadow='0 2px 8px rgba(14, 165, 233, 0.15)';" onmouseout="this.style.borderColor='#e5e7eb'; this.style.boxShadow='none';">

        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">${dateStr}</div>

        <div style="display: inline-block; background: ${scoreColor}; color: white; padding: 4px 10px; border-radius: 6px; font-size: 12px; font-weight: 700; margin-bottom: 8px;">${finalScore}% ${scoreLabel}</div>

        <div style="font-size: 13px; color: #374151; line-height: 1.4; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${scan.originalText || ''}</div>

      </div>

    `;

  }).join('');



  // Fill remaining slots if less than 3

  while (recentScansGrid.children.length < 3) {

    const emptySlot = document.createElement('div');

    emptySlot.style.display = 'none';

    recentScansGrid.appendChild(emptySlot);

  }

}



// View scan from history (placeholder - can link to showProPastFixDetails)

function viewProScanHistory(scanId) {

  // For now, just show the past fixes modal

  if (typeof showProPastFixes === 'function') {

    showProPastFixes();

  }

}



function updateProUsageStats() {

  const scansUsed = appState.proSubscription.scansUsed || 0;

  const scansLimit = appState.proSubscription.scansLimit || 500;



  // Update new hero stats

  updateProDashboardStats();



  // Legacy ring widget (keep for compatibility)

  const ringNumber = document.getElementById('proRingNumber');

  if (ringNumber) {

    ringNumber.textContent = scansUsed;

  }



  const ringProgress = document.getElementById('proRingProgress');

  if (ringProgress) {

    const percentage = Math.min(100, (scansUsed / scansLimit) * 100);

    const circumference = 2 * Math.PI * 75;

    const offset = circumference - (percentage / 100) * circumference;

    ringProgress.style.strokeDashoffset = offset;

  }

}



async function startProScan() {

  const text = document.getElementById('proScanInput').value.trim();



  if (text.length < 50) {

    showWarningModal();

    return;

  }



  if (text.length > 5000) {

    showSuccessMessage('Text exceeds 1,500 word limit');

    return;

  }



  // CRITICAL: Set Pro mode flag

  appState.isProUser = true;



  // Update labels from QuickFix to Pro

  updateStepLabels(true);



  // 1. Hide Pro Dashboard (Step 6)

  const step6 = document.getElementById('quickfixStep6');

  if (step6) {

    step6.style.setProperty('display', 'none', 'important');

    step6.classList.remove('active');

  }



  // 2. Show quickfixFlow (step 2 is inside it) but hide quickfixStep1

  const quickfixFlow = document.getElementById('quickfixFlow');

  if (quickfixFlow) {

    quickfixFlow.style.setProperty('display', 'block', 'important');

  }

  const quickfixStep1 = document.getElementById('quickfixStep1');

  if (quickfixStep1) {

    quickfixStep1.style.setProperty('display', 'none', 'important');

    quickfixStep1.classList.remove('active');

  }



  // Hide input section

  const inputSection = document.getElementById('inputSection');

  if (inputSection) {

    inputSection.style.setProperty('display', 'none', 'important');

  }



  // Scroll to top of page immediately

  window.scrollTo({ top: 0, behavior: 'instant' });



  // 3. Change labels from QuickFix to Pro

  updateStepLabels(true);



  // Show scanning modal

  showScanningModal();



  // CRITICAL: Make Pro API call to get enhanced analysis

  // This ensures users get the enhanced functionality they're paying for

  let flags, score;



  try {

    console.log('ðŸ” Pro: Calling API for enhanced analysis...');

    const analysis = await analyzeTextWithAPI(text);



    console.log('ðŸ” Pro API Result:', {

      score: analysis.score,

      flagCount: analysis.flagCount,

      issuesCount: analysis.issues?.length || 0

    });



    // Convert API issues to flags format (enhanced analysis from Pro API)

    flags = (analysis.issues || []).map(issue => ({

      phrase: issue.phrase || issue.text || '',

      explanation: issue.explanation || issue.reason || 'AI pattern detected',

      suggestedFix: (issue.alternatives && issue.alternatives[0]) || 'Rephrase in your own words',

      severity: issue.severity || 'medium',

      impact: issue.impact || 15

    }));



    score = analysis.score;



    // Reference free scan count for UI consistency (if same text was scanned)

    const freeScanText = appState.originalText || '';

    const freeScanFlags = appState.flagData || [];

    const textMatches = freeScanText.trim().length > 0 && 

                       (text.trim() === freeScanText.trim() || 

                        Math.abs(text.trim().length - freeScanText.trim().length) < 50);



    if (textMatches && freeScanFlags.length > 0) {

      console.log('âœ… Pro: Enhanced analysis complete. Showing same', freeScanFlags.length, 'flags as free scan for UI consistency');

      console.log('ðŸ“Š Pro enhanced flags:', flags.length, 'vs Free scan flags:', freeScanFlags.length);

    }



    hideScanningModal();

  } catch (error) {

    console.error('âŒ Pro API call failed:', error);

    hideScanningModal();

    showSuccessMessage('âŒ Pro scan failed. Please try again.');

    return;

  }



  // Continue with Pro scan processing (both paths converge here)



    // Store Pro scan data (also store in quickfix state for compatibility)

    appState.proOriginalText = text;

    appState.proFlags = flags;

    appState.proOriginalScore = score;

    appState.proFixedText = '';

    appState.proNewScore = 0;



    // Also store in quickfix state so displayQuickFixAnalysis works

    appState.quickfixOriginalText = text;

    appState.quickfixFlags = flags;

    appState.quickfixOriginalScore = score;



    // Increment Pro scans used

    if (appState.proSubscription.active) {

      appState.proSubscription.scansUsed++;

      updateProUsageStats();

    }



    // 4. Show quickfixStep2 and populate with Pro data

    showProStep(2);

    appState.quickfixResetOriginalText = text;

    appState.quickfixResetOriginalScore = score;

    appState.quickfixResetFlagsOriginal = JSON.parse(JSON.stringify(flags));

    displayQuickFixAnalysis(text, score, flags);



    // 5. Hide Apply Pro Fixes button for Pro Step 2 ONLY for Clean cases (score < 30)

    // Show both buttons for Hella Sus and Kinda Sus (score >= 30)

    setTimeout(() => {

      const applyButton = document.getElementById('applySelectedFixes');

      const step2 = document.getElementById('quickfixStep2');

      const isStep2Active = step2 && (step2.style.display !== 'none' && step2.classList.contains('active'));

      const currentScore = score || appState.quickfixOriginalScore || appState.proOriginalScore || 0;

      const isHellaSusOrKindaSus = currentScore >= 30;



      if (applyButton && appState.isProUser && isStep2Active && !isHellaSusOrKindaSus) {

        // Only hide for Clean cases in Pro Step 2

        applyButton.style.display = 'none';

        applyButton.style.setProperty('display', 'none', 'important');

        applyButton.style.visibility = 'hidden';

        applyButton.style.setProperty('visibility', 'hidden', 'important');

        applyButton.style.opacity = '0';

        applyButton.style.setProperty('opacity', '0', 'important');

        applyButton.style.height = '0';

        applyButton.style.setProperty('height', '0', 'important');

        applyButton.style.margin = '0';

        applyButton.style.setProperty('margin', '0', 'important');

        applyButton.style.padding = '0';

        applyButton.style.setProperty('padding', '0', 'important');

      } else if (applyButton && appState.isProUser && isStep2Active && isHellaSusOrKindaSus) {

        // Show button for Hella Sus and Kinda Sus in Pro Step 2

        applyButton.style.display = 'inline-block';

        applyButton.style.setProperty('display', 'inline-block', 'important');

        applyButton.style.visibility = 'visible';

        applyButton.style.setProperty('visibility', 'visible', 'important');

        applyButton.style.opacity = '1';

        applyButton.style.setProperty('opacity', '1', 'important');

        applyButton.style.height = 'auto';

        applyButton.style.margin = '';

        applyButton.style.padding = '';

      }

    }, 100);



    // Also hide immediately and add observer to keep it hidden (only for Clean cases)

    const hideProStep2Button = () => {

      const applyButton = document.getElementById('applySelectedFixes');

      const step2 = document.getElementById('quickfixStep2');

      const isStep2Active = step2 && (step2.style.display !== 'none' && step2.classList.contains('active'));

      const currentScore = appState.quickfixOriginalScore || appState.proOriginalScore || 0;

      const isHellaSusOrKindaSus = currentScore >= 30;



      if (applyButton && appState.isProUser && isStep2Active && !isHellaSusOrKindaSus) {

        // Only hide for Clean cases

        applyButton.style.display = 'none';

        applyButton.style.setProperty('display', 'none', 'important');

        applyButton.style.visibility = 'hidden';

        applyButton.style.setProperty('visibility', 'hidden', 'important');

        applyButton.style.opacity = '0';

        applyButton.style.setProperty('opacity', '0', 'important');

        applyButton.style.height = '0';

        applyButton.style.setProperty('height', '0', 'important');

        applyButton.style.margin = '0';

        applyButton.style.setProperty('margin', '0', 'important');

        applyButton.style.padding = '0';

        applyButton.style.setProperty('padding', '0', 'important');

      }

    };



    // Hide immediately

    hideProStep2Button();



    // Hide after a short delay

    setTimeout(() => {

      hideProStep2Button();

    }, 100);



    // Hide after displayQuickFixAnalysis runs

    setTimeout(() => {

      hideProStep2Button();

    }, 500);



    // Set up observer to keep it hidden ONLY for Clean cases in Pro Step 2 (score < 30)

    setTimeout(() => {

      const applyButton = document.getElementById('applySelectedFixes');

      const step2 = document.getElementById('quickfixStep2');

      const isStep2Visible = step2 && (step2.style.display !== 'none' && step2.classList.contains('active'));

      const currentScore = appState.quickfixOriginalScore || appState.proOriginalScore || 0;

      const isHellaSusOrKindaSus = currentScore >= 30;



      if (applyButton && appState.isProUser && isStep2Visible && !isHellaSusOrKindaSus) {

        // For Clean cases only (score < 30), keep the button fully hidden and off-screen

        applyButton.style.display = 'none';

        applyButton.style.setProperty('display', 'none', 'important');

        applyButton.style.visibility = 'hidden';

        applyButton.style.setProperty('visibility', 'hidden', 'important');

        applyButton.style.position = 'absolute';

        applyButton.style.setProperty('position', 'absolute', 'important');

        applyButton.style.left = '-9999px';

      }

    }, 100);



    // 5. Reset checkboxes and count to 0, then update labels

    setTimeout(() => {

      // Reset all checkboxes to unchecked

      document.querySelectorAll('.fix-option input[type="checkbox"]').forEach(checkbox => {

        checkbox.checked = false;

      });

      // Uncheck "Use Best Words" checkbox

      const selectAllCheckboxPro = document.getElementById('selectAllFixes');

      if (selectAllCheckboxPro) {

        selectAllCheckboxPro.checked = false;

      }

      // Update count to 0

      updateSelectedCount();



      // Hide instruction box for Pro users

      const instructionBox = document.getElementById('fixSelectionInstructionBox');

      if (instructionBox) {

        instructionBox.style.display = 'none';

      }

      updateStepLabels(true);



      // Only show button group if there are flags to fix (not for clean results)

      const buttonGroup = document.getElementById('quickfixButtonGroup');

      const applyButton = document.getElementById('applySelectedFixes');

      const flagCount = flags && flags.length > 0 ? flags.length : 0;

      const isCleanResult = flagCount === 0 && score < 30;



      if (isCleanResult) {

        // Show button group for clean results (keep apply hidden)

        if (buttonGroup) {

          buttonGroup.style.display = 'flex';

          buttonGroup.style.setProperty('display', 'flex', 'important');

        }

        if (applyButton) {

          applyButton.style.display = 'none';

          applyButton.style.setProperty('display', 'none', 'important');

        }

      } else {

        // Show button group only if there are flags to fix

        if (buttonGroup) {

          buttonGroup.style.display = 'flex';

          buttonGroup.style.setProperty('display', 'flex', 'important');

        }

        if (applyButton) {

          // Hide Apply Pro Fixes button for Pro Step 2 ONLY for Clean cases (score < 30)

          // Show both buttons for Hella Sus and Kinda Sus (score >= 30)

          const currentScore = score || appState.quickfixOriginalScore || appState.proOriginalScore || 0;

          const isHellaSusOrKindaSus = currentScore >= 30;

          const isPro = appState.isProUser || false;

          const step2 = document.getElementById('quickfixStep2');

          const stepNumber = step2 && step2.classList.contains('active') ? 2 : 3;



          if (isPro && stepNumber === 2) {

            if (!isHellaSusOrKindaSus) {

              // Only hide for Clean cases (score < 30)

              applyButton.style.display = 'none';

              applyButton.style.setProperty('display', 'none', 'important');

              applyButton.style.visibility = 'hidden';

              applyButton.style.setProperty('visibility', 'hidden', 'important');

              applyButton.style.opacity = '0';

              applyButton.style.setProperty('opacity', '0', 'important');

              applyButton.style.height = '0';

              applyButton.style.setProperty('height', '0', 'important');

              applyButton.style.margin = '0';

              applyButton.style.setProperty('margin', '0', 'important');

              applyButton.style.padding = '0';

              applyButton.style.setProperty('padding', '0', 'important');

            } else {

              // CRITICAL: For Hella Sus/Kinda Sus (score >= 30), ensure button is VISIBLE and BLUE

              applyButton.style.display = 'inline-block';

              applyButton.style.setProperty('display', 'inline-block', 'important');

              applyButton.style.visibility = 'visible';

              applyButton.style.setProperty('visibility', 'visible', 'important');

              applyButton.style.opacity = '1';

              applyButton.style.setProperty('opacity', '1', 'important');

              applyButton.style.height = 'auto';

              applyButton.style.margin = '';

              applyButton.style.padding = '';

              // Ensure it's blue for Pro users

              applyButton.style.setProperty('background', '#00a8e8', 'important');

              applyButton.style.setProperty('color', 'white', 'important');

              // Update text to "Pro (Selected Words Only (X))"

              const selectedCountEl = applyButton.querySelector('#selectedCount');

              const currentCount = selectedCountEl ? selectedCountEl.textContent : '0';

              applyButton.innerHTML = `Pro (Selected Words Only (<span id="selectedCount">${currentCount}</span>))`;

              console.log('âœ… Blue CTA shown for Pro Step 2 Hella Sus/Kinda Sus, count:', currentCount);

            }

          } else {

            // Show button for other steps (non-Pro or Step 3)

            applyButton.style.display = 'block';

            applyButton.style.setProperty('display', 'block', 'important');

            applyButton.style.visibility = 'visible';

            applyButton.style.opacity = '1';

            applyButton.style.height = 'auto';

            applyButton.style.margin = '';

            applyButton.style.padding = '';

          }

        }

      }



      // FORCE hide upsell for Pro users after content renders

      const proUpsellBox = document.getElementById('quickfixProUpsellBox');

      const newProBanner = document.getElementById('quickfixProBanner');

      if (appState.isProUser) {

        if (proUpsellBox) {

          proUpsellBox.style.display = 'none';

          proUpsellBox.style.setProperty('display', 'none', 'important');

        }

        if (newProBanner) {

          newProBanner.style.display = 'none';

          newProBanner.style.setProperty('display', 'none', 'important');

        }

      }



      // Scroll to top after content loads

      window.scrollTo({ top: 0, behavior: 'smooth' });

    }, 100);

}



// ==================== PRO FLOW FUNCTIONS ====================



// Function to swap labels between QuickFix and Pro modes

function updateStepLabels(isPro) {

  // Check appState.isProUser as fallback if isPro not explicitly passed

  if (isPro === undefined) {

    isPro = appState.isProUser || false;

  }



  const steps = [2, 3, 4];

  const replacements = [

    { quickfix: 'QuickFix', pro: 'Pro' },

    { quickfix: 'quickfix', pro: 'Pro' },

    { quickfix: 'Quick Fix', pro: 'Pro' },

    { quickfix: 'Quick Fixâ„¢', pro: 'Pro' }

  ];



  steps.forEach(stepNum => {

    const stepElement = document.getElementById('quickfixStep' + stepNum);

    if (!stepElement) return;



    // Update all text content in the step

    const walker = document.createTreeWalker(

      stepElement,

      NodeFilter.SHOW_TEXT,

      null,

      false

    );



    const textNodes = [];

    let node;

    while (node = walker.nextNode()) {

      if (node.textContent.trim()) {

        textNodes.push(node);

      }

    }



    textNodes.forEach(textNode => {

      // Skip text nodes inside Pro upsell banners - they must always say "Go Pro & Chill" (never "Go QuickFix & Chill")

      const proBanner = document.getElementById('quickfixProBanner');

      const proBannerText = document.getElementById('quickfixProBannerText');

      const proUpsellBox = document.getElementById('quickfixProUpsellBox');

      const step2GoProBanner = document.getElementById('quickfixStep2GoProBanner');

      const step3ProBanner = document.getElementById('quickfixStep3ProBanner');

      if ((proBanner && proBanner.contains(textNode)) || (proBannerText && proBannerText.contains(textNode)) || (proUpsellBox && proUpsellBox.contains(textNode)) || (step2GoProBanner && step2GoProBanner.contains(textNode)) || (step3ProBanner && step3ProBanner.contains(textNode))) {

        return; // Skip - don't replace text in Pro upsell banners

      }



      let text = textNode.textContent;

      if (isPro) {

        // Change QuickFix to Pro

        replacements.forEach(repl => {

          text = text.replace(new RegExp(repl.quickfix, 'gi'), repl.pro);

        });

      } else {

        // Change Pro back to QuickFix (only if it was originally QuickFix)

        // This is a simplified version - in practice, you might want to store original text

        replacements.forEach(repl => {

          text = text.replace(new RegExp('\\b' + repl.pro + '\\b', 'gi'), repl.quickfix);

        });

      }

      textNode.textContent = text;

    });



    // Also update element attributes and titles

    stepElement.querySelectorAll('[title*="QuickFix"], [title*="quickfix"], [title*="Pro"]').forEach(el => {

      if (isPro) {

        el.title = el.title.replace(/QuickFix/gi, 'Pro').replace(/quickfix/gi, 'Pro');

      } else {

        el.title = el.title.replace(/\bPro\b/gi, 'QuickFix');

      }

    });

  });



  // MAIN HEADER: Update "False Flag Fixer - QuickFix" â†’ "False Flag Fixer - Pro" and change emoji

  const mainHeaderTitle = document.getElementById('mainHeaderTitle');

  if (mainHeaderTitle) {

    if (isPro) {

      // Change QuickFix to Pro and lightning emoji to diamond emoji

      let headerText = mainHeaderTitle.innerHTML;

      headerText = headerText.replace(/QuickFix/gi, 'Pro');

      headerText = headerText.replace(/quickfix/gi, 'Pro');

      // Replace lightning emoji with diamond emoji and remove yellow glow, add white outline

      headerText = headerText.replace(/âš¡/g, 'ðŸ’Ž');

      mainHeaderTitle.innerHTML = headerText;



      // Update the span element directly to remove yellow glow and add white outline

      setTimeout(() => {

        const span = mainHeaderTitle.querySelector('span');

        if (span && (span.textContent.includes('ðŸ’Ž') || span.innerHTML.includes('ðŸ’Ž'))) {

          span.style.color = 'white';

          span.style.textShadow = '0 0 4px white, 0 0 8px white, 0 0 12px white';

          span.style.filter = 'none';

          span.style.display = 'inline-block';

          span.style.fontWeight = 'bold';

        }

      }, 50);

    } else {

      // Change Pro back to QuickFix and diamond emoji back to lightning emoji

      let headerText = mainHeaderTitle.innerHTML;

      headerText = headerText.replace(/\bPro\b/gi, 'QuickFix');

      // Replace diamond emoji with lightning emoji

      headerText = headerText.replace(/ðŸ’Ž/g, 'âš¡');

      mainHeaderTitle.innerHTML = headerText;

      // Re-apply glowing white style to lightning emoji (innerHTML strips inline styles)

      const quickfixEmoji = document.getElementById('mainHeaderQuickFixEmoji');

      if (quickfixEmoji) {

        quickfixEmoji.style.cssText = 'color: #ffffff !important; display: inline-block; text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff, 0 0 30px #ffffff, 0 0 40px rgba(255, 255, 255, 0.5); filter: grayscale(100%) brightness(2) contrast(1.2) !important; font-weight: bold;';

        quickfixEmoji.textContent = 'âš¡';

      }

    }

  }



  // MAIN HEADER SUBTITLE: Update subtitle for Pro users

  const mainHeaderSubtitle = document.getElementById('mainHeaderSubtitle');

  if (mainHeaderSubtitle) {

    if (isPro) {

      mainHeaderSubtitle.innerHTML = '100 Scans A Month. No Daily Limit. Unlimited Peace of Mind.';

    } else {

      mainHeaderSubtitle.innerHTML = 'A Pro-level one-time, one price, full essay scan, full fix.';

    }

  }



  // STEP 2: Update "QuickFix found" â†’ "Pro found" heading

  const quickfixCountHeading = document.getElementById('quickfixCountHeading');

  if (quickfixCountHeading) {

    quickfixCountHeading.style.color = '#dc2626';

    if (isPro) {

      let headingText = quickfixCountHeading.innerHTML;

      headingText = headingText.replace(/QuickFix found/gi, 'Pro found');

      headingText = headingText.replace(/quickfix found/gi, 'Pro found');

      quickfixCountHeading.innerHTML = headingText;

    } else {

      let headingText = quickfixCountHeading.innerHTML;

      headingText = headingText.replace(/Pro found/gi, 'QuickFix found');

      quickfixCountHeading.innerHTML = headingText;

    }

  }



  // STEP 2 & 3: Style the "Apply Selected Fixes" button without changing its label

  // Button visibility (and exact text) is handled elsewhere based on score & mode.

  const applyButton = document.getElementById('applySelectedFixes');

  if (applyButton) {

    if (isPro) {

      // Pro: keep the QuickFix-style label but use Pro blue styling

      applyButton.style.setProperty('background', '#00a8e8', 'important');

      applyButton.style.setProperty('color', '#ffffff', 'important');

    } else {

      // QuickFix: restore the original orange styling

      applyButton.style.setProperty('background', '#ff6b00', 'important');

      applyButton.style.setProperty('color', '#ffffff', 'important');

    }

  }



  // Update "QuickFix All (Recommended)" â†’ "Pro All (Recommended)" button text

  const applyAllButton = document.getElementById('applyAllFixes');

  if (applyAllButton) {

    if (isPro) {

      // Change "QuickFix All" to "Pro All"

      let buttonText = applyAllButton.innerHTML;

      buttonText = buttonText.replace(/QuickFix All/gi, 'Pro All');

      applyAllButton.innerHTML = buttonText;

    } else {

      // Change "Pro All" back to "QuickFix All"

      let buttonText = applyAllButton.innerHTML;

      buttonText = buttonText.replace(/Pro All/gi, 'QuickFix All');

      applyAllButton.innerHTML = buttonText;

    }

  }



  // Update "QuickFix Selected Words Only" â†’ "Pro (Selected Words Only (X))" button text and color

  const applySelectedButton = document.getElementById('applySelectedFixes');

  if (applySelectedButton) {

    const selectedCountEl = applySelectedButton.querySelector('#selectedCount');

    const currentCount = selectedCountEl ? selectedCountEl.textContent : '0';



    if (isPro) {

      // Change to "Pro (Selected Words Only (X))" and make it blue

      applySelectedButton.innerHTML = `Pro (Selected Words Only (<span id="selectedCount">${currentCount}</span>))`;

      applySelectedButton.style.setProperty('background', '#00a8e8', 'important');

      applySelectedButton.style.setProperty('color', 'white', 'important');

    } else {

      // Change back to "QuickFix Selected Words Only (X)" and make it orange

      applySelectedButton.innerHTML = `QuickFix Selected Words Only (<span id="selectedCount">${currentCount}</span>)`;

      applySelectedButton.style.setProperty('background', '#ff6b00', 'important');

      applySelectedButton.style.setProperty('color', 'white', 'important');

    }

  }



  // STEP 4: Update Pro-themed header (if Step 4 exists)

  if (isPro) {

    const step4Header = document.getElementById('rotatingMessage');

    if (step4Header) {

      // Keep Pro-themed premium header

      step4Header.textContent = 'ðŸ’Ž Premium Results - Every Flag Found & Fixed âœ¨';

    }

    const step4HeroText = document.getElementById('step4HeroText');

    if (step4HeroText) {

      step4HeroText.innerHTML = step4HeroText.innerHTML.replace(/QuickFix found/gi, 'Pro found');

    }

    const step4ProText = document.getElementById('step4ProText');

    if (step4ProText) {

      step4ProText.textContent = step4ProText.textContent.replace(/QuickFix found/gi, 'Pro found');

    }

  }



  // Always keep Pro banner text as "Pro" (not "QuickFix") - this is a Pro upsell banner

  // BUT: For Clean No Sus QuickFix Step 2, keep the "Go Pro and Chill..." version (don't change it)

  const proBanner = document.getElementById('quickfixProBanner');

  if (proBanner) {

    const proBenefitsText = document.getElementById('proBenefitsText');

    // Check if this is the Clean No Sus Step 2 version with "Go Pro and Chill..."

    const isCleanNoSusVersion = proBenefitsText && proBenefitsText.textContent.includes('Go Pro and Chill');



    if (!isCleanNoSusVersion) {

      // Only update button and heading if it's NOT the Clean No Sus version

    const bannerButton = proBanner.querySelector('button');

    if (bannerButton && bannerButton.textContent.includes('QuickFix')) {

      bannerButton.textContent = 'ðŸ’Ž Go Pro - $9.99/mo';

    }

    if (proBenefitsText && proBenefitsText.textContent.includes('QuickFix')) {

      proBenefitsText.textContent = 'ðŸš¨ Don\'t Risk It. Fix It.';

      proBenefitsText.style.fontSize = '22px';

      proBenefitsText.style.fontWeight = '800';

    }

    }

    // If it IS the Clean No Sus version, leave it completely alone - don't change anything

  }



  // Show/hide appropriate back buttons

  const step2BackToDashboard = document.getElementById('step2BackToDashboard');

  const step2BackToProDashboard = document.getElementById('step2BackToProDashboard');

  const step3BackToDashboard = document.getElementById('step3BackToDashboard');

  const step3BackToProDashboard = document.getElementById('step3BackToProDashboard');

  const step3ViewPastFixes = document.getElementById('step3ViewPastFixes');

  const step3EditFixes = document.getElementById('step3EditFixes');

  const step4BackToDashboard = document.getElementById('step4BackToDashboard');

  const step4BackToProDashboard = document.getElementById('step4BackToProDashboard');



  if (isPro) {

    // Show Pro dashboard buttons, hide regular dashboard buttons

    if (step2BackToDashboard) step2BackToDashboard.style.display = 'none';

    if (step2BackToProDashboard) step2BackToProDashboard.style.display = 'block';

    // Show trusted section on Pro Step 2 EXCEPT Pro Low Sus (score < 30) - it's shown in place of Copy CTA there

    const step2TrustedSection = document.getElementById('step2TrustedSection');

    const proScore = appState.quickfixOriginalScore ?? appState.proOriginalScore ?? 99;

    if (step2TrustedSection) {

      if (proScore < 30) {

        step2TrustedSection.style.display = 'none';

        step2TrustedSection.style.setProperty('display', 'none', 'important');

      } else {

        step2TrustedSection.style.display = 'block';

      }

    }

    // For Step 3: Show all four buttons in order: 1. Paste & Scan, 2. Try Different Words, 3. View Past Fixes, 4. Back to Main Dashboard

    if (step3BackToProDashboard) {

      step3BackToProDashboard.style.display = 'block';

      step3BackToProDashboard.style.setProperty('display', 'block', 'important');

    }

    // Step 3 "Try Different Words": show for Pro EXCEPT on Clean No Sus Pro Step 3 (user requested removal there)

    const quickfixStep3CleanNoSusCTA = document.getElementById('quickfixStep3CleanNoSusCTA');

    const quickfixStep3YoureGoodCard = document.getElementById('quickfixStep3YoureGoodCard');

    const isCleanNoSusStep3 = (quickfixStep3CleanNoSusCTA && quickfixStep3CleanNoSusCTA.style.display === 'block') ||

      (quickfixStep3YoureGoodCard && quickfixStep3YoureGoodCard.style.display === 'block');

    if (step3EditFixes) {

      if (isCleanNoSusStep3) {

        step3EditFixes.style.display = 'none';

        step3EditFixes.style.setProperty('display', 'none', 'important');

        step3EditFixes.style.visibility = 'hidden';

        step3EditFixes.style.setProperty('visibility', 'hidden', 'important');

      } else {

        step3EditFixes.style.display = 'block';

        step3EditFixes.style.setProperty('display', 'block', 'important');

      }

    }

    if (step3ViewPastFixes) {

      step3ViewPastFixes.style.display = 'block';

      step3ViewPastFixes.style.setProperty('display', 'block', 'important');

      console.log('ðŸ“Š View Past Fixes button shown for Pro user');

    }

    // Show "Back to Main Dashboard" button for Pro users (last in order)

    const step3BackToMainDashboard = document.getElementById('step3BackToMainDashboardButton');

    if (step3BackToMainDashboard) {

      step3BackToMainDashboard.style.display = 'block';

      step3BackToMainDashboard.style.setProperty('display', 'block', 'important');

    }

    // Hide orange QuickFix upsell button in Pro Step 3 ONLY

    const quickFixUpsellBtn = document.getElementById('step3QuickFixUpsellButton');

    if (quickFixUpsellBtn) {

      quickFixUpsellBtn.style.display = 'none';

      quickFixUpsellBtn.style.setProperty('display', 'none', 'important');

      quickFixUpsellBtn.style.visibility = 'hidden';

      quickFixUpsellBtn.style.setProperty('visibility', 'hidden', 'important');

    }

    if (step4BackToDashboard) step4BackToDashboard.style.display = 'none';

    if (step4BackToProDashboard) step4BackToProDashboard.style.display = 'block';

  } else {

    // Show regular dashboard buttons, hide Pro dashboard buttons

    if (step2BackToDashboard) step2BackToDashboard.style.display = 'block';

    if (step2BackToProDashboard) step2BackToProDashboard.style.display = 'none';

    // Hide trusted section on free version

    const step2TrustedSection = document.getElementById('step2TrustedSection');

    if (step2TrustedSection) step2TrustedSection.style.display = 'none';

    if (step3BackToDashboard) step3BackToDashboard.style.display = 'block';

    if (step3BackToProDashboard) step3BackToProDashboard.style.display = 'none';

    if (step3ViewPastFixes) step3ViewPastFixes.style.display = 'none';

    if (step3EditFixes) step3EditFixes.style.display = 'none';

    if (step4BackToDashboard) step4BackToDashboard.style.display = 'block';

    if (step4BackToProDashboard) step4BackToProDashboard.style.display = 'none';

    // QuickFix Step 3: show Back to Main Dashboard

    const step3BackToMainDashboardBtn = document.getElementById('step3BackToMainDashboardButton');

    if (step3BackToMainDashboardBtn) {

      step3BackToMainDashboardBtn.style.display = 'block';

      step3BackToMainDashboardBtn.style.setProperty('display', 'block', 'important');

    }

  }

}



function showProStep(stepNumber) {

  console.log('showProStep called with:', stepNumber);



  // Hide Pro Dashboard (Step 6)

  const step6 = document.getElementById('quickfixStep6');

  if (step6) {

    step6.style.setProperty('display', 'none', 'important');

    step6.classList.remove('active');

  }



  // Hide input section

  const inputSection = document.getElementById('inputSection');

  if (inputSection) {

    inputSection.style.setProperty('display', 'none', 'important');

  }



  // For steps 2, 3, 4: Show quickfixFlow (they're inside it) but hide step 1

  if (stepNumber === 2 || stepNumber === 3 || stepNumber === 4) {

    const quickfixFlow = document.getElementById('quickfixFlow');

    if (quickfixFlow) {

      quickfixFlow.style.setProperty('display', 'block', 'important');

    }



    // Hide step 1

    const quickfixStep1 = document.getElementById('quickfixStep1');

    if (quickfixStep1) {

      quickfixStep1.style.setProperty('display', 'none', 'important');

      quickfixStep1.classList.remove('active');

    }

  } else {

    // For other steps, hide quickfixFlow

    const quickfixFlow = document.getElementById('quickfixFlow');

    if (quickfixFlow) {

      quickfixFlow.style.setProperty('display', 'none', 'important');

    }

  }



  // Hide all other steps

  document.querySelectorAll('.quickfix-step').forEach(step => {

    if (step.id !== 'quickfixStep' + stepNumber && step.id !== 'quickfixStep6') {

      step.style.display = 'none';

      step.classList.remove('active');

    }

  });



  const stepElement = document.getElementById('quickfixStep' + stepNumber);

  if (stepElement) {

    // Remove any inline display:none

    let currentStyle = stepElement.getAttribute('style') || '';

    currentStyle = currentStyle.replace(/display\s*:\s*none\s*;?/gi, '');

    if (currentStyle.trim()) {

      stepElement.setAttribute('style', currentStyle);

    }



    // Force show the step

    stepElement.style.setProperty('display', 'block', 'important');

    stepElement.style.setProperty('opacity', '1', 'important');

    stepElement.style.setProperty('visibility', 'visible', 'important');

    stepElement.classList.add('active');



    // Orange "Get Another QuickFix" CTA: show ONLY on Hella Sus or Kinda Sus (score >= 30). Hide for Pro, Free, and QuickFix Clean.

    if (stepNumber === 3) {

      const upsellBtn = document.getElementById('step3QuickFixUpsellButton');

      if (upsellBtn) {

        const score = appState.quickfixNewScore;

        const isKindaOrHellaSus = (typeof score === 'number' && score >= 30);

        if (appState.isProUser || !isKindaOrHellaSus) {

          upsellBtn.style.display = 'none';

          upsellBtn.style.setProperty('display', 'none', 'important');

          upsellBtn.style.visibility = 'hidden';

          upsellBtn.style.setProperty('visibility', 'hidden', 'important');

        } else {

          upsellBtn.style.display = 'flex';

          upsellBtn.style.setProperty('display', 'flex', 'important');

          upsellBtn.style.visibility = 'visible';

          upsellBtn.style.removeProperty('visibility');

        }

      }

      const backBtn = document.getElementById('step3BackToMainDashboardButton');

      if (backBtn) {

        backBtn.style.marginTop = '0';

      }

      // CRITICAL: Ensure all Pro CTAs are visible when showing Pro Step 3

      // This ensures CTAs are shown even when returning from "Paste & Scan Another Essay"

      if (appState.isProUser) {

        setTimeout(() => {

          updateStepLabels(true);

          // Force show all Pro Step 3 CTAs

          const step3BackToProDashboard = document.getElementById('step3BackToProDashboard');

          const step3ViewPastFixes = document.getElementById('step3ViewPastFixes');

          const step3EditFixes = document.getElementById('step3EditFixes');

          if (step3BackToProDashboard) {

            step3BackToProDashboard.style.display = 'block';

            step3BackToProDashboard.style.setProperty('display', 'block', 'important');

          }

          if (step3ViewPastFixes) {

            step3ViewPastFixes.style.display = 'block';

            step3ViewPastFixes.style.setProperty('display', 'block', 'important');

          }

          // Try Different Words: hide on Clean No Sus Pro Step 3

          const quickfixStep3CleanNoSusCTA = document.getElementById('quickfixStep3CleanNoSusCTA');

          const quickfixStep3YoureGoodCard = document.getElementById('quickfixStep3YoureGoodCard');

          const isCleanNoSusStep3 = (quickfixStep3CleanNoSusCTA && quickfixStep3CleanNoSusCTA.style.display === 'block') ||

            (quickfixStep3YoureGoodCard && quickfixStep3YoureGoodCard.style.display === 'block');

          if (step3EditFixes) {

            if (isCleanNoSusStep3) {

              step3EditFixes.style.display = 'none';

              step3EditFixes.style.setProperty('display', 'none', 'important');

            } else {

              step3EditFixes.style.display = 'block';

              step3EditFixes.style.setProperty('display', 'block', 'important');

            }

          }

          console.log('âœ… Pro Step 3 CTAs forced visible');

        }, 100);

      }

    }



    // Ensure proper styling for steps 2, 3, 4

    if (stepNumber === 2 || stepNumber === 3 || stepNumber === 4) {

      stepElement.style.setProperty('padding', '60px 20px 40px 20px', 'important');

      stepElement.style.setProperty('background', '#ffffff', 'important');

      stepElement.style.setProperty('min-height', '100vh', 'important');

    }



    console.log('Pro Step ' + stepNumber + ' displayed');

    console.log('Step element computed display:', window.getComputedStyle(stepElement).display);



    // Button visibility for Pro Step 2 is handled by displayQuickFixAnalysis and displayProAnalysis

    // based on score (show for Hella Sus/Kinda Sus >= 30, hide for Clean < 30)

    // No need to hide it here unconditionally



    // Scroll to top to show the step

    setTimeout(() => {

      stepElement.scrollIntoView({ behavior: 'smooth', block: 'start' });

    }, 100);

  } else {

    console.error('Pro Step element not found for step:', stepNumber);

  }

}



function hideProFlow() {

  // Hide QuickFix steps 2, 3, 4 (which are reused for Pro)

  // Reset labels back to QuickFix mode

  updateStepLabels(false);



  document.querySelectorAll('.quickfix-step').forEach(step => {

    if (step.id === 'quickfixStep2' || step.id === 'quickfixStep3' || step.id === 'quickfixStep4') {

      step.style.display = 'none';

      step.classList.remove('active');

    }

  });



  // Show Pro Dashboard

  showProDashboard();

}



// Function to go back to Pro Dashboard from any Pro step

function backToProDashboard() {

  // Reset labels back to QuickFix mode first

  updateStepLabels(false);



  // Hide all QuickFix steps

  document.querySelectorAll('.quickfix-step').forEach(step => {

    if (step.id === 'quickfixStep2' || step.id === 'quickfixStep3' || step.id === 'quickfixStep4') {

      step.style.display = 'none';

      step.classList.remove('active');

    }

  });



  // CRITICAL: Show Pro dashboard and handle Pro user CTAs

  showProDashboard();

  // handleProUserCTAs will be called by switchToInput which is called by showProDashboard



  // Hide quickfixFlow (which contains steps 2, 3, 4)

  const quickfixFlow = document.getElementById('quickfixFlow');

  if (quickfixFlow) {

    quickfixFlow.style.setProperty('display', 'none', 'important');

  }



  // Clear Pro scan input for "Paste & Scan Another Essay"

  const proScanInput = document.getElementById('proScanInput');

  if (proScanInput) {

    proScanInput.value = '';

    // Update character count

    const proCharCount = document.getElementById('proCharCount');

    if (proCharCount) {

      proCharCount.textContent = '0 / 1,500';

    }

    // Update button state

    if (typeof updateProScanButtonState === 'function') {

      updateProScanButtonState();

    }

  }



  // CRITICAL: Clear main essay input when returning to dashboard

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    essayInput.value = '';

    updateCounter();

  }



  // Show Pro Dashboard (which will set Pro mode again)

  showProDashboard();



  // Scroll to top

  window.scrollTo({ top: 0, behavior: 'smooth' });

}



// Make globally accessible

window.backToProDashboard = backToProDashboard;



function returnToProDashboardWithEssay() {

  // Hide all Pro steps

  hideProFlow();



  // Auto-populate the textarea with the fixed essay

  const proScanInput = document.getElementById('proScanInput');

  if (proScanInput && appState.proFixedText) {

    proScanInput.value = appState.proFixedText;

    // Trigger input event to update character count

    const inputEvent = new Event('input', { bubbles: true });

    proScanInput.dispatchEvent(inputEvent);

  }

}



function returnToMainDashboard() {

  // Hide all Pro sections

  const quickfixStep6 = document.getElementById('quickfixStep6');

  if (quickfixStep6) {

    quickfixStep6.style.display = 'none';

    quickfixStep6.classList.remove('active');

  }



  // Hide Pro steps (which reuse QuickFix steps 2, 3, 4)

  // Reset labels back to QuickFix mode

  updateStepLabels(false);



  document.querySelectorAll('.quickfix-step').forEach(step => {

    if (step.id === 'quickfixStep2' || step.id === 'quickfixStep3' || step.id === 'quickfixStep4') {

      step.style.display = 'none';

      step.classList.remove('active');

    }

  });



  // Show main input section

  const inputSection = document.getElementById('inputSection');

  if (inputSection) {

    inputSection.style.display = 'block';

  }



  // CRITICAL: Clear essay input completely when returning to main dashboard

  const essayInput = document.getElementById('essayInput');

  if (essayInput) {

    essayInput.value = '';

    updateCounter();

  }



  // CRITICAL: Handle Pro user CTAs when returning to main dashboard

  handleProUserCTAs();



  // Update test mode toggle

  if (typeof updateTestModeToggle === 'function') {

    updateTestModeToggle();

  }



  // Hide other sections

  const quickfixFlow = document.getElementById('quickfixFlow');

  if (quickfixFlow) quickfixFlow.style.display = 'none';



  const resultsContainer = document.getElementById('resultsContainer');

  if (resultsContainer) resultsContainer.style.display = 'none';



  const managePage = document.getElementById('manageSubscriptionPage');

  if (managePage) managePage.style.display = 'none';

}





// Pro Step 9 helper functions





function showProScanHistory() {

  console.log('ðŸ”„ showProScanHistory() called');

  showSuccessMessage('Scan history coming soon!');

}



// ==================== STRIPE PAYMENT FUNCTIONS ====================



function initializeStripe() {

  // Load Stripe.js library

  if (typeof Stripe === 'undefined') {

    const script = document.createElement('script');

    script.src = 'https://js.stripe.com/v3/';

    script.onload = function() {

      setupStripe();

    };

    document.head.appendChild(script);

  } else {

    setupStripe();

  }

}



function setupStripe() {

  // TODO: Replace with your actual Stripe publishable key

  const stripeKey = 'pk_test_YOUR_STRIPE_KEY_HERE';



  if (!stripeKey || stripeKey.includes('YOUR_STRIPE_KEY')) {

    console.warn('Stripe key not configured. Payment will not work until key is set.');

    // Set a flag so we know Stripe isn't configured

    appState.stripeConfigured = false;

    return;

  }



  appState.stripe = Stripe(stripeKey);

  appState.stripeConfigured = true;



  // Setup card element for payment modal

  const elements = appState.stripe.elements();

  appState.stripeCardElement = elements.create('card', {

    style: {

      base: {

        fontSize: '16px',

        color: '#0b0646',

        '::placeholder': {

          color: '#9ca3af',

        },

      },

    },

  });



  // Setup card element for update payment modal

  appState.stripeUpdateCardElement = elements.create('card', {

    style: {

      base: {

        fontSize: '16px',

        color: '#0b0646',

        '::placeholder': {

          color: '#9ca3af',

        },

      },

    },

  });

}



function showStripePaymentModal() {

  const modal = document.getElementById('stripePaymentModal');

  if (!modal) return;



  // TEST MODE: Only allow on localhost/dev environments

  const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.hostname === '';



  // TEST MODE: Check if Stripe is configured

  if (!appState.stripe) {

    initializeStripe();

    // Give it a moment to initialize

    setTimeout(() => {

      // If Stripe still not configured or setupStripe returned early (key is placeholder)

      if (!appState.stripe || appState.stripeConfigured === false) {

        // Stripe not configured - only activate test mode on localhost

        if (isLocalhost) {

          console.log('ðŸ§ª TEST MODE: Stripe not configured. Activating Pro mode for testing (localhost only)...');

          activateProTestMode();

        } else {

          console.error('âŒ Stripe is not configured. Please configure Stripe keys for production.');

          showSuccessMessage('Payment system is not configured. Please contact support.', '#dc2626');

        }

        return;

      } else {

        // Stripe initialized, show payment modal

        showStripePaymentModal();

      }

    }, 100);

    return;

  }



  // If we already checked and Stripe isn't configured, only activate test mode on localhost

  if (appState.stripeConfigured === false) {

    if (isLocalhost) {

      console.log('ðŸ§ª TEST MODE: Stripe not configured. Activating Pro mode for testing (localhost only)...');

      activateProTestMode();

    } else {

      console.error('âŒ Stripe is not configured. Please configure Stripe keys for production.');

      showSuccessMessage('Payment system is not configured. Please contact support.', '#dc2626');

    }

    return;

  }



  modal.style.display = 'flex';

  document.body.classList.add('modal-open');



  // Mount Stripe card element

  if (appState.stripeCardElement && document.getElementById('stripeCardElement')) {

    // Unmount first if already mounted

    try {

      appState.stripeCardElement.unmount();

    } catch(e) {}

    appState.stripeCardElement.mount('#stripeCardElement');

  }



  // Setup form submission

  const form = document.getElementById('stripePaymentForm');

  if (form) {

    // Remove old listeners

    const newForm = form.cloneNode(true);

    form.parentNode.replaceChild(newForm, form);

    document.getElementById('stripePaymentForm').addEventListener('submit', handleStripePayment);

  }



  // Close on outside click

  modal.addEventListener('click', function(e) {

    if (e.target === modal) {

      closeStripePaymentModal();

    }

  });

}



function closeStripePaymentModal() {

  const modal = document.getElementById('stripePaymentModal');

  if (modal) {

    modal.style.display = 'none';

    document.body.classList.remove('modal-open');



    if (appState.stripeCardElement) {

      appState.stripeCardElement.unmount();

    }

  }

}

async function handleStripePayment(event) {

  event.preventDefault();



  const submitBtn = document.getElementById('stripeSubmitBtn');

  const errorDiv = document.getElementById('stripeCardErrors');



  if (submitBtn) {

    submitBtn.disabled = true;

    submitBtn.textContent = 'Processing...';

  }



  // TODO: Replace with your backend endpoint that creates a PaymentIntent or Subscription

  // This should call your backend API which then creates the Stripe subscription

  try {

    // Mock payment for now - replace with actual API call

    // const response = await fetch('/api/create-subscription', {

    //   method: 'POST',

    //   headers: { 'Content-Type': 'application/json' },

    //   body: JSON.stringify({})

    // });



    // For now, simulate successful payment

    setTimeout(() => {

      // Activate Pro subscription

      appState.isProUser = true;

      appState.proSubscription.active = true;

      appState.maxChars = 5000;



      // Calculate next billing date (30 days from now)

      const nextBilling = new Date();

      nextBilling.setDate(nextBilling.getDate() + 30);

      appState.proSubscription.nextBillingDate = nextBilling;



      // Close modal and redirect to Pro Dashboard

      closeStripePaymentModal();

      showSuccessMessage('Welcome to Pro! ðŸŽ‰');

      showProDashboard();

    }, 1500);



  } catch (error) {

    console.error('Payment error:', error);

    if (errorDiv) {

      errorDiv.textContent = error.message || 'Payment failed. Please try again.';

    }

    if (submitBtn) {

      submitBtn.disabled = false;

      submitBtn.textContent = 'Subscribe for $9.99/month';

    }

  }

}



// ==================== MANAGE SUBSCRIPTION FUNCTIONS ====================



window.showManageSubscription = function showManageSubscription() {

  console.log('ðŸ”„ showManageSubscription() called');



  // Hide ALL other sections with !important to override any previous !important rules

  const step6 = document.getElementById('quickfixStep6');

  if (step6) {

    step6.style.setProperty('display', 'none', 'important');

    step6.style.setProperty('opacity', '0', 'important');

    step6.style.setProperty('visibility', 'hidden', 'important');

    step6.classList.remove('active');

    console.log('âœ… Step 6 (Pro Dashboard) hidden');

  }

  const inputSection = document.getElementById('inputSection');

  if (inputSection) {

    inputSection.style.setProperty('display', 'none', 'important');

  }

  const quickfixFlow = document.getElementById('quickfixFlow');

  if (quickfixFlow) {

    quickfixFlow.style.setProperty('display', 'none', 'important');

  }

  const resultsContainer = document.getElementById('resultsContainer');

  if (resultsContainer) {

    resultsContainer.style.setProperty('display', 'none', 'important');

    resultsContainer.classList.remove('show');

  }



  // Show manage subscription page with !important

  const managePage = document.getElementById('manageSubscriptionPage');

  if (managePage) {

    managePage.style.setProperty('display', 'block', 'important');

    managePage.style.setProperty('opacity', '1', 'important');

    managePage.style.setProperty('visibility', 'visible', 'important');

    updateManageSubscriptionPage();

    // Scroll to top

    window.scrollTo({ top: 0, behavior: 'smooth' });

    console.log('âœ… Manage subscription page shown');

  } else {

    console.error('âŒ Manage subscription page element not found!');

  }

}



window.hideManageSubscription = function hideManageSubscription() {

  document.getElementById('manageSubscriptionPage').style.display = 'none';

  if (appState.isProUser) {

    showProDashboard();

  } else {

    document.getElementById('inputSection').style.display = 'block';

  }

}



function updateManageSubscriptionPage() {

  if (!appState.proSubscription.active) return;



  // Update subscription info

  const nextBilling = appState.proSubscription.nextBillingDate || new Date();

  document.getElementById('subNextBilling').textContent = nextBilling.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });



  // Update usage

  const scansUsed = appState.proSubscription.scansUsed || 0;

  const scansLimit = appState.proSubscription.scansLimit || 500;

  document.getElementById('subScansUsed').textContent = `${scansUsed}/${scansLimit}`;



  const usagePercent = (scansUsed / scansLimit) * 100;

  const usageBar = document.getElementById('subUsageBar');

  if (usageBar) {

    usageBar.style.width = Math.min(100, usagePercent) + '%';

  }



  // Update reset date (first of next month)

  const resetDate = new Date();

  resetDate.setMonth(resetDate.getMonth() + 1, 1);

  document.getElementById('subResetDate').textContent = resetDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

}



function showUpdatePaymentModal() {

  const modal = document.getElementById('updatePaymentModal');

  if (!modal) return;



  if (!appState.stripe) {

    initializeStripe();

    setTimeout(() => showUpdatePaymentModal(), 500);

    return;

  }



  modal.style.display = 'flex';

  document.body.classList.add('modal-open');



  if (appState.stripeUpdateCardElement && document.getElementById('updateCardElement')) {

    // Unmount first if already mounted

    try {

      appState.stripeUpdateCardElement.unmount();

    } catch(e) {}

    appState.stripeUpdateCardElement.mount('#updateCardElement');

  }



  const form = document.getElementById('updatePaymentForm');

  if (form) {

    // Remove old listeners

    const newForm = form.cloneNode(true);

    form.parentNode.replaceChild(newForm, form);

    document.getElementById('updatePaymentForm').addEventListener('submit', handleUpdatePayment);

  }



  // Close on outside click

  modal.addEventListener('click', function(e) {

    if (e.target === modal) {

      closeUpdatePaymentModal();

    }

  });

}



function closeUpdatePaymentModal() {

  const modal = document.getElementById('updatePaymentModal');

  if (modal) {

    modal.style.display = 'none';

    document.body.classList.remove('modal-open');



    if (appState.stripeUpdateCardElement) {

      appState.stripeUpdateCardElement.unmount();

    }

  }

}



async function handleUpdatePayment(event) {

  event.preventDefault();



  // TODO: Replace with actual backend API call to update payment method

  showSuccessMessage('Payment method updated!');

  closeUpdatePaymentModal();

}



function showCancelSubscriptionModal() {

  const modal = document.getElementById('cancelSubscriptionModal');

  if (!modal) return;



  const nextBilling = appState.proSubscription.nextBillingDate || new Date();

  document.getElementById('cancelEndDate').textContent = nextBilling.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });



  modal.style.display = 'flex';

  document.body.classList.add('modal-open');



  // Close on outside click

  modal.addEventListener('click', function(e) {

    if (e.target === modal) {

      closeCancelSubscriptionModal();

    }

  });

}



function closeCancelSubscriptionModal() {

  const modal = document.getElementById('cancelSubscriptionModal');

  if (modal) {

    modal.style.display = 'none';

    document.body.classList.remove('modal-open');

  }

}



async function confirmCancelSubscription() {

  // TODO: Replace with actual backend API call to cancel subscription

  appState.proSubscription.active = false;

  appState.isProUser = false;

  appState.maxChars = 500;



  closeCancelSubscriptionModal();

  showSuccessMessage('Subscription cancelled. Access continues until billing period ends.');

  hideManageSubscription();

}



// ==================== TESTING: ACTIVATE PRO MODE ====================

// For testing purposes - activates Pro subscription without payment

// Call this from browser console: activateProTestMode()

function activateProTestMode() {

  appState.isProUser = true;

  appState.proSubscription.active = true;

  appState.maxChars = 5000;



  // Set next billing date (30 days from now)

  const nextBilling = new Date();

  nextBilling.setDate(nextBilling.getDate() + 30);

  appState.proSubscription.nextBillingDate = nextBilling;



  // Set some usage

  appState.proSubscription.scansUsed = 5; // 5/100 scans used



  showSuccessMessage('Pro mode activated for testing! ðŸŽ‰');

  showProDashboard();



  console.log('âœ… Pro mode activated. You can now access Step 6 Pro Dashboard.');

  return 'Pro mode activated!';

}



// Alternative: Add a hidden test button (remove in production)

// You can temporarily add this button anywhere to test

function addProTestButton() {

  // Only add if it doesn't exist

  if (document.getElementById('proTestBtn')) return;



  const btn = document.createElement('button');

  btn.id = 'proTestBtn';

  btn.textContent = 'ðŸ§ª TEST: Activate Pro';

  btn.style.cssText = 'position:fixed;bottom:20px;right:20px;background:#00a8e8;color:white;padding:12px 20px;border:none;border-radius:8px;cursor:pointer;z-index:9999;font-weight:600;box-shadow:0 4px 12px rgba(0,0,0,0.2);';

  btn.onclick = function() {

    activateProTestMode();

    this.remove();

  };

  document.body.appendChild(btn);

}



function getRandomPhrase(phrases) {

  return phrases[Math.floor(Math.random() * phrases.length)];

}



// Helper function for sleep/delay

function sleep(ms) {

  return new Promise(resolve => setTimeout(resolve, ms));

}



// Helper function to show retry notification (DISABLED - user doesn't like it)

function showRetryNotification(attempt, maxRetries) {

  // Disabled - user doesn't want connection error notifications

  // Silently retry in background

  return;

}



// Helper function to hide retry notification

function hideRetryNotification() {

  const notification = document.getElementById('retryNotification');

  if (notification) {

    notification.style.display = 'none';

  }

}



async function analyzeTextWithAPI(text, maxRetries = 2) {

  // Demo mode: skip API and return mock data so you can check the full UI flow without credits

  const demoMode = window.FFF_DEMO_MODE || (typeof URLSearchParams !== 'undefined' && new URLSearchParams(window.location.search).get('demo') === '1');

  if (demoMode) {

    console.log('ðŸŽ­ Demo mode: using mock scan data (no API call, no credits used)');

    await new Promise(r => setTimeout(r, 1200)); // Brief delay so loading state is visible

    const mockResult = {

      score: 48,

      verdict: 'Mid Sus',

      issues: [

        { phrase: 'utilize', severity: 'high', explanation: 'AI trigger word detected.', alternatives: ['use', 'try', 'work with'] },

        { phrase: 'leverage', severity: 'medium', explanation: 'Commonly flagged by AI detectors.', alternatives: ['use', 'tap into', 'work with'] },

        { phrase: 'furthermore', severity: 'medium', explanation: 'Formal transition often flagged.', alternatives: ['also', 'plus', 'and'] }

      ],

      flagCount: 3,

      textPhraseFlags: [],

      structuralFlags: []

    };

    mockResult.textPhraseFlags = mockResult.issues.map(i => ({ phrase: i.phrase, severity: i.severity, explanation: i.explanation, alternatives: i.alternatives || [] }));

    return mockResult;

  }



  // Use localhost for local development

  const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

  const BACKEND_URL = window.BACKEND_URL || 'http://localhost:5000';

  const API_ENDPOINT = `${BACKEND_URL}/analyze`;



  console.log('ðŸŒ BACKEND_URL:', BACKEND_URL);



  // Retry loop with exponential backoff

  let currentTimeoutId = null; // Store timeout ID outside loop so we can clear it on retries

  for (let attempt = 0; attempt <= maxRetries; attempt++) {

    try {

      // CRITICAL: Clear any previous timeout before starting new attempt

      if (currentTimeoutId) {

        clearTimeout(currentTimeoutId);

        currentTimeoutId = null;

      }



      if (attempt > 0) {

        // Show retry notification for retries (not first attempt)

        showRetryNotification(attempt - 1, maxRetries);

        // Exponential backoff: 1s, then 2s

        const delay = 1000 * attempt;

        console.log(`ðŸ”„ Retry attempt ${attempt}/${maxRetries} after ${delay}ms delay...`);

        await sleep(delay);

      }



      console.log(`ðŸŒ Making API call to backend (attempt ${attempt + 1}/${maxRetries + 1}):`, API_ENDPOINT);

      console.log('ðŸ“ Text length:', text.length);

      console.log('ðŸ“ Text preview:', text.substring(0, 100) + '...');



      // Determine tier based on user subscription status

      const tier = appState.isProUser ? 'pro' : 'free';

      console.log('ðŸ“Š Sending request with tier:', tier, '(isProUser:', appState.isProUser + ')');



      // CRITICAL: Store abort controller globally so scanNewText can abort it

      const controller = new AbortController();

      window._currentAbortController = controller;



      // Add timeout to prevent hanging

      currentTimeoutId = setTimeout(() => {

        console.error('â±ï¸ Request timeout after 30 seconds - aborting');

        controller.abort();

        window._currentAbortController = null;

        currentTimeoutId = null;

      }, 30000); // 30 second timeout



      let response;

      try {

        response = await fetch(API_ENDPOINT, {

        method: 'POST',

        headers: {

          'Content-Type': 'application/json'

        },

        body: JSON.stringify({ 

          essay: text,

          tier: tier  // Send tier to backend

          }),

          signal: controller.signal

        });

        clearTimeout(currentTimeoutId);

        currentTimeoutId = null;

        window._currentAbortController = null; // Clear after successful fetch

      } catch (fetchError) {

        clearTimeout(currentTimeoutId);

        currentTimeoutId = null;

        window._currentAbortController = null; // Clear after error

        if (fetchError.name === 'AbortError') {

          console.error('âŒ Request aborted (timeout or user cancelled)');

          // Don't retry if aborted - user likely cancelled

          throw new Error('Request cancelled');

        }

        throw fetchError;

      }



      console.log('ðŸ“¡ Response status:', response.status, response.statusText);

      console.log('ðŸ“¡ Response headers:', Object.fromEntries(response.headers.entries()));



      // Check for errors

      if (!response.ok) {

        // If 500 error and not last attempt, retry

        if (response.status === 500 && attempt < maxRetries) {

          // CRITICAL: Clear timeout before retrying

          clearTimeout(currentTimeoutId);

          currentTimeoutId = null;

          window._currentAbortController = null;



          let errorData;

          try {

            errorData = await response.json();

          } catch (e) {

            errorData = { error: 'Unknown error' };

          }

          console.warn(`âš ï¸ Attempt ${attempt + 1} failed with 500 error, will retry...`, errorData);

          continue; // Retry on next iteration

        }



        // CRITICAL: Clear timeout for other errors too

        clearTimeout(currentTimeoutId);

        currentTimeoutId = null;

        window._currentAbortController = null;



        // For other errors or last attempt, throw error

        let errorData;

        try {

          errorData = await response.json();

        } catch (e) {

          const errorText = await response.text();

          console.error('âŒ Failed to parse error response as JSON:', errorText);

          errorData = { error: errorText };

        }

        console.error('âŒ Backend API Error Response:', {

          status: response.status,

          statusText: response.statusText,

          body: errorData

        });

        throw new Error(`Backend API request failed: ${response.status} ${response.statusText}`);

      }



      // Success! Hide retry notification and parse response

      hideRetryNotification();



      // Parse successful response with timeout protection

      let data;

      try {

        const responseText = await response.text();

        console.log('ðŸ“¦ Response text length:', responseText.length, 'bytes');



        // Parse JSON with timeout protection

        const parseStart = performance.now();

        data = JSON.parse(responseText);

        const parseTime = performance.now() - parseStart;

        console.log('â±ï¸ JSON parse took:', parseTime.toFixed(2), 'ms');



        if (parseTime > 1000) {

          console.warn('âš ï¸ JSON parsing took longer than 1 second!');

        }

      } catch (parseError) {

        console.error('âŒ Failed to parse JSON response:', parseError);

        throw new Error('Invalid JSON response from server');

      }



      console.log('âœ… Backend API Success Response (parsed):', {

        score: data.score,

        verdict: data.verdict,

        textPhraseFlagsCount: data.textPhraseFlags?.length || 0,

        structuralFlagsCount: data.structuralFlags?.length || 0,

        responseSize: JSON.stringify(data).length + ' bytes'

      });



      // Extract and return the expected format (handle minimal response)

      const result = {

        score: data.score ?? 50,

        verdict: data.verdict || 'Mid Sus',

        // Convert textPhraseFlags to issues format for backward compatibility

        issues: (data.textPhraseFlags || []).map(flag => ({

          phrase: flag.phrase,

          severity: flag.severity,

          explanation: flag.explanation,

          alternatives: flag.alternatives || []

        })),

        flagCount: (data.textPhraseFlags?.length || 0) + (data.structuralFlags?.length || 0),

        textPhraseFlags: data.textPhraseFlags || [],

        structuralFlags: data.structuralFlags || []

      };



      console.log('âœ… Returning from analyzeTextWithAPI:', {

        score: result.score,

        issuesCount: result.issues.length,

        flagCount: result.flagCount,

        firstIssue: result.issues[0] || 'NONE'

      });



      // CRITICAL: Log if score exists but no issues

      if (result.score >= 30 && result.issues.length === 0) {

        console.error('âŒ WARNING: API returned score', result.score, 'but 0 issues!');

        console.error('Full API response:', JSON.stringify(data, null, 2));

      }



      return result; // Success - return immediately



    } catch (error) {

      // Network errors or other exceptions

      console.error(`âŒ Attempt ${attempt + 1} failed with exception:`, error.message);



      // CRITICAL: Clear timeout in catch block

      if (currentTimeoutId) {

        clearTimeout(currentTimeoutId);

        currentTimeoutId = null;

      }

      if (window._currentAbortController) {

        try {

          window._currentAbortController.abort();

        } catch (e) {}

        window._currentAbortController = null;

      }



      // If this is the last attempt, fall through to fallback

      if (attempt === maxRetries) {

        console.error('âŒ All retry attempts exhausted');

        break; // Exit loop and fall back to local detection

      }

      // Otherwise, continue to next retry

      continue;

    }

  }



  // All retries failed - hide notification and use local fallback

  hideRetryNotification();

  console.error('âŒ API call failed after all retries');

  console.warn('âš ï¸ Using local fallback - results may be less accurate');



  // Use local detection as fallback

  return analyzeTextLocally(text);

}



function updateScanButton() {

  // This function is called by updateCounter

}



// ===== UNIFIED TOOLTIP SYSTEM =====

let tooltip = null;



function createTooltip() {

  if (tooltip) return;

  tooltip = document.createElement('div');

  tooltip.className = 'tooltip';

  document.body.appendChild(tooltip);

}



function getTooltipColorClass(button) {

  // New unified classes

  if (button.classList.contains('btn-primary')) return 'blue-border';

  if (button.classList.contains('btn-secondary')) return 'orange-border';

  if (button.classList.contains('btn-success')) return 'green-border';

  // Old classes (for backwards compatibility)

  if (button.classList.contains('scan-button')) return 'blue-border';

  if (button.classList.contains('emergency-button')) return 'orange-border';

  if (button.classList.contains('pro-button')) return 'green-border';

  if (button.classList.contains('btn-quickfix')) return 'orange-border';

  if (button.classList.contains('btn-pro')) return 'green-border';

  return '';

}



function showTooltip(event) {

  // Check if authorship checkbox is checked before showing tooltip

  const authorshipCheckbox = document.getElementById('authorshipCheckbox');

  if (authorshipCheckbox && !authorshipCheckbox.checked) {

    return; // Hide tooltip if checkbox is not checked

  }



  createTooltip();



  const button = event.currentTarget;

  const message = button.getAttribute('data-tooltip') || button.getAttribute('title');



  if (!message) return;



  // Set content

  tooltip.textContent = message;



  // Remove old color classes

  tooltip.classList.remove('blue-border', 'orange-border', 'green-border');



  // Add appropriate color class

  const colorClass = getTooltipColorClass(button);

  if (colorClass) {

    tooltip.classList.add(colorClass);

  }



  // Show tooltip

  tooltip.classList.add('show');



  // Position tooltip above the button

  positionTooltip(button);

}



function positionTooltip(button) {

  const rect = button.getBoundingClientRect();

  const tooltipRect = tooltip.getBoundingClientRect();



  // Center horizontally on button

  let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);

  let top = rect.top - tooltipRect.height - 10;



  // Keep tooltip within viewport

  if (left < 10) left = 10;

  if (left + tooltipRect.width > window.innerWidth - 10) {

    left = window.innerWidth - tooltipRect.width - 10;

  }

  if (top < 10) {

    top = rect.bottom + 10;

  }



  tooltip.style.left = left + 'px';

  tooltip.style.top = top + 'px';

}



function hideTooltip() {

  // Hide tooltip using the global variable

  if (tooltip) {

    tooltip.classList.remove('show');

    tooltip.style.display = 'none';

  }



  // Also check for tooltip by ID (for the other tooltip system)

  const tooltipById = document.getElementById('tooltip');

  if (tooltipById) {

    tooltipById.classList.remove('show');

    tooltipById.style.display = 'none';

  }



  // Clear all tooltip elements that might be stuck

  const allTooltips = document.querySelectorAll('.tooltip.show, .tooltip[style*="display"], .tooltip[style*="block"]');

  allTooltips.forEach(tt => {

    tt.classList.remove('show');

    tt.style.display = 'none';

  });

}



// Make hideTooltip globally accessible

window.hideTooltip = hideTooltip;



// Clear all tooltips on page load (only removes stuck ones, not active ones)

function clearAllTooltips() {

  // FORCE HIDE ALL TOOLTIPS - NUCLEAR OPTION

  const allTooltipSelectors = [

    '#tooltip',

    '.tooltip',

    '.tooltip.show',

    '[id*="tooltip"]',

    '[class*="tooltip"]',

    '#scoreTooltip',

    '#triggerTooltip',

    '#falseFlowTooltip',

    '.tooltip-text-desktop'

  ];



  allTooltipSelectors.forEach(selector => {

    try {

      const elements = document.querySelectorAll(selector);

      elements.forEach(el => {

        if (el) {

          el.classList.remove('show');

          el.style.display = 'none';

          el.style.visibility = 'hidden';

          el.style.opacity = '0';

          el.style.pointerEvents = 'none';

        }

      });

    } catch (e) {}

  });



  // Clear the global tooltip variable (if it exists)

  if (typeof tooltip !== 'undefined' && tooltip) {

    tooltip.classList.remove('show');

    tooltip.style.display = 'none';

    tooltip.style.visibility = 'hidden';

    tooltip.style.opacity = '0';

    tooltip = null;

  }



  // Only remove tooltips that are stuck (have show class but shouldn't be visible)

  const stuckTooltips = document.querySelectorAll('#tooltip.show, .tooltip.show');

  stuckTooltips.forEach(tt => {

    // Only remove if they're not near a hovered element

    const rect = tt.getBoundingClientRect();

    const isVisible = rect.width > 0 && rect.height > 0;

    if (isVisible) {

      // Check if there's a hovered element nearby - if not, it's stuck

      const hovered = document.querySelector(':hover');

      if (!hovered || !hovered.hasAttribute('data-tooltip')) {

        tt.classList.remove('show');

        tt.style.display = 'none';

      }

    } else {

      tt.classList.remove('show');

      tt.style.display = 'none';

    }

  });

}



window.clearAllTooltips = clearAllTooltips;



// Tooltip function for flagged words - white background with colored border matching score

function showFlagTooltip(event, text, borderColor) {

  // Get or create tooltip element

  let tooltip = document.getElementById('flagTooltip');

  if (!tooltip) {

    tooltip = document.createElement('div');

    tooltip.id = 'flagTooltip';

    tooltip.className = 'tooltip';

    document.body.appendChild(tooltip);

  }



  // Set tooltip content and styling

  tooltip.textContent = text;

  tooltip.style.background = 'white';

  tooltip.style.color = '#1e3a8a';

  tooltip.style.borderLeft = `4px solid ${borderColor}`;

  tooltip.style.borderRight = `4px solid ${borderColor}`;

  tooltip.style.borderTop = 'none';

  tooltip.style.borderBottom = 'none';

  tooltip.style.padding = '12px 16px';

  tooltip.style.borderRadius = '8px';

  tooltip.style.fontSize = '13px';

  tooltip.style.fontWeight = '600';

  tooltip.style.maxWidth = '280px';

  tooltip.style.zIndex = '10000';

  tooltip.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';

  tooltip.style.pointerEvents = 'none';

  tooltip.style.display = 'block';

  tooltip.style.lineHeight = '1.5';

  tooltip.style.textAlign = 'center';

  tooltip.style.wordWrap = 'break-word';

  tooltip.classList.add('show');



  // Position tooltip

  const rect = event.target.getBoundingClientRect();

  const tooltipRect = tooltip.getBoundingClientRect();

  let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);

  let top = rect.top - tooltipRect.height - 10;



  // Keep tooltip within viewport

  if (left < 10) left = 10;

  if (left + tooltipRect.width > window.innerWidth - 10) {

    left = window.innerWidth - tooltipRect.width - 10;

  }

  if (top < 10) {

    top = rect.bottom + 10;

  }



  tooltip.style.left = left + 'px';

  tooltip.style.top = top + 'px';

}



function hideFlagTooltip() {

  const tooltip = document.getElementById('flagTooltip');

  if (tooltip) {

    tooltip.classList.remove('show');

    tooltip.style.display = 'none';

  }

}



window.showFlagTooltip = showFlagTooltip;

window.hideFlagTooltip = hideFlagTooltip;



// JavaScript to populate the blurred essay

function populateLockboxEssay(essayText) {

  const blurredBackground = document.getElementById('lockboxBlurredBackground');

  if (blurredBackground && essayText) {

    // Take first 5-8 lines (approx 500 characters)

    const previewText = essayText.substring(0, 500) + (essayText.length > 500 ? '...' : '');



    blurredBackground.innerHTML = `

      <div style="font-size: 13px; line-height: 1.6; color: #6b7280; white-space: pre-wrap; word-wrap: break-word; max-height: 400px; overflow: hidden; padding: 32px 24px;">

        ${previewText}

      </div>

    `;

  }

}



// Call this when showing the lockbox

function showLockboxWithEssay(essayContent) {

  const overlay = document.getElementById('freeUnlockOverlay');

  if (overlay) {

    populateLockboxEssay(essayContent);

    overlay.style.display = 'block';

  }

}



window.populateLockboxEssay = populateLockboxEssay;

window.showLockboxWithEssay = showLockboxWithEssay;



// Handle email signup form submission for all users (QuickFix & Pro)

function handleEmailSignup(event) {

  event.preventDefault();



  // Check which form was submitted (Step 2 or Step 3)

  const formId = event.target.id;

  let emailInput, submitBtn, messageDiv;



  if (formId === 'proEmailSignupFormElement') {

    // Step 2 form

    emailInput = document.getElementById('proEmailInput');

    submitBtn = document.getElementById('proEmailSubmitBtn');

    messageDiv = document.getElementById('proEmailSignupMessage');

  } else if (formId === 'quickfixStep3EmailSignupFormElement') {

    // Step 3 form

    emailInput = document.getElementById('quickfixStep3EmailInput');

    submitBtn = document.getElementById('quickfixStep3EmailSubmitBtn');

    messageDiv = document.getElementById('quickfixStep3EmailSignupMessage');

  }



  if (!emailInput || !submitBtn || !messageDiv) return;



  const email = emailInput.value.trim();



  if (!email) {

    messageDiv.textContent = 'Please enter a valid email address.';

    messageDiv.style.display = 'block';

    messageDiv.style.background = '#fee2e2';

    messageDiv.style.color = '#991b1b';

    return;

  }



  // Log email to console (for now - later can connect to Mailchimp/ConvertKit)

  console.log('ðŸ“§ Email signup:', email);



  // Show success message

  messageDiv.textContent = 'Thank you! We\'ll notify you about updates.';

  messageDiv.style.display = 'block';

  messageDiv.style.background = '#d1fae5';

  messageDiv.style.color = '#065f46';



  // Disable form

  emailInput.disabled = true;

  submitBtn.disabled = true;

  submitBtn.textContent = 'Subscribed âœ“';

  submitBtn.style.background = '#10b981';

  submitBtn.style.cursor = 'not-allowed';



  // Clear input after a delay

  setTimeout(() => {

    emailInput.value = '';

  }, 2000);

}



window.handleEmailSignup = handleEmailSignup;



// ========= PANIC OVERLAY =========

// Helper function to save essay and open paywall (ensures essay is preserved for re-analysis after upgrade)

window.openPaywallWithSavedEssay = function(score, triggers) {

  // Ensure essay text is saved for re-analysis after upgrade

  const essayInput = document.querySelector('#essayInput');

  if (essayInput && essayInput.value) {

    if (!appState.lastScanData) appState.lastScanData = {};

    appState.lastScanData.essayText = essayInput.value;

    appState.lastScanData.score = score;

    appState.lastScanData.triggers = triggers;

    console.log('ðŸ’¾ Saved essay text for re-analysis after upgrade:', appState.lastScanData.essayText.length, 'characters');

  }

  closeOverlayAndShowEssay();

  setTimeout(() => {

    if (typeof showPaywallModal === 'function') {

      showPaywallModal('View all detected triggers and get replacement suggestions.');

    }

  }, 300);

};



function showPanicOverlay(score, triggers) {

  console.log('ðŸš¨ PANIC OVERLAY - Score:', score, 'Triggers:', triggers);



  // Remove any existing overlay

  document.querySelectorAll('.panic-overlay, .happy-overlay').forEach(el => el.remove());



  // Ensure essay text is saved for re-analysis after upgrade

  if (!appState.lastScanData || !appState.lastScanData.essayText) {

    const essayInput = document.querySelector('#essayInput');

    if (essayInput && essayInput.value) {

      if (!appState.lastScanData) appState.lastScanData = {};

      appState.lastScanData.essayText = essayInput.value;

      appState.lastScanData.score = score;

      appState.lastScanData.triggers = triggers;

      console.log('ðŸ’¾ Saved essay text for re-analysis after upgrade:', appState.lastScanData.essayText.length, 'characters');

    }

  }



  // Create overlay

  const overlay = document.createElement('div');

  overlay.className = 'panic-overlay';



  // Get total trigger count

  const totalTriggerCount = triggers && Array.isArray(triggers) ? triggers.length : 0;



  // Get trigger texts safely - show top 5

  const triggerTexts = [];

  if (triggers && Array.isArray(triggers)) {

    triggers.slice(0, 5).forEach(flag => {

      let wordText = '';

      if (typeof flag === 'string') {

        wordText = flag;

      } else if (flag && typeof flag === 'object') {

        wordText = flag.word || flag.text || flag.trigger || flag.flaggedWord || flag.phrase || '';

      }

      if (wordText && typeof wordText === 'string' && wordText.trim().length > 0) {

        triggerTexts.push(wordText.trim());

      }

    });

  }



  // Determine Sus level for dynamic messaging

  const susLevel = score >= 70 ? 'Major Sus' : score >= 30 ? 'Mid Sus' : 'Low Sus';

  const shownCount = triggerTexts.length;



  // Color scheme based on score tier (Hella Sus = RED, Kinda Sus = yellow/orange)

  const scoreBoxBg = score >= 70 ? '#dc2626' : '#f59e0b';

  const scoreBoxBorder = score >= 70 ? '#dc2626' : '#f59e0b';



  overlay.innerHTML = `

    <div class="panic-overlay-content" style="

      position: fixed;

      top: 50%;

      left: 50%;

      transform: translate(-50%, -50%);

      background: white;

      backdrop-filter: blur(8px);

      padding: 40px;

      border-radius: 20px;

      border: 3px solid #dc2626;

      text-align: center;

      z-index: 10000;

      min-width: 400px;

      max-width: 500px;

      box-shadow: 0 0 60px rgba(220, 38, 38, 0.3);

      color: #1f2937;

    ">

      <!-- Lil Sus image above "Don't Turn It In Yet" -->

      <div style="text-align: center; margin-bottom: 16px;">

        <img src="https://i.postimg.cc/SsFdDG8K/ls-dont-trans.png" alt="Lil Sus" style="width: 100px; height: auto; display: block; margin: 0 auto;">

      </div>



      <!-- "Don't Turn It In Yet" with red stop symbol -->

      <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 20px;">

        <span style="font-size: 24px;">ðŸ›‘</span>

        <span style="color: #0b0646; font-size: 28px; font-weight: 700; font-family: 'Raleway', sans-serif; letter-spacing: -0.25px;">Don't Turn It In Yet</span>

      </div>



      <!-- Header: "X AI Trigger Words Detected â€¢ First X Shown" -->

      <p style="color: #0b0646; margin: 0 0 20px 0; font-size: 20px; font-weight: 700; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.4;">

        ${totalTriggerCount} AI Trigger Words Detected â€¢ First ${shownCount} Shown

      </p>



      <!-- Trigger pills - reduced size -->

      <div style="

        display: flex;

        gap: 10px;

        justify-content: center;

        margin-bottom: 30px;

        flex-wrap: wrap;

      ">

        ${triggerTexts.length > 0 ? triggerTexts.map(trigger => `

          <div style="

            background: #FFF000;

            color: black;

            padding: 10px 16px;

            border-radius: 20px;

            font-weight: 500;

            font-size: 14px;

            box-shadow: 0 0 15px rgba(255, 240, 0, 0.4);

            letter-spacing: 0.5px;

          ">${trigger.toLowerCase()}</div>

        `).join('') : '<div style="color: #6b7280; font-size: 16px;">High AI probability detected</div>'}

      </div>



      <!-- CTA Buttons: Side-by-side -->

      <div style="display: flex; gap: 12px; margin-bottom: 15px;">

        <!-- LEFT: "See My Score" -->

        <button onclick="closeOverlayAndShowEssay()" style="

          background: white;

          color: #0b0646;

          border: 1px dashed #0b0646;

          padding: 18px 24px;

          border-radius: 12px;

          font-size: 16px;

          font-weight: 700;

          cursor: pointer;

          flex: 1;

          display: flex;

          align-items: center;

          justify-content: center;

          gap: 8px;

          transition: transform 0.2s, box-shadow 0.2s;

          box-shadow: 0 4px 15px rgba(11, 6, 70, 0.2);

        " onmouseover="this.style.background='#f8f9fa'; this.style.transform='scale(1.02)'" onmouseout="this.style.background='white'; this.style.transform='scale(1)'">

          <span style="font-size: 20px;">ðŸ”</span>

          See My Score

        </button>



        <!-- RIGHT: "View All - Unlock Pro" -->

        <button onclick="

          const overlay = this.closest('.panic-overlay');

          const score = overlay ? parseFloat(overlay.dataset.score) : 0;

          const triggers = overlay ? JSON.parse(overlay.dataset.triggers || '[]') : [];

          closeOverlayAndShowEssay();

          setTimeout(() => openPaywallWithSavedEssay(score, triggers), 300);

        " style="

          background: linear-gradient(to bottom, #00a8e8, #0b0646);

          color: white;

          border: none;

          padding: 18px 24px;

          border-radius: 12px;

          font-size: 16px;

          font-weight: 700;

          cursor: pointer;

          flex: 1;

          display: flex;

          align-items: center;

          justify-content: center;

          gap: 8px;

          transition: transform 0.2s, box-shadow 0.2s;

          box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);

          white-space: nowrap;

        " onmouseover="this.style.background='linear-gradient(to bottom, #0087c4, #06082e)'; this.style.transform='scale(1.02)'; this.style.boxShadow='0 6px 20px rgba(59, 130, 246, 0.4)'" onmouseout="this.style.background='linear-gradient(to bottom, #00a8e8, #0b0646)'; this.style.transform='scale(1)'; this.style.boxShadow='0 4px 15px rgba(59, 130, 246, 0.3)'">

          <span style="font-size: 20px;">ðŸ“Š</span>

          View All - Unlock Pro

        </button>

      </div>



      <p style="color: #6b7280; font-size: 13px; margin: 0;">

        Click outside or press ESC to close

      </p>

    </div>



    <div style="

      position: fixed;

      top: 0;

      left: 0;

      right: 0;

      bottom: 0;

      background: rgba(0, 0, 0, 0.6);

      backdrop-filter: blur(4px);

      z-index: 9999;

    " onclick="closeOverlayAndShowEssay()"></div>

  `;



  // Store score and triggers on overlay for button access

  overlay.dataset.score = score;

  overlay.dataset.triggers = JSON.stringify(triggers);



  // Add to page

  document.body.appendChild(overlay);



  // Escape key to close

  const handleEscape = (e) => {

    if (e.key === 'Escape') closeOverlayAndShowEssay();

  };

  document.addEventListener('keydown', handleEscape);



  // Store cleanup function

  overlay.cleanup = () => {

    document.removeEventListener('keydown', handleEscape);

  };

}



// Helper function to close overlay and show essay

window.closeOverlayAndShowEssay = function() {

  console.log('ðŸš€ [DEBUG] closeOverlayAndShowEssay CALLED');



  // Close overlays

  document.querySelectorAll('.panic-overlay, .happy-overlay').forEach(overlay => {

    if (overlay.cleanup) overlay.cleanup();

    overlay.remove();

  });



  // Show interactive essay box using stored data

  if (typeof showInteractiveEssayBox === 'function' && appState.lastScanData) {

    const score = appState.lastScanData.score || 0;

    const triggers = appState.lastScanData.triggers || [];

    const essayText = appState.lastScanData.essayText || '';



    console.log('ðŸš€ [DEBUG] Calling showInteractiveEssayBox with:', {

      score: score,

      triggersCount: triggers.length,

      essayTextLength: essayText.length,

      scoreRange: score < 30 ? 'Clean (0-29)' : score < 70 ? 'Kinda Sus (30-69)' : 'Hella Sus (70+)'

    });



    // CRITICAL: Ensure essay text is available - try multiple sources

    if (!essayText || essayText.trim().length === 0) {

      const essayInput = document.querySelector('#essayInput, textarea');

      if (essayInput && essayInput.value) {

        appState.lastScanData.essayText = essayInput.value;

        console.log('âœ… [DEBUG] Retrieved essay text from essayInput, length:', essayInput.value.length);

      } else if (appState.originalText) {

        appState.lastScanData.essayText = appState.originalText;

        console.log('âœ… [DEBUG] Retrieved essay text from appState.originalText, length:', appState.originalText.length);

      }

    }



    // CRITICAL: Pass essay text to showInteractiveEssayBox

    const essayTextToPass = appState.lastScanData.essayText || 

                            (document.querySelector('#essayInput, textarea')?.value) || 

                            appState.originalText || 

                            '';



    console.log('ðŸš€ [DEBUG] Passing essay text to showInteractiveEssayBox, length:', essayTextToPass.length);



    showInteractiveEssayBox(

      score, 

      triggers,

      essayTextToPass

    );



    // Start progress bar animation AFTER modal closes and results are visible (FREE results only)

    // Wait a bit to ensure the cards are visible before starting animation

    setTimeout(() => {

      if (typeof startProgressAnimations === 'function') {

        console.log('ðŸŽ¬ Starting progress bar animation after modal close - Score:', score);

        startProgressAnimations(score);

      }

    }, 300);



    // Scroll to top of results page after showing essay box

    setTimeout(() => {

      const resultsContainer = document.getElementById('resultsContainer') || 

                              document.querySelector('.results-container') ||

                              document.querySelector('#kindaSusCard, #hellaSusCard, #youreGoodCard');

      if (resultsContainer) {

        resultsContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

      } else {

        // Fallback: scroll to top of page

        window.scrollTo({ top: 0, behavior: 'smooth' });

      }

    }, 100);

  } else {

    console.error('Cannot show interactive essay: No scan data found', {

      hasFunction: typeof showInteractiveEssayBox === 'function',

      hasData: !!appState.lastScanData,

      lastScanData: appState.lastScanData

    });

  }

};



// ========= HAPPY OVERLAY =========  

function showHappyOverlay(score, triggers) {

  console.log('âœ… HAPPY OVERLAY - Score:', score);



  // Remove any existing overlay

  document.querySelectorAll('.panic-overlay, .happy-overlay').forEach(el => el.remove());



  // Create overlay

  const overlay = document.createElement('div');

  overlay.className = 'happy-overlay';



  overlay.innerHTML = `

    <div style="

      position: fixed;

      top: 50%;

      left: 50%;

      transform: translate(-50%, -50%);

      background: rgba(255, 255, 255, 0.98);

      backdrop-filter: blur(12px);

      padding: 50px 40px;

      border-radius: 24px;

      border: 3px solid #10b981;

      text-align: center;

      z-index: 10000;

      min-width: 420px;

      max-width: 500px;

      box-shadow: 0 25px 80px rgba(16, 185, 129, 0.25);

      color: #064e3b;

    ">

      <div style="

        font-size: 72px;

        color: #10b981;

        margin-bottom: 25px;

        filter: drop-shadow(0 0 15px rgba(16, 185, 129, 0.4));

        animation: pulse 2s infinite;

      ">âœ¨</div>



      <h2 style="

        color: #065f46;

        margin: 0 0 12px 0;

        font-size: 32px;

        font-weight: 900;

        line-height: 1.2;

      ">YOUR ESSAY IS CLEAN!</h2>



      <div style="

        color: #047857;

        font-size: 18px;

        margin-bottom: 30px;

        font-weight: 500;

      ">

        No AI triggers detected

      </div>



      <div style="

        background: linear-gradient(135deg, #10b981, #34d399);

        color: white;

        padding: 16px 30px;

        border-radius: 16px;

        font-size: 42px;

        font-weight: 900;

        margin: 25px 0;

        border: none;

        box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);

        display: inline-block;

      ">${score}%</div>



      <div style="

        color: #059669;

        font-size: 20px;

        font-weight: 700;

        margin-bottom: 35px;

        letter-spacing: 1px;

      ">AI PROBABILITY</div>



      <div style="

        background: #ecfdf5;

        border: 2px solid #a7f3d0;

        border-radius: 16px;

        padding: 20px;

        margin: 0 0 35px 0;

      ">

        <div style="

          display: flex;

          align-items: center;

          justify-content: center;

          gap: 12px;

          margin-bottom: 10px;

        ">

          <span style="

            background: #10b981;

            color: white;

            width: 36px;

            height: 36px;

            border-radius: 50%;

            display: flex;

            align-items: center;

            justify-content: center;

            font-weight: bold;

            font-size: 18px;

          ">âœ“</span>

          <span style="color: #065f46; font-size: 18px; font-weight: 600;">

            Safe to submit

          </span>

        </div>

        <p style="color: #4b5563; margin: 0; font-size: 15px; line-height: 1.5;">

          Your essay shows minimal AI indicators and is unlikely to be flagged by detectors.

        </p>

      </div>



      <button onclick="closeOverlayAndShowEssay()" style="

        background: linear-gradient(135deg, #10b981, #059669);

        color: white;

        border: none;

        padding: 20px 45px;

        border-radius: 14px;

        font-size: 20px;

        font-weight: 800;

        cursor: pointer;

        width: 100%;

        display: flex;

        align-items: center;

        justify-content: center;

        gap: 15px;

        transition: all 0.3s;

        margin-bottom: 20px;

        box-shadow: 0 12px 30px rgba(16, 185, 129, 0.4);

        letter-spacing: 0.5px;

      " onmouseover="this.style.transform='scale(1.03)'; this.style.boxShadow='0 15px 40px rgba(16, 185, 129, 0.5)';"

        onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 12px 30px rgba(16, 185, 129, 0.4)';">

        <span style="font-size: 26px;">ðŸŽ‰</span>

        READY TO SUBMIT SAFELY!

      </button>



      <p style="color: #9ca3af; font-size: 14px; margin: 0; font-weight: 500;">

        Click anywhere outside or press ESC

      </p>

    </div>



    <div style="

      position: fixed;

      top: 0;

      left: 0;

      right: 0;

      bottom: 0;

      background: rgba(255, 255, 255, 0.85);

      backdrop-filter: blur(6px);

      z-index: 9999;

    " onclick="closeOverlayAndShowEssay()"></div>

  `;



  // Add CSS animation

  const style = document.createElement('style');

  style.textContent = `

    @keyframes pulse {

      0% { transform: scale(1); }

      50% { transform: scale(1.1); }

      100% { transform: scale(1); }

    }

  `;

  document.head.appendChild(style);



  // Add to page

  document.body.appendChild(overlay);



  // Escape key to close

  const handleEscape = (e) => {

    if (e.key === 'Escape') closeOverlayAndShowEssay();

  };

  document.addEventListener('keydown', handleEscape);



  // Store cleanup function

  overlay.cleanup = () => {

    document.removeEventListener('keydown', handleEscape);

    style.remove();

  };

}



// ========= INTERACTIVE ESSAY =========

function showInteractiveEssayBox(score, triggers, essayText) {

  // Don't show interactive essay box for clean scores (0-29)

  if (score < 30) {

    console.log('ðŸ›‘ Skipping interactive essay box for clean score:', score);

    return; // Exit the function, don't create anything

  }



  console.log('=== DEBUG showInteractiveEssayBox ===');

  console.log('1. Score:', score);

  console.log('2. Essay text type:', typeof essayText);

  console.log('3. Essay text length:', essayText?.length);

  console.log('4. Essay text first 50 chars:', essayText?.substring(0, 50));

  console.log('5. triggers:', triggers);

  console.log('ðŸš€ [DEBUG] Score range:', score < 30 ? 'Clean (0-29)' : score < 70 ? 'Kinda Sus (30-69)' : 'Hella Sus (70+)');



  // CRITICAL: Ensure this function works for ALL score ranges

  if (score === undefined || score === null) {

    console.warn('âš ï¸ [DEBUG] Score is undefined/null, using default');

    score = 0;

  }



  if (!triggers || !Array.isArray(triggers)) {

    console.warn('âš ï¸ [DEBUG] Triggers is not an array, using empty array');

    triggers = [];

  }



  // CRITICAL: Remove ALL existing interactive essay boxes first to prevent duplicates

  document.querySelectorAll('.interactive-essay-box, [class*="interactive-essay"]').forEach(el => {

    console.log('ðŸ—‘ï¸ Removing duplicate essay box:', el);

    el.remove();

  });



  // 1. Find and remove old trigger pills UI completely - find the parent card container

  const triggerHeading = document.getElementById('freeTriggerHeading');

  const triggerPillsCard = triggerHeading ? triggerHeading.closest('.card') : null;



  // Also hide/remove individual elements as backup

  const triggerChips = document.getElementById('freeTriggerChips');

  const triggerChipsHint = document.getElementById('freeTriggerChipsHint');

  if (triggerChips) {

    triggerChips.style.display = 'none';

    triggerChips.innerHTML = '';

  }

  if (triggerChipsHint) {

    triggerChipsHint.style.display = 'none';

  }



  // 2. Find the essay text on page

  // CRITICAL: Use passed essayText parameter first, then fallback to stored data

  if (!essayText || typeof essayText !== 'string' || essayText.trim().length === 0) {

    // Try multiple sources for essay text (prioritize stored data)

    // 1. Try appState.lastScanData.essayText (stored when scan completes)

    if (appState.lastScanData && appState.lastScanData.essayText) {

      essayText = appState.lastScanData.essayText;

      console.log('âœ… [DEBUG] Found essay text in appState.lastScanData.essayText, length:', essayText.length);

    }

    // 2. Try appState.originalText

    else if (appState.originalText && appState.originalText.trim()) {

      essayText = appState.originalText;

      console.log('âœ… [DEBUG] Found essay text in appState.originalText, length:', essayText.length);

    }

    // 3. Try essayInput textarea

    else {

      const essayInput = document.querySelector('#essayInput, textarea');

      if (essayInput && essayInput.value && essayInput.value.trim()) {

        essayText = essayInput.value;

        console.log('âœ… [DEBUG] Found essay text in essayInput, length:', essayText.length);

      } else {

        // Fallback to our default essay

        essayText = `Furthermore, the data suggests that cutting-edge innovations enable businesses to leverage unprecedented levels of success. In conclusion, it is important to note that organizations must utilize these cutting-edge solutions to leverage unprecedented levels of growth.`;

        console.warn('âš ï¸ [DEBUG] No essay text found, using fallback default essay');

      }

    }

  } else {

    console.log('âœ… [DEBUG] Using essayText parameter, length:', essayText.length);

  }



  // Ensure we have text

  if (!essayText || essayText.trim().length === 0) {

    console.error('âŒ [DEBUG] Essay text is empty! Using fallback');

    essayText = `Furthermore, the data suggests that cutting-edge innovations enable businesses to leverage unprecedented levels of success. In conclusion, it is important to note that organizations must utilize these cutting-edge solutions to leverage unprecedented levels of growth.`;

  }



  console.log('ðŸ“ [DEBUG] Final essay text length:', essayText.length, 'First 100 chars:', essayText.substring(0, 100));



  // 3. Extract trigger texts safely

  const triggerTexts = [];

  if (triggers && Array.isArray(triggers)) {

    triggers.forEach(t => {

      let wordText = '';

      if (typeof t === 'string') {

        wordText = t;

      } else if (t && typeof t === 'object') {

        wordText = t.word || t.text || t.trigger || t.flaggedWord || t.phrase || '';

      }

      if (wordText && typeof wordText === 'string' && wordText.trim().length > 0) {

        triggerTexts.push(wordText.trim());

      }

    });

  }



  // 4. Create highlighted essay with ONLY first 3 triggers highlighted

  // Simple mapping of common trigger words to alternatives

  const triggerAlternatives = {

    'furthermore': 'also, additionally, moreover',

    'cutting-edge': 'innovative, advanced, latest',

    'leverage': 'use, utilize, take advantage of',

    'utilize': 'use, employ, make use of',

    'unprecedented': 'unusual, exceptional, remarkable',

    'consequently': 'therefore, as a result, thus',

    'moreover': 'furthermore, additionally, also',

    'nevertheless': 'however, still, yet',

    'therefore': 'so, thus, as a result',

    'thus': 'so, therefore, as a result'

  };



  // Function to get alternative for a trigger word

  function getAlternative(trigger) {

    const lowerTrigger = trigger.toLowerCase();

    return triggerAlternatives[lowerTrigger] || 'a more natural alternative';

  }



  let highlightedEssay = essayText;

  let highlightCount = 0;

  const maxHighlights = 3;

  let lastHighlightEndIndex = 0;



  // Track all trigger occurrences with their positions

  const triggerOccurrences = [];

  triggerTexts.forEach(trigger => {

    if (trigger && essayText.includes(trigger)) {

      const regex = new RegExp(escapeRegExp(trigger), 'gi');

      let match;

      while ((match = regex.exec(essayText)) !== null) {

        triggerOccurrences.push({

          trigger: trigger,

          index: match.index,

          length: match[0].length,

          text: match[0]

        });

      }

    }

  });



  // Sort by position in text

  triggerOccurrences.sort((a, b) => a.index - b.index);



  // Only highlight the first 3 occurrences

  const highlightedOccurrences = triggerOccurrences.slice(0, maxHighlights);

  const remainingOccurrences = triggerOccurrences.slice(maxHighlights);



  // Build highlighted essay by processing text in order

  let result = '';

  let currentIndex = 0;



  // Process first 3 highlights

  highlightedOccurrences.forEach((occ, idx) => {

    // Add text before this highlight

    result += essayText.substring(currentIndex, occ.index);



    // Get alternative word

    const alternative = getAlternative(occ.trigger);

    // Tooltip text with word, why flagged, and suggestions

    const tooltipText = `${occ.text} - Common in AI writing. Consider using: ${alternative}`;

    // Escape for JavaScript

    const tooltipTextJS = tooltipText.replace(/'/g, "\\'").replace(/"/g, '\\"');



    // Add highlighted trigger with QuickFix-style tooltip

    result += `<mark class="ai-highlight" data-trigger="${escapeHtml(occ.trigger)}" 

       style="background:#FFF000;color:black;padding:2px 4px;border-radius:4px;cursor:pointer;position:relative;font-weight:bold;"

       onclick="showPaywallForTrigger('${escapeHtml(occ.trigger)}')"

       onmouseenter="showTriggerTooltip(event, '${tooltipTextJS}')"

       onmouseleave="hideTriggerTooltip()">

     ${escapeHtml(occ.text)}

    </mark>`;



    currentIndex = occ.index + occ.length;

    lastHighlightEndIndex = currentIndex;

  });



  // Calculate blur metrics for dynamic positioning (Hella Sus only, score >= 70)

  let blurStartIndex = currentIndex;

  let blurredTextLength = 0;

  let blurIntensity = 10; // Default blur

  let lockEmojiPosition = 50; // Default center position (%)



  // Calculate blur metrics for Hella Sus (3+ triggers) or Kinda Sus (1+ triggers)

  if ((score >= 70 && highlightedOccurrences.length >= 3) || (score >= 30 && score < 70 && highlightedOccurrences.length >= 1)) {

    blurredTextLength = essayText.length - blurStartIndex;

    const totalLength = essayText.length;

    const blurredPercentage = (blurredTextLength / totalLength) * 100;

    const textBeforeBlurPercentage = (blurStartIndex / totalLength) * 100;



    // Calculate lock emoji position: Start at least 2 lines below last highlight

    // Position based on last highlight end + sufficient spacing to avoid overlap

    const lastHighlightEndPosition = (lastHighlightEndIndex / totalLength) * 100;



    // Adjust blur intensity based on essay length (only for Hella Sus)

    if (score >= 70) {

      if (totalLength < 150) {

        // Short essay: Less blur, smaller blurred area

        blurIntensity = 6;

      } else if (totalLength >= 150 && totalLength < 300) {

        // Medium essay: Normal blur

        blurIntensity = 10;

      } else if (totalLength >= 300 && totalLength <= 500) {

        // Long essay: More blur area

        blurIntensity = 12;

      }

    } else {

      // Kinda Sus: Normal blur

      blurIntensity = 10;

    }



    // Position lock emoji: At least 2 lines below last highlight (one line after + one more for spacing)

    // Use larger spacing (18-20%) to ensure it's well below the last highlight line

    // This accounts for line breaks and ensures the emoji starts on the line AFTER the next blurred line

    const minSpacingFromHighlight = 18; // % spacing to ensure 2+ lines below last highlight

    const calculatedPosition = lastHighlightEndPosition + minSpacingFromHighlight;



    // Ensure it's well into the blurred section (at least 8% into blur) but not too close to bottom

    // Cap at 78% to avoid bottom interference with "Unlock All Fixes" heading

    const maxPosition = 78; // Leave room at bottom for heading/buttons

    const minPosition = Math.max(textBeforeBlurPercentage + 10, lastHighlightEndPosition + minSpacingFromHighlight);

    lockEmojiPosition = Math.min(Math.max(calculatedPosition, minPosition), maxPosition);



    console.log('ðŸ”’ Blur metrics:', {

      score,

      totalLength,

      blurStartIndex,

      blurredTextLength,

      textBeforeBlurPercentage: textBeforeBlurPercentage.toFixed(1) + '%',

      blurredPercentage: blurredPercentage.toFixed(1) + '%',

      blurIntensity,

      lockEmojiPosition: lockEmojiPosition.toFixed(1) + '%',

      triggers: highlightedOccurrences.length

    });

  }



  // Add remaining text - blur after LAST highlight for Kinda Sus (30-69%), or after 3rd for Hella Sus (70+)

  if (currentIndex < essayText.length) {

    if (score >= 30 && score < 70 && highlightedOccurrences.length >= 1) {

      // Kinda Sus: Blur everything after the LAST highlighted trigger (even if only 1 or 2)

      result += `<span class="blurred-essay-text" data-blur-start="${blurStartIndex}" data-blur-length="${blurredTextLength}" style="filter: blur(10px);">${escapeHtml(essayText.substring(currentIndex))}</span>`;

    } else if (score >= 70 && highlightedOccurrences.length >= 3) {

      // Hella Sus: Blur text after the 3rd highlight with dynamic intensity

      const blurStyle = `filter: blur(${blurIntensity}px);`;

      result += `<span class="blurred-essay-text" data-blur-start="${blurStartIndex}" data-blur-length="${blurredTextLength}" style="${blurStyle}">${escapeHtml(essayText.substring(currentIndex))}</span>`;

    } else {

      // If no highlights or not in range, show remaining text normally

      result += escapeHtml(essayText.substring(currentIndex));

    }

  }



  // If no highlights at all, just show the text normally

  if (highlightedOccurrences.length === 0) {

    highlightedEssay = escapeHtml(essayText);

    console.log('ðŸ“ [DEBUG] No highlights found, using plain escaped text');

  } else {

    highlightedEssay = result;

    console.log('ðŸ“ [DEBUG] Highlights found, using result with', highlightedOccurrences.length, 'highlights');

  }



  // CRITICAL: Ensure highlightedEssay is never empty

  if (!highlightedEssay || highlightedEssay.trim().length === 0) {

    console.warn('âš ï¸ [DEBUG] highlightedEssay is empty! Using fallback');

    highlightedEssay = escapeHtml(essayText || 'Essay text not available');

  }



  console.log('ðŸ“ [DEBUG] Final highlightedEssay length:', highlightedEssay.length);

  console.log('ðŸ“ [DEBUG] highlightedEssay preview (first 200 chars):', highlightedEssay.substring(0, 200));

  console.log('ðŸ“ [DEBUG] highlightedOccurrences.length:', highlightedOccurrences.length);

  console.log('ðŸ“ [DEBUG] triggerTexts.length:', triggerTexts.length);

  console.log('ðŸ“ [DEBUG] essayText length:', essayText.length);



  // 5. Create the interactive essay box content (triggerPillsCard already found above)

  // 6. Create the interactive essay box content

  const essayBoxContent = `

    <div style="

      background: white;

      border: 2px solid ${score >= 70 ? '#dc2626' : score >= 30 ? '#f59e0b' : '#10b981'};

      border-radius: 16px;

      padding: 30px;

      margin: 30px 0;

      box-shadow: 0 10px 40px rgba(0,0,0,0.08);

      position: relative;

      overflow: hidden;

    ">

      <!-- Score Badge -->

      <div style="

        position: absolute;

        top: 20px;

        right: 20px;

        background: ${score >= 70 ? '#dc2626' : score >= 30 ? '#f59e0b' : '#10b981'};

        color: white;

        padding: 8px 16px;

        border-radius: 20px;

        font-weight: 800;

        font-size: 14px;

        z-index: 2;

      ">

        ${score >= 70 ? 'Major Sus' : score >= 30 ? 'Mid Sus' : 'Low Sus'}

      </div>



      <!-- Header -->

      <div style="

        text-align: center;

        margin-bottom: 25px;

        padding-bottom: 20px;

        border-bottom: ${score < 30 ? 'none' : '2px solid #f3f4f6'};

      ">

        <h2 style="color: #0b0646; margin: 0 0 16px 0; font-size: 28px; font-weight: 800;">

          ${triggers && Array.isArray(triggers) ? triggers.length : triggerTexts.length} AI Trigger Words Detected ${score >= 70 ? 'ðŸš©' : score >= 30 ? 'âš ï¸' : 'âœ“'}

        </h2>

        ${score < 30 ? `

        <!-- Clean: Simple message -->

        <p style="color: #6b7280; margin: 0 0 12px 0; font-size: 14px; font-weight: 500; line-height: 1.5;">

          No AI-trigger words detected. Your essay is ready to turn in!

        </p>

        ` : `

        <p style="color: #6b7280; margin: 0 0 12px 0; font-size: 14px; font-weight: 500; line-height: 1.5;">

          These are the first 3 high AI trigger words that might trigger AI detectors. Unlock to see all triggers found.

        </p>

        `}

        <h3 style="color: #9ca3af; margin: 0; padding-top: 12px; font-size: 14px; font-weight: 500;">

          YOUR ESSAY PREVIEW

        </h3>

      </div>



      <!-- Flagged Words Section - HIDDEN for Clean -->

      ${score >= 30 ? `

      <div style="text-align: center; margin-bottom: 20px;">

        <h4 style="color: #0b0646; margin: 0 0 8px 0; font-size: 20px; font-weight: 700;">

          Flagged Words

        </h4>

        <p style="color: #6b7280; margin: 0; font-size: 12px; font-style: italic; line-height: 1.4;">

          Hover over highlighted words in your essay to see why they were flagged

        </p>

      </div>

      ` : ''}



      <!-- Highlighted Essay - DIFFERENT STYLING FOR CLEAN (< 30) -->

      ${score < 30 ? `

      <!-- Clean Essay Box - Simple white with green border (matching image 1) -->

      <div id="cleanEssayBoxContent" style="

        background: white;

        border: 2px solid #10b981;

        border-radius: 8px;

        padding: 20px;

        margin-bottom: 20px;

        line-height: 1.8;

        font-size: 16px;

        color: #374151;

        font-family: 'Georgia', 'Times New Roman', serif;

        text-align: center;

      " data-full-text="${escapeHtml(essayText)}">

        ${highlightedEssay}

      </div>



      <!-- Copy Button for Clean -->

      <div style="text-align: center; margin: 0 0 20px 0;">

        <button onclick="copyCleanEssayFromBox()" style="

          background: #10b981;

          color: white;

          border: none;

          border-radius: 8px;

          padding: 12px 24px;

          font-size: 16px;

          font-weight: 700;

          cursor: pointer;

          width: 100%;

          transition: all 0.2s;

        " onmouseover="this.style.background='#059669';" onmouseout="this.style.background='#10b981';">

          âœ… Copy & Turn It In

        </button>

      </div>

      ` : `

      <!-- Kinda Sus / Hella Sus Essay Box - Original styling -->

      <div style="

        background: #f9fafb;

        border: 1px solid #e5e7eb;

        border-radius: 12px;

        padding: 30px;

        line-height: 1.9;

        font-size: 17px;

        max-height: 450px;

        margin-bottom: 35px;

        font-family: 'Georgia', 'Times New Roman', serif;

        position: relative;

        display: flex;

        flex-direction: column;

      ">

        <div style="flex: 1; overflow-y: auto; position: relative;">

        ${highlightedEssay}



        <!-- Watermark overlay for free users -->

        <div style="

          position: absolute;

          top: 0;

          left: 0;

          right: 0;

          bottom: 0;

          background: linear-gradient(to bottom, transparent 90%, rgba(249, 250, 251, 0.9) 100%);

          pointer-events: none;

        "></div>

        </div>



        ${(score >= 30 && score < 70 && highlightedOccurrences.length >= 1) || (score >= 70 && highlightedOccurrences.length >= 3) ? `

        <!-- Unlock All Fixes CTAs - Inside box, below blurred content -->

        <div style="

          position: relative;

          z-index: 15;

          padding-top: 20px;

          padding-bottom: 10px;

          background: #f9fafb;

          border-top: 1px solid #e5e7eb;

        ">

          <!-- Lock emoji centered above "Unlock All Fixes" heading -->

          <div style="

            text-align: center;

            margin-bottom: 12px;

          ">

            <span style="

              font-size: 60px;

              opacity: 0.7;

              color: ${score >= 70 ? '#dc2626' : score >= 30 ? '#f59e0b' : '#9ca3af'};

              display: inline-block;

            ">ðŸ”’</span>

          </div>

          <h3 style="font-size: 20px; font-weight: 700; margin: 0 0 16px 0; line-height: 1.3; color: #1f2937; text-align: center;">Unlock All Fixes</h3>



          <!-- QuickFix and Pro CTAs side by side -->

          <div style="display: flex; gap: 12px; flex-wrap: wrap; justify-content: center;">

            <!-- QuickFix CTA -->

            <div style="flex: 1; min-width: 200px; max-width: 280px;">

              <button onclick="handleQuickFixClick()" style="background: #ff6b00; color: white; border: none; padding: 14px 20px; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; transition: transform 0.2s; box-shadow: 0 4px 12px rgba(255, 107, 0, 0.3);" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">

                <span>âš¡</span>

                <span>QuickFix - $1.99</span>

              </button>

            </div>



            <!-- Pro CTA -->

            <div style="flex: 1; min-width: 200px; max-width: 280px;">

              <button onclick="if(typeof window.handleProUpgrade === 'function') { window.handleProUpgrade(); } else if(typeof handleProUpgrade === 'function') { handleProUpgrade(); } else { console.error('handleProUpgrade not found'); }" style="background: linear-gradient(to bottom, #00a8e8, #0b0646); color: white; border: none; padding: 14px 20px; border-radius: 8px; font-weight: 700; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; transition: transform 0.2s; box-shadow: 0 4px 12px rgba(0, 153, 221, 0.3);" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">

                <span>ðŸ’Ž</span>

                <span>Go Pro - $9.99/mo</span>

              </button>

            </div>

          </div>

        </div>

        ` : ''}

      </div>

      `}



      <!-- Warning/Info Footer - HIDDEN for Clean (< 30), shown for Kinda Sus and Hella Sus -->

      ${score >= 30 ? `

      <div style="

        margin-top: 25px;

        padding: 18px;

        background: ${score >= 70 ? '#fef2f2' : '#fffbeb'};

        border-radius: 10px;

        border: 1px solid ${score >= 70 ? '#fecaca' : '#fbbf24'};

        color: ${score >= 70 ? '#7f1d1d' : '#92400e'};

        font-size: 14px;

        text-align: center;

      ">

        <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 8px;">

          <span style="font-size: 18px;">${score >= 70 ? 'ðŸš©' : 'âš ï¸'}</span>

          ${score >= 70 ? 

            '<strong>These phrases are gonna get you flagged fr fr. Turnitin\'s catching this. Swap them.</strong>' :

            '<strong>These words are sus. Reword them before Turnitin catches it. You got this though.</strong>'

          }

        </div>

      </div>

      ` : ''}

    </div>

  `;



  // Insert into page - Insert AFTER the kindaSusCard or hellaSusCard

  // Remove any existing interactive essay boxes first to prevent duplicates

  document.querySelectorAll('.interactive-essay-box, #freeEssayPreviewBox').forEach(el => {

    console.log('ðŸ—‘ï¸ Removing existing essay box:', el.id || el.className);

    el.remove();

  });



  // Find the visible card (kindaSusCard or hellaSusCard)

  const kindaSusCard = document.getElementById('kindaSusCard');

  const hellaSusCard = document.getElementById('hellaSusCard');



  // Determine which card is visible

  let targetCard = null;

  if (hellaSusCard && window.getComputedStyle(hellaSusCard).display !== 'none') {

    targetCard = hellaSusCard;

    console.log('âœ… Found visible hellaSusCard');

  } else if (kindaSusCard && window.getComputedStyle(kindaSusCard).display !== 'none') {

    targetCard = kindaSusCard;

    console.log('âœ… Found visible kindaSusCard');

  }



  if (!targetCard) {

    console.error('âŒ Neither kindaSusCard nor hellaSusCard is visible!');

    console.log('kindaSusCard display:', kindaSusCard ? window.getComputedStyle(kindaSusCard).display : 'NOT FOUND');

    console.log('hellaSusCard display:', hellaSusCard ? window.getComputedStyle(hellaSusCard).display : 'NOT FOUND');



    // Last resort: try resultsContainer

    const resultsContainer = document.getElementById('resultsContainer');

    if (resultsContainer) {

      const newCard = document.createElement('div');

      newCard.className = 'card interactive-essay-box';

      newCard.style.cssText = 'padding: 0; margin-bottom: 20px; display: block !important; visibility: visible !important; opacity: 1 !important;';

      newCard.innerHTML = essayBoxContent;

      resultsContainer.appendChild(newCard);

      console.log('âœ… Interactive essay box inserted into resultsContainer (fallback)');



      setTimeout(() => {

        newCard.scrollIntoView({ behavior: 'smooth', block: 'start' });

      }, 100);

      return;

    } else {

      console.error('âŒ Could not find any insertion point for interactive essay box');

      return;

    }

  }



  // Create new card element

  const newCard = document.createElement('div');

  newCard.className = 'card interactive-essay-box';

  newCard.style.cssText = 'padding: 0; margin-bottom: 20px; display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 100 !important;';

  newCard.innerHTML = essayBoxContent;



  // Insert AFTER the target card

  if (targetCard.parentNode) {

    if (targetCard.nextSibling) {

      targetCard.parentNode.insertBefore(newCard, targetCard.nextSibling);

    } else {

      targetCard.parentNode.appendChild(newCard);

    }

    console.log('âœ… Interactive essay box inserted after', targetCard.id);

  } else {

    console.error('âŒ targetCard has no parent node!');

    return;

  }



  // Verify it was actually inserted

  const insertedBox = document.querySelector('.interactive-essay-box');

  if (insertedBox) {

    console.log('âœ… SUCCESS: Essay box exists in DOM');

    console.log('Box HTML length:', insertedBox.outerHTML.length);

    console.log('Box computed display:', window.getComputedStyle(insertedBox).display);

    console.log('Box computed visibility:', window.getComputedStyle(insertedBox).visibility);

    console.log('Box computed opacity:', window.getComputedStyle(insertedBox).opacity);

    console.log('Box offsetHeight:', insertedBox.offsetHeight);

    console.log('Box offsetWidth:', insertedBox.offsetWidth);

  } else {

    console.error('âŒ FAILED: Essay box was not inserted into DOM');

  }



  // Scroll to the essay box

  setTimeout(() => {

    newCard.scrollIntoView({ behavior: 'smooth', block: 'start' });

  }, 100);

}



// Helper functions

function escapeRegExp(string) {

  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

}



function escapeHtml(text) {

  const div = document.createElement('div');

  div.textContent = text;

  return div.innerHTML;

}



// Copy function for Clean essay box

function copyCleanEssayFromBox() {

  const cleanBox = document.getElementById('cleanEssayBoxContent');

  let textToCopy = '';



  if (cleanBox) {

    textToCopy = cleanBox.getAttribute('data-full-text') || '';

  }



  if (!textToCopy || textToCopy.trim() === '') {

    textToCopy = appState.originalText || appState.lastScanData?.essayText || '';

  }



  if (!textToCopy || textToCopy.trim() === '') {

    const essayInput = document.getElementById('essayInput');

    if (essayInput && essayInput.value) {

      textToCopy = essayInput.value;

    }

  }



  if (textToCopy && textToCopy.trim()) {

    navigator.clipboard.writeText(textToCopy).then(() => {

      if (typeof showSuccessMessage === 'function') {

        showSuccessMessage('âœ… Essay copied to clipboard!', '#10b981');

      }

    }).catch(err => {

      console.error('Failed to copy:', err);

      if (typeof showSuccessMessage === 'function') {

        showSuccessMessage('âŒ Failed to copy. Please try again.', '#dc2626');

      }

    });

  } else {

    console.error('No essay text found to copy');

    if (typeof showSuccessMessage === 'function') {

      showSuccessMessage('âŒ No essay text found to copy', '#dc2626');

    }

  }

}



// Tooltip functions

window.showHighlightTooltip = function(event, trigger) {

  const tooltip = event.target.querySelector('.highlight-tooltip');

  if (tooltip) {

    tooltip.style.display = 'block';

    tooltip.textContent = `Click for "${trigger}" suggestions (Pro)`;

  }

};



window.hideHighlightTooltip = function() {

  document.querySelectorAll('.highlight-tooltip').forEach(t => t.style.display = 'none');

};



// New trigger tooltip functions - Match QuickFix styling exactly

window.showTriggerTooltip = function(event, tooltipText) {

  // Get or create tooltip element (same as QuickFix)

  let tooltip = document.getElementById('freeTriggerTooltip');

  if (!tooltip) {

    tooltip = document.createElement('div');

    tooltip.id = 'freeTriggerTooltip';

    tooltip.className = 'tooltip';

    document.body.appendChild(tooltip);

  }



  // Determine border color based on score (match QuickFix logic)

  let borderColor = '#dc2626'; // Default red for high risk

  const mark = event.target.closest('.ai-highlight') || event.target;

  if (mark) {

    // Try to get score from appState or determine from context

    const score = appState?.lastScanData?.score || appState?.apiResponse?.textRisk || 70;

    if (score < 30) {

      borderColor = '#2ecc71'; // Green

    } else if (score >= 30 && score < 70) {

      borderColor = '#f59e0b'; // Amber

    } else {

      borderColor = '#dc2626'; // Red

    }

  }



  // Set tooltip content and styling (exact match to QuickFix)

  tooltip.textContent = tooltipText;

  tooltip.style.background = 'white';

  tooltip.style.color = '#1e3a8a';

  tooltip.style.borderLeft = `4px solid ${borderColor}`;

  tooltip.style.borderRight = `4px solid ${borderColor}`;

  tooltip.style.borderTop = 'none';

  tooltip.style.borderBottom = 'none';

  tooltip.style.padding = '12px 16px';

  tooltip.style.borderRadius = '8px';

  tooltip.style.fontSize = '13px';

  tooltip.style.fontWeight = '600';

  tooltip.style.maxWidth = '280px';

  tooltip.style.zIndex = '10000';

  tooltip.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';

  tooltip.style.pointerEvents = 'none';

  tooltip.style.display = 'block';

  tooltip.style.lineHeight = '1.5';

  tooltip.style.textAlign = 'center';

  tooltip.style.wordWrap = 'break-word';

  tooltip.classList.add('show');



  // Position tooltip (same as QuickFix)

  const rect = event.target.getBoundingClientRect();

  const tooltipRect = tooltip.getBoundingClientRect();

  let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);

  let top = rect.top - tooltipRect.height - 10;



  // Keep tooltip within viewport

  if (left < 10) left = 10;

  if (left + tooltipRect.width > window.innerWidth - 10) {

    left = window.innerWidth - tooltipRect.width - 10;

  }

  if (top < 10) {

    top = rect.bottom + 10;

  }



  tooltip.style.left = left + 'px';

  tooltip.style.top = top + 'px';

};



window.hideTriggerTooltip = function() {

  const tooltip = document.getElementById('freeTriggerTooltip');

  if (tooltip) {

    tooltip.classList.remove('show');

    tooltip.style.display = 'none';

  }

};



// Paywall trigger function

window.showPaywallForTrigger = function(trigger) {

  showPaywallModal(`See replacement suggestions for "${trigger}" and fix it automatically.`);

};



// ========= PAYWALL MODAL =========

function showPaywallModal(message = 'Upgrade to access this feature') {

  console.log('ðŸ’° PAYWALL MODAL:', message);



  // Remove any existing paywall modal

  document.querySelectorAll('.paywall-modal').forEach(el => el.remove());



  // Create modal

  const modal = document.createElement('div');

  modal.className = 'paywall-modal';



  // Add responsive styles and positioning

  const style = document.createElement('style');

  style.id = 'paywall-modal-responsive-styles';

  style.textContent = `

    @keyframes rotate {

      from {

        transform: rotate(0deg);

      }

      to {

        transform: rotate(360deg);

      }

    }

    .paywall-modal {

      position: fixed !important;

      top: 0 !important;

      left: 0 !important;

      width: 100% !important;

      height: 100% !important;

      z-index: 10000 !important;

      pointer-events: none !important;

    }

    .paywall-modal > div {

      pointer-events: auto !important;

    }

    @media (max-width: 768px) {

      .paywall-pricing-tiers {

        flex-direction: column !important;

      }

      .paywall-tier-card {

        min-width: 100% !important;

      }

    }

  `;

  document.head.appendChild(style);



  modal.innerHTML = `

    <div style="

      position: fixed !important;

      top: 50% !important;

      left: 50% !important;

      transform: translate(-50%, -50%) !important;

      background: white;

      border-radius: 16px;

      padding: 0;

      z-index: 10002 !important;

      width: 90%;

      max-width: 900px;

      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);

      overflow: hidden;

      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

      max-height: 85vh;

      overflow-y: auto;

    ">

      <!-- Close Button (X) -->

      <button onclick="closePaywallModal()" style="

        position: absolute;

        top: 12px;

        right: 12px;

        background: transparent;

        border: none;

        font-size: 28px;

        color: white;

        cursor: pointer;

        width: auto;

        height: auto;

        line-height: 1;

        transition: all 0.2s;

        display: flex;

        align-items: center;

        justify-content: center;

        font-weight: 400;

        z-index: 10;

        padding: 8px;

      " onmouseover="this.style.opacity='0.7';" onmouseout="this.style.opacity='1';">Ã—</button>



      <!-- Header Banner -->

      <div style="

        background: linear-gradient(135deg, #3b82f6, #1d4ed8);

        color: white;

        padding: 20px 40px;

        text-align: center;

      ">

        <p style="

          margin: 0 0 16px 0;

          font-size: 16px;

          font-weight: 600;

          opacity: 0.95;

        ">Don't let false flags ruin your essay. Fix it now before you submit.</p>

      </div>



      <!-- Main Content -->

      <div style="padding: 40px;">

        <!-- Title & Subtitle -->

        <div style="text-align: center; margin-bottom: 35px;">

          <!-- Rotating Logo -->

          <img src="https://i.postimg.cc/hPKB2kRp/Final-site-icon-trans.png" alt="False Flag Fixer Logo" style="

            width: 80px;

            height: 80px;

            margin: 0 auto 20px auto;

            display: block;

            animation: rotate 3s linear infinite;

          ">

          <h2 style="

            margin: 0 0 12px 0;

            font-size: 32px;

            font-weight: 700;

            font-family: 'Raleway', sans-serif;

            color: #1f2937;

            letter-spacing: -0.25px;

          ">Pick Your Fix</h2>

          <p style="

            margin: 0;

            font-size: 18px;

            font-weight: 500;

            color: #6b7280;

            line-height: 1.6;

            max-width: 600px;

            margin: 0 auto;

          ">Full protection from false AI flags â€” see your exact score, catch every trigger, and fix it before you turn it in</p>

        </div>



        <!-- Pricing Tiers (Side-by-Side) -->

        <div class="paywall-pricing-tiers" style="

          display: flex;

          gap: 24px;

          margin-bottom: 30px;

          flex-wrap: wrap;

        ">

          <!-- LEFT TIER - QuickFix -->

          <div class="paywall-tier-card" style="

            flex: 1;

            min-width: 300px;

            background: white;

            border: 2px solid #ea580c;

            border-radius: 16px;

            padding: 30px;

            text-align: center;

            box-shadow: 0 4px 12px rgba(234, 88, 12, 0.1);

          ">

            <div style="

              color: #ea580c;

              font-size: 14px;

              font-weight: 800;

              letter-spacing: 1px;

              margin-bottom: 16px;

            ">One-Time Fix</div>



            <div style="

              font-size: 48px;

              font-weight: 900;

              color: #ea580c;

              margin-bottom: 8px;

              line-height: 1;

            ">$1.99</div>



            <div style="

              color: #6b7280;

              font-size: 14px;

              margin-bottom: 24px;

            ">one-time payment</div>



            <div style="

              margin-bottom: 28px;

              text-align: left;

            ">

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                margin-bottom: 12px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>Upload or paste up to 1,500 words</span>

              </div>

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                margin-bottom: 12px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>One powerful AI fix</span>

              </div>

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                margin-bottom: 12px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>Get replacement suggestions</span>

              </div>

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>See your new score after fix</span>

              </div>

            </div>



            <button onclick="handleQuickFixPurchase()" style="

              background: #ea580c;

              color: white;

              border: none;

              padding: 16px 32px;

              border-radius: 12px;

              font-size: 16px;

              font-weight: 800;

              cursor: pointer;

              width: 100%;

              transition: all 0.2s;

              letter-spacing: 0.5px;

            " onmouseover="this.style.background='#c2410c'; this.style.transform='scale(1.02)'" onmouseout="this.style.background='#ea580c'; this.style.transform='scale(1)'">

              âš¡ Quick Fix Now

            </button>

          </div>



          <!-- RIGHT TIER - Pro -->

          <div class="paywall-tier-card" style="

            flex: 1;

            min-width: 300px;

            background: #f0f9ff;

            border: 2px solid #3b82f6;

            border-radius: 16px;

            padding: 30px;

            text-align: center;

            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.15);

            position: relative;

          ">

            <div style="

              position: absolute;

              top: 0;

              right: 0;

              background: linear-gradient(to bottom, #00a8e8, #0b0646);

              color: white;

              padding: 8px 20px;

              font-size: 12px;

              font-weight: 800;

              border-bottom-left-radius: 12px;

            ">Most Popular</div>



            <div style="

              color: #3b82f6;

              font-size: 14px;

              font-weight: 800;

              letter-spacing: 1px;

              margin-bottom: 16px;

              margin-top: 10px;

            ">Pro</div>



            <div style="

              font-size: 48px;

              font-weight: 900;

              color: #3b82f6;

              margin-bottom: 8px;

              line-height: 1;

            ">$9.99</div>



            <div style="

              color: #6b7280;

              font-size: 14px;

              margin-bottom: 24px;

            ">per month â€¢ cancel anytime</div>



            <div style="

              margin-bottom: 28px;

              text-align: left;

            ">

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                margin-bottom: 12px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>Upload or paste up to 1,500 words</span>

              </div>

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                margin-bottom: 12px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>Everything in QuickFix</span>

              </div>

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                margin-bottom: 12px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>100 scans/month</span>

              </div>

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                margin-bottom: 12px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>Advanced AI detection</span>

              </div>

              <div style="

                display: flex;

                align-items: center;

                gap: 10px;

                color: #374151;

                font-size: 14px;

              ">

                <span style="color: #10b981; font-weight: bold; font-size: 18px;">âœ“</span>

                <span>Priority support</span>

              </div>

            </div>



            <button onclick="handleProUpgrade()" style="

              background: linear-gradient(to bottom, #00a8e8, #0b0646);

              color: white;

              border: none;

              padding: 16px 32px;

              border-radius: 12px;

              font-size: 16px;

              font-weight: 800;

              cursor: pointer;

              width: 100%;

              transition: all 0.2s;

              letter-spacing: 0.5px;

            " onmouseover="this.style.background='linear-gradient(to bottom, #0087c4, #06082e)'; this.style.transform='scale(1.02)'" onmouseout="this.style.background='linear-gradient(to bottom, #00a8e8, #0b0646)'; this.style.transform='scale(1)'">

              ðŸš€ Go Pro Now

            </button>

          </div>

        </div>



        <!-- Footer -->

        <div style="

          text-align: center;

          padding-top: 24px;

          border-top: 1px solid #e5e7eb;

        ">

          <p style="

            margin: 0 0 16px 0;

            color: #6b7280;

            font-size: 14px;

          ">Join thousands of students using False Flag Fixerâ„¢ Pro <span style="color: #fbbf24; margin-left: 8px;">â˜…â˜…â˜…â˜…â˜…</span></p>

          <a href="javascript:void(0)" onclick="closePaywallModal()" style="

            color: #dc2626;

            text-decoration: underline;

            font-size: 14px;

            font-weight: 600;

            cursor: pointer;

          ">Nah I'm built different ðŸ’€</a>

        </div>

      </div>

    </div>



    <!-- Overlay -->

    <div style="

      position: fixed !important;

      top: 0 !important;

      left: 0 !important;

      right: 0 !important;

      bottom: 0 !important;

      width: 100% !important;

      height: 100% !important;

      background: rgba(0, 0, 0, 0.7) !important;

      backdrop-filter: blur(4px);

      z-index: 10001 !important;

    " onclick="closePaywallModal()"></div>

  `;



  // Add to page

  document.body.appendChild(modal);



  // Escape key to close

  const handleEscape = (e) => {

    if (e.key === 'Escape') closePaywallModal();

  };

  document.addEventListener('keydown', handleEscape);



  // Store cleanup function

  modal.cleanup = () => {

    document.removeEventListener('keydown', handleEscape);

    const styleEl = document.getElementById('paywall-modal-responsive-styles');

    if (styleEl) styleEl.remove();

  };

}



// Close function

window.closePaywallModal = function() {

  document.querySelectorAll('.paywall-modal').forEach(modal => {

    if (modal.cleanup) modal.cleanup();

    modal.remove();

  });

};



// Purchase handlers (stub functions)

window.handleQuickFixPurchase = function() {

  console.log('QuickFix purchase initiated');

  alert('QuickFix purchase flow would start here. In production, this would integrate with your payment processor.');

  closePaywallModal();

};



// Removed duplicate handleProUpgrade - using the one defined earlier at line 23294



// ========= PAGE VISIBILITY LISTENERS - Abort scan when user navigates away =========

// Abort local detection when page becomes hidden (user navigates away, switches tabs, etc.)

document.addEventListener('visibilitychange', function() {

  if (document.hidden) {

    console.log('ðŸ”„ Page hidden - aborting local detection');

    if (window._localDetectionAbortController) {

      try {

        window._localDetectionAbortController.abort();

        console.log('âœ… Aborted local detection due to page visibility change');

      } catch (e) {

        console.warn('âš ï¸ Error aborting local detection:', e);

      }

      window._localDetectionAbortController = null;

    }

    if (window._localDetectionTimeout) {

      clearTimeout(window._localDetectionTimeout);

      window._localDetectionTimeout = null;

    }

    // Reset scan flag

    window._scanInProgress = false;

  }

});



// Also abort on page unload (user closes tab, navigates away, etc.)

window.addEventListener('pagehide', function() {

  console.log('ðŸ”„ Page unloading - aborting local detection');

  if (window._localDetectionAbortController) {

    try {

      window._localDetectionAbortController.abort();

    } catch (e) {}

    window._localDetectionAbortController = null;

  }

  if (window._localDetectionTimeout) {

    clearTimeout(window._localDetectionTimeout);

    window._localDetectionTimeout = null;

  }

  window._scanInProgress = false;

});



// Abort on beforeunload as well (extra safety)

window.addEventListener('beforeunload', function() {

  if (window._localDetectionAbortController) {

    try {

      window._localDetectionAbortController.abort();

    } catch (e) {}

  }

  if (window._localDetectionTimeout) {

    clearTimeout(window._localDetectionTimeout);

  }

  window._scanInProgress = false;

});



</script>



<!-- Rescan Comparison Modal - Direct child of body, always accessible -->

<div id="rescanComparisonModal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.6); z-index: 99999; backdrop-filter: blur(4px);">

  <div id="rescanComparisonModalContent" style="background: white; border-radius: 16px; padding: 32px; max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); z-index: 100000;">

    <!-- Close Button -->

    <button onclick="closeRescanComparisonModal()" style="position: absolute; top: 16px; right: 16px; background: none; border: none; font-size: 28px; color: #6b7280; cursor: pointer; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 50%;" onmouseover="this.style.background='#f3f4f6';" onmouseout="this.style.background='none';">Ã—</button>



    <!-- Header -->

    <h2 style="font-size: 24px; font-weight: 700; color: #1f2937; margin: 0 0 24px 0; text-align: center;">Rescan Complete</h2>



    <!-- Before/After Scores -->

    <div style="display: flex; gap: 20px; justify-content: center; margin-bottom: 24px;">

      <div style="text-align: center;">

        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">Before Score</div>

        <div id="rescanBeforeScore" style="font-size: 36px; font-weight: 700; color: #374151;">0%</div>

      </div>

      <div style="display: flex; align-items: center; font-size: 24px; color: #6b7280;">â†’</div>

      <div style="text-align: center;">

        <div style="font-size: 12px; color: #6b7280; margin-bottom: 8px;">After Score</div>

        <div id="rescanAfterScore" style="font-size: 36px; font-weight: 700; color: #10b981;">0%</div>

      </div>

    </div>



    <!-- Buttons -->

    <div style="display: flex; flex-direction: column; gap: 12px;">

      <button onclick="viewFullResultsFromRescanModal()" style="width: 100%; padding: 14px 24px; font-size: 16px; font-weight: 700; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer;" onmouseover="this.style.background='#059669';" onmouseout="this.style.background='#10b981';">

        âœ… View Full Results

      </button>

      <button id="rescanModalEditMoreBtn" onclick="closeRescanComparisonModalAndFocusEdit()" style="width: 100%; padding: 14px 24px; font-size: 16px; font-weight: 700; background: white; color: #00a8e8; border: 2px solid #00a8e8; border-radius: 8px; cursor: pointer; display: none;" onmouseover="this.style.background='#f0f9ff';" onmouseout="this.style.background='white';">

        âœï¸ Edit More

      </button>

    </div>

  </div>

</div>

















<script>
// ============================================
// ULTIMATE TEXTAREA WORD LIMIT ENFORCEMENT
// Handles: Typing, Pasting, Editing, Uploads
// ============================================

class WordLimitEnforcer {
  constructor(config) {
    this.textarea = document.getElementById(config.id);
    this.counter = document.getElementById(config.counterId);
    this.limit = config.limit;
    this.name = config.name;
    
    if (!this.textarea) return;
    
    this.init();
  }
  
  init() {
    console.log(`ðŸ”’ Initializing ${this.name} (${this.limit} words)`);
    
    this.textarea.removeAttribute('oninput');
    this.textarea.removeAttribute('onkeydown');
    this.textarea.removeAttribute('onpaste');
    this.textarea.removeAttribute('onkeyup');
    
    this.lastValue = this.textarea.value;
    this.lastWordCount = this.countWords(this.textarea.value);
    
    this.setupEvents();
    this.updateCounter();
    
    console.log(`âœ… ${this.name} ready`);
  }
  
  countWords(text) {
    if (!text || !text.trim()) return 0;
    return text.trim().split(/\s+/).filter(w => w.length > 0).length;
  }
  
  getCurrentState() {
    return {
      value: this.textarea.value,
      wordCount: this.countWords(this.textarea.value),
      cursorPos: this.textarea.selectionStart,
      selectionEnd: this.textarea.selectionEnd,
      hasSelection: this.textarea.selectionStart !== this.textarea.selectionEnd
    };
  }
  
  updateCounter() {
    const state = this.getCurrentState();
    
    if (this.counter) {
      this.counter.textContent = state.wordCount.toLocaleString();
      
      if (state.wordCount >= this.limit) {
        this.counter.style.color = '#dc2626';
        this.counter.style.fontWeight = '700';
        this.textarea.style.borderColor = '#dc2626';
        this.textarea.style.boxShadow = '0 0 0 2px rgba(220, 38, 38, 0.2)';
      } else if (state.wordCount >= this.limit * 0.9) {
        this.counter.style.color = '#f59e0b';
        this.counter.style.fontWeight = '600';
        this.textarea.style.borderColor = '#f59e0b';
        this.textarea.style.boxShadow = 'none';
      } else {
        this.counter.style.color = '#6b7280';
        this.counter.style.fontWeight = '400';
        this.textarea.style.borderColor = '#e5e7eb';
        this.textarea.style.boxShadow = 'none';
      }
    }
    
    this.lastValue = state.value;
    this.lastWordCount = state.wordCount;
    return state.wordCount;
  }
  
  truncateToLimit(text) {
    const words = text.trim().split(/\s+/);
    if (words.length <= this.limit) return text;
    
    let result = '';
    let charIndex = 0;
    let wordCount = 0;
    const regex = /\S+/g;
    let match;
    
    while ((match = regex.exec(text)) !== null && wordCount < this.limit) {
      const word = match[0];
      const wordStart = match.index;
      const wordEnd = wordStart + word.length;
      
      if (wordCount === 0) {
        result = text.substring(0, wordEnd);
      } else {
        const whitespace = text.substring(charIndex, wordStart);
        result += whitespace + word;
      }
      
      charIndex = wordEnd;
      wordCount++;
    }
    
    return result;
  }
  
  setupEvents() {
    // INPUT EVENT
    this.textarea.addEventListener('input', (e) => {
      const state = this.getCurrentState();
      
      if (state.wordCount > this.limit) {
        console.log(`âœ‚ï¸ ${this.name}: Truncating from ${state.wordCount} to ${this.limit} words`);
        this.textarea.value = this.truncateToLimit(state.value);
        
        setTimeout(() => {
          const newLength = this.textarea.value.length;
          const newPos = Math.min(state.cursorPos, newLength);
          this.textarea.setSelectionRange(newPos, newPos);
        }, 0);
      }
      
      this.updateCounter();
    });
    
    // KEYDOWN EVENT
    this.textarea.addEventListener('keydown', (e) => {
      const state = this.getCurrentState();
      
      if (state.wordCount >= this.limit) {
        const key = e.key;
        const keyCode = e.keyCode || e.which;
        
        const allowedKeys = ['Backspace', 'Delete', 'Tab', 'Enter', 'Escape',
          'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
          'Home', 'End', 'PageUp', 'PageDown', 'Shift', 'Control', 'Alt', 'Meta'];
        
        const allowedKeyCodes = [8, 46, 9, 13, 27, 37, 38, 39, 40, 36, 35, 33, 34, 16, 17, 18, 91];
        
        if (e.ctrlKey || e.metaKey || e.altKey) return true;
        if (keyCode >= 112 && keyCode <= 123) return true;
        if (allowedKeys.includes(key) || allowedKeyCodes.includes(keyCode)) return true;
        
        if (state.hasSelection) {
          const before = state.value.substring(0, state.cursorPos);
          const after = state.value.substring(state.selectionEnd);
          const newText = before + key + after;
          const newWordCount = this.countWords(newText);
          
          if (newWordCount <= this.limit) return true;
        }
        
        console.log(`ðŸš« ${this.name}: Blocked "${key}" (at ${state.wordCount}/${this.limit} words)`);
        e.preventDefault();
        return false;
      }
      
      return true;
    });
    
    // PASTE EVENT
    this.textarea.addEventListener('paste', (e) => {
      e.preventDefault();
      
      const pastedText = e.clipboardData.getData('text');
      if (!pastedText.trim()) return;
      
      const state = this.getCurrentState();
      
      let baseText;
      if (state.hasSelection) {
        baseText = state.value.substring(0, state.cursorPos) + state.value.substring(state.selectionEnd);
      } else {
        baseText = state.value;
      }
      
      const baseWordCount = this.countWords(baseText);
      const availableWords = this.limit - baseWordCount;
      
      if (availableWords <= 0) {
        console.log(`ðŸš« ${this.name}: No space for paste`);
        return;
      }
      
      let newText;
      if (state.hasSelection) {
        newText = state.value.substring(0, state.cursorPos) + pastedText + state.value.substring(state.selectionEnd);
      } else {
        newText = state.value.substring(0, state.cursorPos) + pastedText + state.value.substring(state.cursorPos);
      }
      
      const newWordCount = this.countWords(newText);
      
      if (newWordCount <= this.limit) {
        this.textarea.value = newText;
        console.log(`âœ… ${this.name}: Pasted ${this.countWords(pastedText)} words`);
      } else {
        console.log(`âœ‚ï¸ ${this.name}: Partial paste (${availableWords} words available)`);
        
        const pastedWords = pastedText.trim().split(/\s+/).filter(w => w.length > 0);
        const allowedWords = pastedWords.slice(0, availableWords);
        const truncatedPaste = allowedWords.join(' ');
        
        if (state.hasSelection) {
          this.textarea.value = state.value.substring(0, state.cursorPos) + truncatedPaste + state.value.substring(state.selectionEnd);
        } else {
          this.textarea.value = state.value.substring(0, state.cursorPos) + truncatedPaste + state.value.substring(state.cursorPos);
        }
      }
      
      this.updateCounter();
      
      setTimeout(() => {
        this.textarea.focus();
      }, 0);
    });
    
    // BLUR EVENT
    this.textarea.addEventListener('blur', () => {
      const state = this.getCurrentState();
      if (state.wordCount > this.limit) {
        this.textarea.value = this.truncateToLimit(state.value);
        this.updateCounter();
      }
    });
  }
  
  setValue(text) {
    const truncated = this.truncateToLimit(text);
    this.textarea.value = truncated;
    this.updateCounter();
    return truncated;
  }
  
  getValue() { return this.textarea.value; }
  getWordCount() { return this.countWords(this.textarea.value); }
}

// MAIN INITIALIZATION
document.addEventListener('DOMContentLoaded', function() {
  console.log('ðŸš€ Ultimate Word Limit Enforcer initializing...');
  
  const enforcers = [
    new WordLimitEnforcer({ id: 'essayInput', limit: 1500, counterId: 'charCount', name: 'Free Scan' }),
    new WordLimitEnforcer({ id: 'proScanInput', limit: 1500, counterId: 'proScanCharCount', name: 'Pro Scan' }),
    new WordLimitEnforcer({ id: 'quickfixEssayInput', limit: 1500, counterId: 'quickfixFlowCharCount', name: 'QuickFix' })
  ].filter(e => e.textarea);
  
  console.log(`âœ… ${enforcers.length} textareas initialized`);
  
  // Make enforcers globally accessible
  window.wordLimitEnforcers = enforcers;
  
  // Debug function
  window.debugWordLimits = function() {
    console.log('ðŸ” WORD LIMIT DEBUG:');
    enforcers.forEach(enforcer => {
      const count = enforcer.getWordCount();
      const atLimit = count >= enforcer.limit;
      console.log(`  ${enforcer.name}: ${count}/${enforcer.limit} words ${atLimit ? 'ðŸš«' : 'âœ…'}`);
    });
  };
  
  window.forceTruncateAll = function() {
    enforcers.forEach(enforcer => {
      const current = enforcer.getValue();
      const truncated = enforcer.truncateToLimit(current);
      if (current !== truncated) {
        enforcer.setValue(truncated);
        console.log(`âœ‚ï¸ ${enforcer.name}: Force truncated`);
      }
    });
  };
  
  // Safety watchdog - every 500ms
  setInterval(() => {
    enforcers.forEach(enforcer => {
      if (enforcer.getWordCount() > enforcer.limit) {
        console.error(`ðŸš¨ EMERGENCY: ${enforcer.name} over limit! Force truncating...`);
        enforcer.setValue(enforcer.getValue());
      }
    });
  }, 500);
  
  console.log('ðŸŽ‰ ALL word limit systems ready!');
  console.log('ðŸ’¡ Tip: Run debugWordLimits() in console to check all textareas');
});
</script>

<!-- Pro Priority AI Chat Support Widget -->
<div id="proChatWidget" style="display: none; position: fixed; bottom: 20px; right: 20px; z-index: 10000;">
  <div style="width: 360px; height: 520px; background: white; border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden;">
    
    <!-- Chat Header -->
    <div style="background: linear-gradient(135deg, #00a8e8, #0b0646); color: white; padding: 16px; display: flex; justify-content: space-between; align-items: center;">
      <div style="display: flex; align-items: center; gap: 10px;">
        <span style="font-size: 24px;">ðŸ’Ž</span>
        <div>
          <h4 style="margin: 0; font-size: 16px; font-weight: 700;">Pro Priority Support</h4>
          <p style="margin: 2px 0 0 0; font-size: 11px; opacity: 0.9;">AI-powered â€¢ 24/7 â€¢ Instant</p>
        </div>
      </div>
      <button onclick="window.proChatSupport.toggleChat()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 18px; cursor: pointer; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">Ã—</button>
    </div>
    
    <!-- Chat Messages -->
    <div id="chatMessages" style="flex: 1; padding: 16px; overflow-y: auto; background: #f8f9fa;">
      <!-- Welcome message will be inserted by JS -->
    </div>
    
    <!-- Chat Input -->
    <div style="padding: 12px 16px; border-top: 1px solid #e5e7eb; background: white;">
      <div style="display: flex; gap: 8px;">
        <input 
          id="chatInput" 
          type="text" 
          placeholder="Ask about False Flag Fixer..." 
          maxlength="800"
          style="flex: 1; padding: 12px 16px; border: 1px solid #d1d5db; border-radius: 24px; font-size: 14px; outline: none;"
          onkeypress="if(event.key==='Enter')window.proChatSupport.sendMessage()"
        >
        <button 
          onclick="window.proChatSupport.sendMessage()"
          style="background: linear-gradient(135deg, #00a8e8, #0b0646); color: white; border: none; border-radius: 50%; width: 44px; height: 44px; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"
        >
          âž¤
        </button>
      </div>
      <p id="chatWordCount" style="font-size: 10px; color: #9ca3af; margin: 6px 0 0 0; text-align: center;">
        ðŸ’Ž Pro feature â€¢ 150 word limit per message
      </p>
    </div>
  </div>
</div>

<!-- Chat Toggle Button -->
<button id="chatToggleBtn" onclick="window.proChatSupport.toggleChat()" style="display: none; position: fixed; bottom: 20px; right: 20px; z-index: 9999; background: linear-gradient(135deg, #00a8e8, #0b0646); color: white; border: none; border-radius: 50%; width: 60px; height: 60px; font-size: 28px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,168,232,0.3); transition: transform 0.2s;">
  ðŸ’¬
</button>

<script>
// ============================================
// PRO CHAT SUPPORT CLASS
// ============================================
class ProChatSupport {
  constructor() {
    this.isOpen = false;
    this.isProUser = false;
    this.messageHistory = [];
    this.maxWords = 150;
  }
  
  initialize() {
    console.log('ðŸ’¬ Pro Chat Support initializing...');
    this.checkProStatus();
    
    if (this.isProUser) {
      this.showToggleButton();
      this.addWelcomeMessage();
      console.log('âœ… Pro Chat Support ready for Pro user');
    } else {
      console.log('â„¹ï¸ Pro Chat hidden (user is not Pro)');
    }
    
    // Add word count listener to input
    const input = document.getElementById('chatInput');
    if (input) {
      input.addEventListener('input', () => this.updateWordCount());
    }
  }
  
  checkProStatus() {
    // Production verification - stricter on custom domains
    const hostname = window.location.hostname;
    const isDevEnvironment = hostname.includes('replit.dev') || 
                            hostname.includes('replit.app') || 
                            hostname.includes('localhost') ||
                            hostname === '127.0.0.1';
    
    // Method 1: Check localStorage
    const isPro = localStorage.getItem('fff_pro_user') === 'true';
    
    // Method 2: Check URL parameter (for testing - dev only)
    const urlParams = new URLSearchParams(window.location.search);
    const testPro = isDevEnvironment && urlParams.get('test_pro') === 'true';
    
    // Method 3: Check if on Pro dashboard (quickfixStep6 visible)
    const proStep = document.getElementById('quickfixStep6');
    const isOnProDashboard = proStep && proStep.style.display !== 'none' && proStep.classList.contains('active');
    
    // For custom domains (production), require real Pro status (localStorage set by Stripe callback)
    if (!isDevEnvironment && !isPro && !isOnProDashboard) {
      console.warn('Production: Pro verification requires Stripe integration');
      this.isProUser = false;
      return false;
    }
    
    this.isProUser = isPro || testPro || isOnProDashboard;
    return this.isProUser;
  }
  
  showToggleButton() {
    const btn = document.getElementById('chatToggleBtn');
    if (btn) btn.style.display = 'flex';
  }
  
  hideToggleButton() {
    const btn = document.getElementById('chatToggleBtn');
    if (btn) btn.style.display = 'none';
  }
  
  addWelcomeMessage() {
    const messagesDiv = document.getElementById('chatMessages');
    if (!messagesDiv) return;
    
    messagesDiv.innerHTML = '';
    
    // Add beta warning for dev/test environments
    const hostname = window.location.hostname;
    const isDevEnvironment = hostname.includes('replit.dev') || 
                            hostname.includes('replit.app') || 
                            hostname.includes('localhost');
    if (isDevEnvironment) {
      this.addBetaWarning();
    }
    
    this.addMessage('assistant', "ðŸ‘‹ Hi! I'm your Pro Priority Support AI. Ask me anything about False Flag Fixer!");
    this.addMessage('assistant', "ðŸ’¡ I can help with:\nâ€¢ How to use QuickFix & Pro features\nâ€¢ Understanding AI detection\nâ€¢ Writing tips to sound human\nâ€¢ Account & billing questions");
  }
  
  addBetaWarning() {
    const messagesDiv = document.getElementById('chatMessages');
    if (!messagesDiv) return;
    
    const warning = document.createElement('div');
    warning.style.cssText = 'background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 12px; margin: 10px 0; text-align: center; color: #92400e;';
    warning.innerHTML = '<strong>ðŸš§ Beta Feature</strong><br>Pro Chat is in testing. Stripe integration coming soon!';
    messagesDiv.appendChild(warning);
  }
  
  openWithSupportGreeting() {
    // Open the chat widget
    const widget = document.getElementById('proChatWidget');
    const btn = document.getElementById('chatToggleBtn');
    
    if (widget) {
      widget.style.display = 'block';
      if (btn) btn.style.display = 'none';
      this.isOpen = true;
      
      // Clear and add support-specific greeting
      const messagesDiv = document.getElementById('chatMessages');
      if (messagesDiv) {
        messagesDiv.innerHTML = '';
        
        // Add beta warning if dev environment
        const hostname = window.location.hostname;
        const isDevEnvironment = hostname.includes('replit.dev') || 
                                hostname.includes('replit.app') || 
                                hostname.includes('localhost');
        if (isDevEnvironment) {
          this.addBetaWarning();
        }
        
        this.addMessage('assistant', "ðŸ‘‹ **Hi! I'm your Pro Priority Support AI.**\n\nI can help with:\nâ€¢ Using QuickFix & Pro features\nâ€¢ AI detection questions\nâ€¢ Billing & subscriptions\nâ€¢ Technical issues\n\nðŸ’¬ **Type your question below!**");
        
        // Add human support option
        this.addHumanSupportOption();
      }
      
      document.getElementById('chatInput')?.focus();
    }
  }
  
  addHumanSupportOption() {
    const messagesDiv = document.getElementById('chatMessages');
    if (!messagesDiv) return;
    
    const optionDiv = document.createElement('div');
    optionDiv.className = 'human-support-option';
    optionDiv.style.cssText = 'margin: 20px 0; padding: 15px; background: linear-gradient(135deg, #00a8e8, #0b0646); border-radius: 10px; text-align: center; color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.2);';
    
    optionDiv.innerHTML = `
      <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">
        Need Human Help?
      </div>
      <p style="font-size: 14px; margin: 0 0 12px 0; opacity: 0.9;">
        Our support team responds within 24 hours
      </p>
      <button onclick="emailHumanSupport()" style="
        background: white;
        color: #00a8e8;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      ">
        <span>Email Human Support</span>
      </button>
      <p style="font-size: 12px; margin: 8px 0 0 0; opacity: 0.8;">
        Pro users get priority response
      </p>
    `;
    
    messagesDiv.appendChild(optionDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  
  toggleChat() {
    this.isOpen = !this.isOpen;
    const widget = document.getElementById('proChatWidget');
    const btn = document.getElementById('chatToggleBtn');
    
    if (this.isOpen) {
      widget.style.display = 'block';
      btn.style.display = 'none';
      document.getElementById('chatInput').focus();
    } else {
      widget.style.display = 'none';
      btn.style.display = 'flex';
    }
  }
  
  updateWordCount() {
    const input = document.getElementById('chatInput');
    const countEl = document.getElementById('chatWordCount');
    if (!input || !countEl) return;
    
    const words = input.value.trim().split(/\s+/).filter(w => w.length > 0).length;
    
    if (words > this.maxWords) {
      countEl.textContent = `âš ï¸ ${words}/${this.maxWords} words - too long!`;
      countEl.style.color = '#dc2626';
    } else if (words > this.maxWords * 0.8) {
      countEl.textContent = `${words}/${this.maxWords} words`;
      countEl.style.color = '#f59e0b';
    } else {
      countEl.textContent = 'ðŸ’Ž Pro feature â€¢ 150 word limit per message';
      countEl.style.color = '#9ca3af';
    }
  }
  
  async sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (!message) return;
    
    // Check word limit
    const words = message.split(/\s+/).filter(w => w.length > 0).length;
    if (words > this.maxWords) {
      this.addMessage('assistant', `âš ï¸ Message too long (${words} words). Please keep it under ${this.maxWords} words.\n\nFor full essay analysis, use QuickFix or Pro Dashboard!`);
      return;
    }
    
    // Re-check Pro status
    if (!this.checkProStatus()) {
      this.addMessage('assistant', 'ðŸ”’ Priority chat is for Pro users only. Upgrade to Pro for instant AI support!');
      return;
    }
    
    // Add user message and clear input
    this.addMessage('user', message);
    input.value = '';
    this.updateWordCount();
    
    // Show typing indicator
    this.showTypingIndicator();
    
    try {
      const response = await fetch(`${window.BACKEND_URL}/api/chat/pro-support`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: message,
          user_id: localStorage.getItem('user_id') || 'anon-' + Date.now(),
          is_pro: true
        })
      });
      
      const data = await response.json();
      
      this.removeTypingIndicator();
      
      if (data.error && response.status === 403) {
        this.addMessage('assistant', 'ðŸ”’ ' + (data.upgrade_message || 'This feature is for Pro users only.'));
      } else if (data.error && response.status === 429) {
        this.addMessage('assistant', 'â³ You\'ve reached the chat limit. Please try again in about an hour.');
      } else if (data.response) {
        this.addMessage('assistant', data.response);
      } else {
        this.addMessage('assistant', 'Sorry, I encountered an error. Please try again.');
      }
      
    } catch (error) {
      console.error('Chat error:', error);
      this.removeTypingIndicator();
      this.addMessage('assistant', 'âš ï¸ Connection issue. Please try again or use the main tool for essay analysis.');
    }
  }
  
  addMessage(role, content) {
    const messagesDiv = document.getElementById('chatMessages');
    if (!messagesDiv) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = 'margin: 8px 0; padding: 12px 16px; border-radius: 16px; max-width: 85%; word-break: break-word; font-size: 14px; line-height: 1.5;';
    
    if (role === 'user') {
      messageDiv.className = 'chat-message-user';
      messageDiv.style.cssText += 'background: linear-gradient(135deg, #00a8e8, #0077b6); color: white; margin-left: auto; border-bottom-right-radius: 4px;';
    } else {
      messageDiv.className = 'chat-message-assistant';
      messageDiv.style.cssText += 'background: #f1f5f9; color: #1e293b; border-bottom-left-radius: 4px;';
    }
    
    // Format content with line breaks and bold
    const formattedContent = content
      .replace(/\n/g, '<br>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>');
    
    messageDiv.innerHTML = formattedContent;
    messagesDiv.appendChild(messageDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    
    this.messageHistory.push({ role, content, timestamp: new Date() });
  }
  
  showTypingIndicator() {
    const messagesDiv = document.getElementById('chatMessages');
    if (!messagesDiv) return;
    
    const typingDiv = document.createElement('div');
    typingDiv.id = 'chatTypingIndicator';
    typingDiv.style.cssText = 'margin: 8px 0; padding: 12px 16px; background: #f1f5f9; border-radius: 16px; display: inline-flex; align-items: center; gap: 6px;';
    typingDiv.innerHTML = `
      <div style="width: 8px; height: 8px; background: #94a3b8; border-radius: 50%; animation: chatTyping 1.4s infinite;"></div>
      <div style="width: 8px; height: 8px; background: #94a3b8; border-radius: 50%; animation: chatTyping 1.4s infinite 0.2s;"></div>
      <div style="width: 8px; height: 8px; background: #94a3b8; border-radius: 50%; animation: chatTyping 1.4s infinite 0.4s;"></div>
    `;
    messagesDiv.appendChild(typingDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  
  removeTypingIndicator() {
    const typing = document.getElementById('chatTypingIndicator');
    if (typing) typing.remove();
  }
}

// Initialize Pro Chat Support

// Smart Support Routing Functions
function openProChatOrRedirect() {
    const isPro = localStorage.getItem('fff_pro_user') === 'true' || 
                  new URLSearchParams(window.location.search).has('test_pro');
    
    if (isPro && window.proChatSupport) {
        // Open Pro Chat for Pro users
        window.proChatSupport.openWithSupportGreeting();
        return;
    }
    
    // Free users go to contact page
    window.open('https://dontturnitinyet.com/contact', '_blank');
}

function emailHumanSupport() {
    const chatHistory = getChatHistoryForEmail();
    const subject = 'False Flag Fixer Pro Support Request';
    const body = 'Please help with:\n\n' +
                 'Chat History:\n' + chatHistory + '\n\n' +
                 'Pro User: Yes\n' +
                 'Timestamp: ' + new Date().toISOString();
    
    window.location.href = 'mailto:support@falseflagfixer.com?subject=' + encodeURIComponent(subject) + '&body=' + encodeURIComponent(body);
}

function getChatHistoryForEmail() {
    const messagesDiv = document.getElementById('chatMessages');
    if (!messagesDiv) return 'No chat history';
    
    const messages = messagesDiv.querySelectorAll('.chat-message');
    let history = '';
    messages.forEach(msg => {
        const role = msg.classList.contains('user') ? 'User' : 'AI';
        history += role + ': ' + msg.textContent.trim().substring(0, 200) + '\n';
    });
    return history || 'No messages';
}

window.proChatSupport = new ProChatSupport();

// Initialize after DOM is ready and other scripts have run
setTimeout(() => {
  window.proChatSupport.initialize();
}, 1000);

// Also check when Pro dashboard is shown
const originalShowProDashboard = window.showProDashboard;
if (typeof originalShowProDashboard === 'function') {
  window.showProDashboard = function() {
    originalShowProDashboard.apply(this, arguments);
    setTimeout(() => {
      localStorage.setItem('fff_pro_user', 'true');
      window.proChatSupport.checkProStatus();
      window.proChatSupport.showToggleButton();
    }, 500);
  };
}
</script>
</body>

</html> 









